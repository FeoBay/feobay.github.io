(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function t(t){for(var r,a,s=t[0],c=t[1],l=t[2],p=0,d=[];p<s.length;p++)a=s[p],Object.prototype.hasOwnProperty.call(i,a)&&i[a]&&d.push(i[a][0]),i[a]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(n[r]=c[r]);for(u&&u(t);d.length;)d.shift()();return o.push.apply(o,l||[]),e()}function e(){for(var n,t=0;t<o.length;t++){for(var e=o[t],r=!0,s=1;s<e.length;s++){var c=e[s];0!==i[c]&&(r=!1)}r&&(o.splice(t--,1),n=a(a.s=e[0]))}return n}var r={},i={8:0},o=[];function a(t){if(r[t])return r[t].exports;var e=r[t]={i:t,l:!1,exports:{}};return n[t].call(e.exports,e,e.exports,a),e.l=!0,e.exports}a.e=function(n){var t=[],e=i[n];if(0!==e)if(e)t.push(e[2]);else{var r=new Promise((function(t,r){e=i[n]=[t,r]}));t.push(e[2]=r);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,a.nc&&s.setAttribute("nonce",a.nc),s.src=function(n){return a.p+"assets/js/"+({9:"vendors~docsearch"}[n]||n)+"."+{1:"b3476b15",2:"f694a8d9",3:"a8cdd41e",4:"8f0cb102",5:"dae9948e",6:"29f5ce59",7:"02397cac",9:"03d43e08",10:"4f685c29",11:"b6c3015f",12:"1e736edf",13:"6ff53e3f",14:"124cad20",15:"634f120f",16:"63a0c807",17:"74e98b2b",18:"78f87d15",19:"41655948",20:"f4781f1b",21:"095e0654",22:"d2d210f6",23:"04a55794",24:"408719a6",25:"9694fa4d",26:"f4b82a81",27:"a4337f6d",28:"d4b9ced4",29:"feb2180f",30:"c19d681f",31:"b577d38d",32:"714c6b8a",33:"642f5e16",34:"2754cb3b",35:"e97ed98c",36:"f66c04ed"}[n]+".js"}(n);var c=new Error;o=function(t){s.onerror=s.onload=null,clearTimeout(l);var e=i[n];if(0!==e){if(e){var r=t&&("load"===t.type?"missing":t.type),o=t&&t.target&&t.target.src;c.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",c.name="ChunkLoadError",c.type=r,c.request=o,e[1](c)}i[n]=void 0}};var l=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(t)},a.m=n,a.c=r,a.d=function(n,t,e){a.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:e})},a.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},a.t=function(n,t){if(1&t&&(n=a(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(a.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var r in n)a.d(e,r,function(t){return n[t]}.bind(null,r));return e},a.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return a.d(t,"a",t),t},a.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},a.p="/",a.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],c=s.push.bind(s);s.push=t,s=s.slice();for(var l=0;l<s.length;l++)t(s[l]);var u=c;o.push([95,0]),e()}([function(n,t,e){"use strict";var r=function(n){return n&&n.Math===Math&&n};n.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof global&&global)||r("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,t,e){"use strict";var r="object"==typeof document&&document.all;n.exports=void 0===r&&void 0!==r?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,t,e){"use strict";var r=e(25),i=Function.prototype,o=i.call,a=r&&i.bind.bind(o,o);n.exports=r?a:function(n){return function(){return o.apply(n,arguments)}}},function(n,t,e){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,t){var e=Array.isArray;n.exports=e},function(n,t,e){"use strict";var r=e(3);n.exports=!r((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,t,e){"use strict";var r=e(1);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,t,e){var r=e(65),i="object"==typeof self&&self&&self.Object===Object&&self,o=r||i||Function("return this")();n.exports=o},function(n,t,e){"use strict";var r=e(2),i=e(34),o=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,t){return o(i(n),t)}},function(n,t,e){var r=e(159),i=e(162);n.exports=function(n,t){var e=i(n,t);return r(e)?e:void 0}},function(n,t){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,t,e){var r=e(13),i=e(144),o=e(145),a=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":a&&a in Object(n)?i(n):o(n)}},function(n,t,e){"use strict";var r=e(5),i=e(15),o=e(26);n.exports=r?function(n,t,e){return i.f(n,t,o(1,e))}:function(n,t,e){return n[t]=e,n}},function(n,t,e){var r=e(7).Symbol;n.exports=r},function(n,t,e){"use strict";function r(n,t,e,r,i,o,a,s){var c,l="function"==typeof n?n.options:n;if(t&&(l.render=t,l.staticRenderFns=e,l._compiled=!0),r&&(l.functional=!0),o&&(l._scopeId="data-v-"+o),a?(c=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(a)},l._ssrRegister=c):i&&(c=s?function(){i.call(this,(l.functional?this.parent:this).$root.$options.shadowRoot)}:i),c)if(l.functional){l._injectStyles=c;var u=l.render;l.render=function(n,t){return c.call(t),u(n,t)}}else{var p=l.beforeCreate;l.beforeCreate=p?[].concat(p,c):[c]}return{exports:n,options:l}}e.d(t,"a",(function(){return r}))},function(n,t,e){"use strict";var r=e(5),i=e(58),o=e(104),a=e(59),s=e(49),c=TypeError,l=Object.defineProperty,u=Object.getOwnPropertyDescriptor;t.f=r?o?function(n,t,e){if(a(n),t=s(t),a(e),"function"==typeof n&&"prototype"===t&&"value"in e&&"writable"in e&&!e.writable){var r=u(n,t);r&&r.writable&&(n[t]=e.value,e={configurable:"configurable"in e?e.configurable:r.configurable,enumerable:"enumerable"in e?e.enumerable:r.enumerable,writable:!1})}return l(n,t,e)}:l:function(n,t,e){if(a(n),t=s(t),a(e),i)try{return l(n,t,e)}catch(n){}if("get"in e||"set"in e)throw new c("Accessors not supported");return"value"in e&&(n[t]=e.value),n}},function(n,t,e){"use strict";var r=e(2),i=r({}.toString),o=r("".slice);n.exports=function(n){return o(i(n),8,-1)}},function(n,t,e){var r=e(149),i=e(150),o=e(151),a=e(152),s=e(153);function c(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=a,c.prototype.set=s,n.exports=c},function(n,t,e){var r=e(67);n.exports=function(n,t){for(var e=n.length;e--;)if(r(n[e][0],t))return e;return-1}},function(n,t,e){var r=e(9)(Object,"create");n.exports=r},function(n,t,e){var r=e(171);n.exports=function(n,t){var e=n.__data__;return r(t)?e["string"==typeof t?"string":"hash"]:e.map}},function(n,t,e){var r=e(43);n.exports=function(n){if("string"==typeof n||r(n))return n;var t=n+"";return"0"==t&&1/n==-1/0?"-0":t}},function(n,t,e){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,t,e={version:"0.2.0"},r=e.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,t,e){return n<t?t:n>e?e:n}function o(n){return 100*(-1+n)}e.configure=function(n){var t,e;for(t in n)void 0!==(e=n[t])&&n.hasOwnProperty(t)&&(r[t]=e);return this},e.status=null,e.set=function(n){var t=e.isStarted();n=i(n,r.minimum,1),e.status=1===n?null:n;var c=e.render(!t),l=c.querySelector(r.barSelector),u=r.speed,p=r.easing;return c.offsetWidth,a((function(t){""===r.positionUsing&&(r.positionUsing=e.getPositioningCSS()),s(l,function(n,t,e){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+t+"ms "+e,i}(n,u,p)),1===n?(s(c,{transition:"none",opacity:1}),c.offsetWidth,setTimeout((function(){s(c,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){e.remove(),t()}),u)}),u)):setTimeout(t,u)})),this},e.isStarted=function(){return"number"==typeof e.status},e.start=function(){e.status||e.set(0);var n=function(){setTimeout((function(){e.status&&(e.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},e.done=function(n){return n||e.status?e.inc(.3+.5*Math.random()).set(1):this},e.inc=function(n){var t=e.status;return t?("number"!=typeof n&&(n=(1-t)*i(Math.random()*t,.1,.95)),t=i(t+n,0,.994),e.set(t)):e.start()},e.trickle=function(){return e.inc(Math.random()*r.trickleRate)},n=0,t=0,e.promise=function(r){return r&&"resolved"!==r.state()?(0===t&&e.start(),n++,t++,r.always((function(){0==--t?(n=0,e.done()):e.set((n-t)/n)})),this):this},e.render=function(n){if(e.isRendered())return document.getElementById("nprogress");l(document.documentElement,"nprogress-busy");var t=document.createElement("div");t.id="nprogress",t.innerHTML=r.template;var i,a=t.querySelector(r.barSelector),c=n?"-100":o(e.status||0),u=document.querySelector(r.parent);return s(a,{transition:"all 0 linear",transform:"translate3d("+c+"%,0,0)"}),r.showSpinner||(i=t.querySelector(r.spinnerSelector))&&d(i),u!=document.body&&l(u,"nprogress-custom-parent"),u.appendChild(t),t},e.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},e.isRendered=function(){return!!document.getElementById("nprogress")},e.getPositioningCSS=function(){var n=document.body.style,t="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return t+"Perspective"in n?"translate3d":t+"Transform"in n?"translate":"margin"};var a=function(){var n=[];function t(){var e=n.shift();e&&e(t)}return function(e){n.push(e),1==n.length&&t()}}(),s=function(){var n=["Webkit","O","Moz","ms"],t={};function e(e){return e=e.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,t){return t.toUpperCase()})),t[e]||(t[e]=function(t){var e=document.body.style;if(t in e)return t;for(var r,i=n.length,o=t.charAt(0).toUpperCase()+t.slice(1);i--;)if((r=n[i]+o)in e)return r;return t}(e))}function r(n,t,r){t=e(t),n.style[t]=r}return function(n,t){var e,i,o=arguments;if(2==o.length)for(e in t)void 0!==(i=t[e])&&t.hasOwnProperty(e)&&r(n,e,i);else r(n,o[1],o[2])}}();function c(n,t){return("string"==typeof n?n:p(n)).indexOf(" "+t+" ")>=0}function l(n,t){var e=p(n),r=e+t;c(e,t)||(n.className=r.substring(1))}function u(n,t){var e,r=p(n);c(n,t)&&(e=r.replace(" "+t+" "," "),n.className=e.substring(1,e.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return e})?r.call(t,e,t,n):r)||(n.exports=i)},function(n,t,e){"use strict";var r=e(0),i=e(46).f,o=e(12),a=e(92),s=e(33),c=e(61),l=e(119);n.exports=function(n,t){var e,u,p,d,f,h=n.target,m=n.global,v=n.stat;if(e=m?r:v?r[h]||s(h,{}):r[h]&&r[h].prototype)for(u in t){if(d=t[u],p=n.dontCallGetSet?(f=i(e,u))&&f.value:e[u],!l(m?u:h+(v?".":"#")+u,n.forced)&&void 0!==p){if(typeof d==typeof p)continue;c(d,p)}(n.sham||p&&p.sham)&&o(d,"sham",!0),a(e,u,d,n)}}},function(n,t,e){"use strict";var r=e(25),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,t,e){"use strict";var r=e(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,t,e){"use strict";n.exports=function(n,t){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:t}}},function(n,t,e){"use strict";var r=e(47),i=e(28);n.exports=function(n){return r(i(n))}},function(n,t,e){"use strict";var r=e(48),i=TypeError;n.exports=function(n){if(r(n))throw new i("Can't call method on "+n);return n}},function(n,t,e){"use strict";var r=e(0),i=e(1),o=function(n){return i(n)?n:void 0};n.exports=function(n,t){return arguments.length<2?o(r[n]):r[n]&&r[n][t]}},function(n,t,e){"use strict";var r=e(1),i=e(101),o=TypeError;n.exports=function(n){if(r(n))return n;throw new o(i(n)+" is not a function")}},function(n,t,e){"use strict";var r=e(0),i=e(55),o=e(8),a=e(57),s=e(53),c=e(52),l=r.Symbol,u=i("wks"),p=c?l.for||l:l&&l.withoutSetter||a;n.exports=function(n){return o(u,n)||(u[n]=s&&o(l,n)?l[n]:p("Symbol."+n)),u[n]}},function(n,t,e){"use strict";var r=e(56),i=e(0),o=e(33),a=n.exports=i["__core-js_shared__"]||o("__core-js_shared__",{});(a.versions||(a.versions=[])).push({version:"3.37.1",mode:r?"pure":"global",copyright:"© 2014-2024 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,t,e){"use strict";var r=e(0),i=Object.defineProperty;n.exports=function(n,t){try{i(r,n,{value:t,configurable:!0,writable:!0})}catch(e){r[n]=t}return t}},function(n,t,e){"use strict";var r=e(28),i=Object;n.exports=function(n){return i(r(n))}},function(n,t,e){"use strict";var r=e(116);n.exports=function(n){return r(n.length)}},function(n,t,e){var r=e(143),i=e(10),o=Object.prototype,a=o.hasOwnProperty,s=o.propertyIsEnumerable,c=r(function(){return arguments}())?r:function(n){return i(n)&&a.call(n,"callee")&&!s.call(n,"callee")};n.exports=c},function(n,t,e){var r=e(9)(e(7),"Map");n.exports=r},function(n,t){n.exports=function(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}},function(n,t,e){var r=e(163),i=e(170),o=e(172),a=e(173),s=e(174);function c(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=a,c.prototype.set=s,n.exports=c},function(n,t){n.exports=function(n){var t=-1,e=Array(n.size);return n.forEach((function(n){e[++t]=n})),e}},function(n,t){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,t,e){var r=e(4),i=e(43),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,a=/^\w*$/;n.exports=function(n,t){if(r(n))return!1;var e=typeof n;return!("number"!=e&&"symbol"!=e&&"boolean"!=e&&null!=n&&!i(n))||(a.test(n)||!o.test(n)||null!=t&&n in Object(t))}},function(n,t,e){var r=e(11),i=e(10);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,t){n.exports=function(n){return n}},function(n,t){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,t,e){"use strict";var r=e(5),i=e(24),o=e(97),a=e(26),s=e(27),c=e(49),l=e(8),u=e(58),p=Object.getOwnPropertyDescriptor;t.f=r?p:function(n,t){if(n=s(n),t=c(t),u)try{return p(n,t)}catch(n){}if(l(n,t))return a(!i(o.f,n,t),n[t])}},function(n,t,e){"use strict";var r=e(2),i=e(3),o=e(16),a=Object,s=r("".split);n.exports=i((function(){return!a("z").propertyIsEnumerable(0)}))?function(n){return"String"===o(n)?s(n,""):a(n)}:a},function(n,t,e){"use strict";n.exports=function(n){return null==n}},function(n,t,e){"use strict";var r=e(98),i=e(50);n.exports=function(n){var t=r(n,"string");return i(t)?t:t+""}},function(n,t,e){"use strict";var r=e(29),i=e(1),o=e(51),a=e(52),s=Object;n.exports=a?function(n){return"symbol"==typeof n}:function(n){var t=r("Symbol");return i(t)&&o(t.prototype,s(n))}},function(n,t,e){"use strict";var r=e(2);n.exports=r({}.isPrototypeOf)},function(n,t,e){"use strict";var r=e(53);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,t,e){"use strict";var r=e(54),i=e(3),o=e(0).String;n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol("symbol detection");return!o(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,t,e){"use strict";var r,i,o=e(0),a=e(99),s=o.process,c=o.Deno,l=s&&s.versions||c&&c.version,u=l&&l.v8;u&&(i=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&a&&(!(r=a.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=a.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,t,e){"use strict";var r=e(32);n.exports=function(n,t){return r[n]||(r[n]=t||{})}},function(n,t,e){"use strict";n.exports=!1},function(n,t,e){"use strict";var r=e(2),i=0,o=Math.random(),a=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+a(++i+o,36)}},function(n,t,e){"use strict";var r=e(5),i=e(3),o=e(103);n.exports=!r&&!i((function(){return 7!==Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,t,e){"use strict";var r=e(6),i=String,o=TypeError;n.exports=function(n){if(r(n))return n;throw new o(i(n)+" is not an object")}},function(n,t,e){"use strict";n.exports={}},function(n,t,e){"use strict";var r=e(8),i=e(110),o=e(46),a=e(15);n.exports=function(n,t,e){for(var s=i(t),c=a.f,l=o.f,u=0;u<s.length;u++){var p=s[u];r(n,p)||e&&r(e,p)||c(n,p,l(t,p))}}},function(n,t,e){"use strict";var r=e(115);n.exports=function(n){var t=+n;return t!=t||0===t?0:r(t)}},function(n,t,e){"use strict";var r=e(126),i=e(6),o=e(28),a=e(127);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,t=!1,e={};try{(n=r(Object.prototype,"__proto__","set"))(e,[]),t=e instanceof Array}catch(n){}return function(e,r){return o(e),a(r),i(e)?(t?n(e,r):e.__proto__=r,e):e}}():void 0)},function(n,t){n.exports=function(n,t){for(var e=-1,r=t.length,i=n.length;++e<r;)n[i+e]=t[e];return n}},function(n,t){var e="object"==typeof global&&global&&global.Object===Object&&global;n.exports=e},function(n,t,e){var r=e(17),i=e(154),o=e(155),a=e(156),s=e(157),c=e(158);function l(n){var t=this.__data__=new r(n);this.size=t.size}l.prototype.clear=i,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=s,l.prototype.set=c,n.exports=l},function(n,t){n.exports=function(n,t){return n===t||n!=n&&t!=t}},function(n,t,e){var r=e(11),i=e(38);n.exports=function(n){if(!i(n))return!1;var t=r(n);return"[object Function]"==t||"[object GeneratorFunction]"==t||"[object AsyncFunction]"==t||"[object Proxy]"==t}},function(n,t){var e=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return e.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,t,e){var r=e(175),i=e(10);n.exports=function n(t,e,o,a,s){return t===e||(null==t||null==e||!i(t)&&!i(e)?t!=t&&e!=e:r(t,e,o,a,n,s))}},function(n,t,e){var r=e(72),i=e(178),o=e(73);n.exports=function(n,t,e,a,s,c){var l=1&e,u=n.length,p=t.length;if(u!=p&&!(l&&p>u))return!1;var d=c.get(n),f=c.get(t);if(d&&f)return d==t&&f==n;var h=-1,m=!0,v=2&e?new r:void 0;for(c.set(n,t),c.set(t,n);++h<u;){var g=n[h],y=t[h];if(a)var b=l?a(y,g,h,t,n,c):a(g,y,h,n,t,c);if(void 0!==b){if(b)continue;m=!1;break}if(v){if(!i(t,(function(n,t){if(!o(v,t)&&(g===n||s(g,n,e,a,c)))return v.push(t)}))){m=!1;break}}else if(g!==y&&!s(g,y,e,a,c)){m=!1;break}}return c.delete(n),c.delete(t),m}},function(n,t,e){var r=e(39),i=e(176),o=e(177);function a(n){var t=-1,e=null==n?0:n.length;for(this.__data__=new r;++t<e;)this.add(n[t])}a.prototype.add=a.prototype.push=i,a.prototype.has=o,n.exports=a},function(n,t){n.exports=function(n,t){return n.has(t)}},function(n,t,e){var r=e(188),i=e(194),o=e(78);n.exports=function(n){return o(n)?r(n):i(n)}},function(n,t,e){(function(n){var r=e(7),i=e(190),o=t&&!t.nodeType&&t,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=a&&a.exports===o?r.Buffer:void 0,c=(s?s.isBuffer:void 0)||i;n.exports=c}).call(this,e(45)(n))},function(n,t){var e=/^(?:0|[1-9]\d*)$/;n.exports=function(n,t){var r=typeof n;return!!(t=null==t?9007199254740991:t)&&("number"==r||"symbol"!=r&&e.test(n))&&n>-1&&n%1==0&&n<t}},function(n,t,e){var r=e(191),i=e(192),o=e(193),a=o&&o.isTypedArray,s=a?i(a):r;n.exports=s},function(n,t,e){var r=e(68),i=e(41);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,t,e){var r=e(9)(e(7),"Set");n.exports=r},function(n,t,e){var r=e(38);n.exports=function(n){return n==n&&!r(n)}},function(n,t){n.exports=function(n,t){return function(e){return null!=e&&(e[n]===t&&(void 0!==t||n in Object(e)))}}},function(n,t,e){var r=e(83),i=e(21);n.exports=function(n,t){for(var e=0,o=(t=r(t,n)).length;null!=n&&e<o;)n=n[i(t[e++])];return e&&e==o?n:void 0}},function(n,t,e){var r=e(4),i=e(42),o=e(205),a=e(208);n.exports=function(n,t){return r(n)?n:i(n,t)?[n]:o(a(n))}},function(n,t,e){},function(n,t,e){},function(n,t,e){var r=e(141),i=e(146),o=e(217),a=e(225),s=e(234),c=e(91),l=o((function(n){var t=c(n);return s(t)&&(t=void 0),a(r(n,1,s,!0),i(t,2))}));n.exports=l},function(n,t,e){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var t,e=""+n,i=r.exec(e);if(!i)return e;var o="",a=0,s=0;for(a=i.index;a<e.length;a++){switch(e.charCodeAt(a)){case 34:t="&quot;";break;case 38:t="&amp;";break;case 39:t="&#39;";break;case 60:t="&lt;";break;case 62:t="&gt;";break;default:continue}s!==a&&(o+=e.substring(s,a)),s=a+1,o+=t}return s!==a?o+e.substring(s,a):o}},function(n,t){var e=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,o=/^0o[0-7]+$/i,a=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,c="object"==typeof self&&self&&self.Object===Object&&self,l=s||c||Function("return this")(),u=Object.prototype.toString,p=Math.max,d=Math.min,f=function(){return l.Date.now()};function h(n){var t=typeof n;return!!n&&("object"==t||"function"==t)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(h(n)){var t="function"==typeof n.valueOf?n.valueOf():n;n=h(t)?t+"":t}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(e,"");var s=i.test(n);return s||o.test(n)?a(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,t,e){var r,i,o,a,s,c,l=0,u=!1,v=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(t){var e=r,o=i;return r=i=void 0,l=t,a=n.apply(o,e)}function b(n){return l=n,s=setTimeout(x,t),u?y(n):a}function _(n){var e=n-c;return void 0===c||e>=t||e<0||v&&n-l>=o}function x(){var n=f();if(_(n))return w(n);s=setTimeout(x,function(n){var e=t-(n-c);return v?d(e,o-(n-l)):e}(n))}function w(n){return s=void 0,g&&r?y(n):(r=i=void 0,a)}function C(){var n=f(),e=_(n);if(r=arguments,i=this,c=n,e){if(void 0===s)return b(c);if(v)return s=setTimeout(x,t),y(c)}return void 0===s&&(s=setTimeout(x,t)),a}return t=m(t)||0,h(e)&&(u=!!e.leading,o=(v="maxWait"in e)?p(m(e.maxWait)||0,t):o,g="trailing"in e?!!e.trailing:g),C.cancel=function(){void 0!==s&&clearTimeout(s),l=0,r=c=i=s=void 0},C.flush=function(){return void 0===s?a:w(f())},C}},function(n,t,e){!function(){"use strict";n.exports={polyfill:function(){var n=window,t=document;if(!("scrollBehavior"in t.documentElement.style)||!0===n.__forceSmoothScrollPolyfill__){var e,r=n.HTMLElement||n.Element,i={scroll:n.scroll||n.scrollTo,scrollBy:n.scrollBy,elementScroll:r.prototype.scroll||s,scrollIntoView:r.prototype.scrollIntoView},o=n.performance&&n.performance.now?n.performance.now.bind(n.performance):Date.now,a=(e=n.navigator.userAgent,new RegExp(["MSIE ","Trident/","Edge/"].join("|")).test(e)?1:0);n.scroll=n.scrollTo=function(){void 0!==arguments[0]&&(!0!==c(arguments[0])?h.call(n,t.body,void 0!==arguments[0].left?~~arguments[0].left:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?~~arguments[0].top:n.scrollY||n.pageYOffset):i.scroll.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:n.scrollY||n.pageYOffset))},n.scrollBy=function(){void 0!==arguments[0]&&(c(arguments[0])?i.scrollBy.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:0,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:0):h.call(n,t.body,~~arguments[0].left+(n.scrollX||n.pageXOffset),~~arguments[0].top+(n.scrollY||n.pageYOffset)))},r.prototype.scroll=r.prototype.scrollTo=function(){if(void 0!==arguments[0])if(!0!==c(arguments[0])){var n=arguments[0].left,t=arguments[0].top;h.call(this,this,void 0===n?this.scrollLeft:~~n,void 0===t?this.scrollTop:~~t)}else{if("number"==typeof arguments[0]&&void 0===arguments[1])throw new SyntaxError("Value could not be converted");i.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left:"object"!=typeof arguments[0]?~~arguments[0]:this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top:void 0!==arguments[1]?~~arguments[1]:this.scrollTop)}},r.prototype.scrollBy=function(){void 0!==arguments[0]&&(!0!==c(arguments[0])?this.scroll({left:~~arguments[0].left+this.scrollLeft,top:~~arguments[0].top+this.scrollTop,behavior:arguments[0].behavior}):i.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left+this.scrollLeft:~~arguments[0]+this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top+this.scrollTop:~~arguments[1]+this.scrollTop))},r.prototype.scrollIntoView=function(){if(!0!==c(arguments[0])){var e=d(this),r=e.getBoundingClientRect(),o=this.getBoundingClientRect();e!==t.body?(h.call(this,e,e.scrollLeft+o.left-r.left,e.scrollTop+o.top-r.top),"fixed"!==n.getComputedStyle(e).position&&n.scrollBy({left:r.left,top:r.top,behavior:"smooth"})):n.scrollBy({left:o.left,top:o.top,behavior:"smooth"})}else i.scrollIntoView.call(this,void 0===arguments[0]||arguments[0])}}function s(n,t){this.scrollLeft=n,this.scrollTop=t}function c(n){if(null===n||"object"!=typeof n||void 0===n.behavior||"auto"===n.behavior||"instant"===n.behavior)return!0;if("object"==typeof n&&"smooth"===n.behavior)return!1;throw new TypeError("behavior member of ScrollOptions "+n.behavior+" is not a valid value for enumeration ScrollBehavior.")}function l(n,t){return"Y"===t?n.clientHeight+a<n.scrollHeight:"X"===t?n.clientWidth+a<n.scrollWidth:void 0}function u(t,e){var r=n.getComputedStyle(t,null)["overflow"+e];return"auto"===r||"scroll"===r}function p(n){var t=l(n,"Y")&&u(n,"Y"),e=l(n,"X")&&u(n,"X");return t||e}function d(n){for(;n!==t.body&&!1===p(n);)n=n.parentNode||n.host;return n}function f(t){var e,r,i,a,s=(o()-t.startTime)/468;a=s=s>1?1:s,e=.5*(1-Math.cos(Math.PI*a)),r=t.startX+(t.x-t.startX)*e,i=t.startY+(t.y-t.startY)*e,t.method.call(t.scrollable,r,i),r===t.x&&i===t.y||n.requestAnimationFrame(f.bind(n,t))}function h(e,r,a){var c,l,u,p,d=o();e===t.body?(c=n,l=n.scrollX||n.pageXOffset,u=n.scrollY||n.pageYOffset,p=i.scroll):(c=e,l=e.scrollLeft,u=e.scrollTop,p=s),f({scrollable:c,method:p,startTime:d,startX:l,startY:u,x:r,y:a})}}}}()},function(n,t,e){"use strict";var r=e(23),i=e(34),o=e(35),a=e(138),s=e(140);r({target:"Array",proto:!0,arity:1,forced:e(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var t=i(this),e=o(t),r=arguments.length;s(e+r);for(var c=0;c<r;c++)t[e]=arguments[c],e++;return a(t,e),e}})},function(n,t){n.exports=function(n){var t=null==n?0:n.length;return t?n[t-1]:void 0}},function(n,t,e){"use strict";var r=e(1),i=e(15),o=e(94),a=e(33);n.exports=function(n,t,e,s){s||(s={});var c=s.enumerable,l=void 0!==s.name?s.name:t;if(r(e)&&o(e,l,s),s.global)c?n[t]=e:a(t,e);else{try{s.unsafe?n[t]&&(c=!0):delete n[t]}catch(n){}c?n[t]=e:i.f(n,t,{value:e,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,t,e){"use strict";var r=e(132),i=String;n.exports=function(n){if("Symbol"===r(n))throw new TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,t,e){"use strict";var r=e(2),i=e(3),o=e(1),a=e(8),s=e(5),c=e(105).CONFIGURABLE,l=e(106),u=e(107),p=u.enforce,d=u.get,f=String,h=Object.defineProperty,m=r("".slice),v=r("".replace),g=r([].join),y=s&&!i((function(){return 8!==h((function(){}),"length",{value:8}).length})),b=String(String).split("String"),_=n.exports=function(n,t,e){"Symbol("===m(f(t),0,7)&&(t="["+v(f(t),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),e&&e.getter&&(t="get "+t),e&&e.setter&&(t="set "+t),(!a(n,"name")||c&&n.name!==t)&&(s?h(n,"name",{value:t,configurable:!0}):n.name=t),y&&e&&a(e,"arity")&&n.length!==e.arity&&h(n,"length",{value:e.arity});try{e&&a(e,"constructor")&&e.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=p(n);return a(r,"source")||(r.source=g(b,"string"==typeof t?t:"")),n};Function.prototype.toString=_((function(){return o(this)&&d(this).source||l(this)}),"toString")},function(n,t,e){n.exports=e(240)},function(n,t,e){"use strict";var r=e(23),i=e(120).left,o=e(121),a=e(54);r({target:"Array",proto:!0,forced:!e(122)&&a>79&&a<83||!o("reduce")},{reduce:function(n){var t=arguments.length;return i(this,n,t,t>1?arguments[1]:void 0)}})},function(n,t,e){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,o=i&&!r.call({1:2},1);t.f=o?function(n){var t=i(this,n);return!!t&&t.enumerable}:r},function(n,t,e){"use strict";var r=e(24),i=e(6),o=e(50),a=e(100),s=e(102),c=e(31),l=TypeError,u=c("toPrimitive");n.exports=function(n,t){if(!i(n)||o(n))return n;var e,c=a(n,u);if(c){if(void 0===t&&(t="default"),e=r(c,n,t),!i(e)||o(e))return e;throw new l("Can't convert object to primitive value")}return void 0===t&&(t="number"),s(n,t)}},function(n,t,e){"use strict";n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,t,e){"use strict";var r=e(30),i=e(48);n.exports=function(n,t){var e=n[t];return i(e)?void 0:r(e)}},function(n,t,e){"use strict";var r=String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,t,e){"use strict";var r=e(24),i=e(1),o=e(6),a=TypeError;n.exports=function(n,t){var e,s;if("string"===t&&i(e=n.toString)&&!o(s=r(e,n)))return s;if(i(e=n.valueOf)&&!o(s=r(e,n)))return s;if("string"!==t&&i(e=n.toString)&&!o(s=r(e,n)))return s;throw new a("Can't convert object to primitive value")}},function(n,t,e){"use strict";var r=e(0),i=e(6),o=r.document,a=i(o)&&i(o.createElement);n.exports=function(n){return a?o.createElement(n):{}}},function(n,t,e){"use strict";var r=e(5),i=e(3);n.exports=r&&i((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,t,e){"use strict";var r=e(5),i=e(8),o=Function.prototype,a=r&&Object.getOwnPropertyDescriptor,s=i(o,"name"),c=s&&"something"===function(){}.name,l=s&&(!r||r&&a(o,"name").configurable);n.exports={EXISTS:s,PROPER:c,CONFIGURABLE:l}},function(n,t,e){"use strict";var r=e(2),i=e(1),o=e(32),a=r(Function.toString);i(o.inspectSource)||(o.inspectSource=function(n){return a(n)}),n.exports=o.inspectSource},function(n,t,e){"use strict";var r,i,o,a=e(108),s=e(0),c=e(6),l=e(12),u=e(8),p=e(32),d=e(109),f=e(60),h=s.TypeError,m=s.WeakMap;if(a||p.state){var v=p.state||(p.state=new m);v.get=v.get,v.has=v.has,v.set=v.set,r=function(n,t){if(v.has(n))throw new h("Object already initialized");return t.facade=n,v.set(n,t),t},i=function(n){return v.get(n)||{}},o=function(n){return v.has(n)}}else{var g=d("state");f[g]=!0,r=function(n,t){if(u(n,g))throw new h("Object already initialized");return t.facade=n,l(n,g,t),t},i=function(n){return u(n,g)?n[g]:{}},o=function(n){return u(n,g)}}n.exports={set:r,get:i,has:o,enforce:function(n){return o(n)?i(n):r(n,{})},getterFor:function(n){return function(t){var e;if(!c(t)||(e=i(t)).type!==n)throw new h("Incompatible receiver, "+n+" required");return e}}}},function(n,t,e){"use strict";var r=e(0),i=e(1),o=r.WeakMap;n.exports=i(o)&&/native code/.test(String(o))},function(n,t,e){"use strict";var r=e(55),i=e(57),o=r("keys");n.exports=function(n){return o[n]||(o[n]=i(n))}},function(n,t,e){"use strict";var r=e(29),i=e(2),o=e(111),a=e(118),s=e(59),c=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var t=o.f(s(n)),e=a.f;return e?c(t,e(n)):t}},function(n,t,e){"use strict";var r=e(112),i=e(117).concat("length","prototype");t.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,t,e){"use strict";var r=e(2),i=e(8),o=e(27),a=e(113).indexOf,s=e(60),c=r([].push);n.exports=function(n,t){var e,r=o(n),l=0,u=[];for(e in r)!i(s,e)&&i(r,e)&&c(u,e);for(;t.length>l;)i(r,e=t[l++])&&(~a(u,e)||c(u,e));return u}},function(n,t,e){"use strict";var r=e(27),i=e(114),o=e(35),a=function(n){return function(t,e,a){var s=r(t),c=o(s);if(0===c)return!n&&-1;var l,u=i(a,c);if(n&&e!=e){for(;c>u;)if((l=s[u++])!=l)return!0}else for(;c>u;u++)if((n||u in s)&&s[u]===e)return n||u||0;return!n&&-1}};n.exports={includes:a(!0),indexOf:a(!1)}},function(n,t,e){"use strict";var r=e(62),i=Math.max,o=Math.min;n.exports=function(n,t){var e=r(n);return e<0?i(e+t,0):o(e,t)}},function(n,t,e){"use strict";var r=Math.ceil,i=Math.floor;n.exports=Math.trunc||function(n){var t=+n;return(t>0?i:r)(t)}},function(n,t,e){"use strict";var r=e(62),i=Math.min;n.exports=function(n){var t=r(n);return t>0?i(t,9007199254740991):0}},function(n,t,e){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,t,e){"use strict";t.f=Object.getOwnPropertySymbols},function(n,t,e){"use strict";var r=e(3),i=e(1),o=/#|\.prototype\./,a=function(n,t){var e=c[s(n)];return e===u||e!==l&&(i(t)?r(t):!!t)},s=a.normalize=function(n){return String(n).replace(o,".").toLowerCase()},c=a.data={},l=a.NATIVE="N",u=a.POLYFILL="P";n.exports=a},function(n,t,e){"use strict";var r=e(30),i=e(34),o=e(47),a=e(35),s=TypeError,c="Reduce of empty array with no initial value",l=function(n){return function(t,e,l,u){var p=i(t),d=o(p),f=a(p);if(r(e),0===f&&l<2)throw new s(c);var h=n?f-1:0,m=n?-1:1;if(l<2)for(;;){if(h in d){u=d[h],h+=m;break}if(h+=m,n?h<0:f<=h)throw new s(c)}for(;n?h>=0:f>h;h+=m)h in d&&(u=e(u,d[h],h,p));return u}};n.exports={left:l(!1),right:l(!0)}},function(n,t,e){"use strict";var r=e(3);n.exports=function(n,t){var e=[][n];return!!e&&r((function(){e.call(null,t||function(){return 1},1)}))}},function(n,t,e){"use strict";var r=e(0),i=e(16);n.exports="process"===i(r.process)},function(n,t,e){"use strict";var r=e(23),i=e(0),o=e(124),a=e(125),s=i.WebAssembly,c=7!==new Error("e",{cause:7}).cause,l=function(n,t){var e={};e[n]=a(n,t,c),r({global:!0,constructor:!0,arity:1,forced:c},e)},u=function(n,t){if(s&&s[n]){var e={};e[n]=a("WebAssembly."+n,t,c),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:c},e)}};l("Error",(function(n){return function(t){return o(n,this,arguments)}})),l("EvalError",(function(n){return function(t){return o(n,this,arguments)}})),l("RangeError",(function(n){return function(t){return o(n,this,arguments)}})),l("ReferenceError",(function(n){return function(t){return o(n,this,arguments)}})),l("SyntaxError",(function(n){return function(t){return o(n,this,arguments)}})),l("TypeError",(function(n){return function(t){return o(n,this,arguments)}})),l("URIError",(function(n){return function(t){return o(n,this,arguments)}})),u("CompileError",(function(n){return function(t){return o(n,this,arguments)}})),u("LinkError",(function(n){return function(t){return o(n,this,arguments)}})),u("RuntimeError",(function(n){return function(t){return o(n,this,arguments)}}))},function(n,t,e){"use strict";var r=e(25),i=Function.prototype,o=i.apply,a=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?a.bind(o):function(){return a.apply(o,arguments)})},function(n,t,e){"use strict";var r=e(29),i=e(8),o=e(12),a=e(51),s=e(63),c=e(61),l=e(129),u=e(130),p=e(131),d=e(134),f=e(135),h=e(5),m=e(56);n.exports=function(n,t,e,v){var g=v?2:1,y=n.split("."),b=y[y.length-1],_=r.apply(null,y);if(_){var x=_.prototype;if(!m&&i(x,"cause")&&delete x.cause,!e)return _;var w=r("Error"),C=t((function(n,t){var e=p(v?t:n,void 0),r=v?new _(n):new _;return void 0!==e&&o(r,"message",e),f(r,C,r.stack,2),this&&a(x,this)&&u(r,this,C),arguments.length>g&&d(r,arguments[g]),r}));if(C.prototype=x,"Error"!==b?s?s(C,w):c(C,w,{name:!0}):h&&"stackTraceLimit"in _&&(l(C,_,"stackTraceLimit"),l(C,_,"prepareStackTrace")),c(C,_),!m)try{x.name!==b&&o(x,"name",b),x.constructor=C}catch(n){}return C}}},function(n,t,e){"use strict";var r=e(2),i=e(30);n.exports=function(n,t,e){try{return r(i(Object.getOwnPropertyDescriptor(n,t)[e]))}catch(n){}}},function(n,t,e){"use strict";var r=e(128),i=String,o=TypeError;n.exports=function(n){if(r(n))return n;throw new o("Can't set "+i(n)+" as a prototype")}},function(n,t,e){"use strict";var r=e(6);n.exports=function(n){return r(n)||null===n}},function(n,t,e){"use strict";var r=e(15).f;n.exports=function(n,t,e){e in n||r(n,e,{configurable:!0,get:function(){return t[e]},set:function(n){t[e]=n}})}},function(n,t,e){"use strict";var r=e(1),i=e(6),o=e(63);n.exports=function(n,t,e){var a,s;return o&&r(a=t.constructor)&&a!==e&&i(s=a.prototype)&&s!==e.prototype&&o(n,s),n}},function(n,t,e){"use strict";var r=e(93);n.exports=function(n,t){return void 0===n?arguments.length<2?"":t:r(n)}},function(n,t,e){"use strict";var r=e(133),i=e(1),o=e(16),a=e(31)("toStringTag"),s=Object,c="Arguments"===o(function(){return arguments}());n.exports=r?o:function(n){var t,e,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(e=function(n,t){try{return n[t]}catch(n){}}(t=s(n),a))?e:c?o(t):"Object"===(r=o(t))&&i(t.callee)?"Arguments":r}},function(n,t,e){"use strict";var r={};r[e(31)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,t,e){"use strict";var r=e(6),i=e(12);n.exports=function(n,t){r(t)&&"cause"in t&&i(n,"cause",t.cause)}},function(n,t,e){"use strict";var r=e(12),i=e(136),o=e(137),a=Error.captureStackTrace;n.exports=function(n,t,e,s){o&&(a?a(n,t):r(n,"stack",i(e,s)))}},function(n,t,e){"use strict";var r=e(2),i=Error,o=r("".replace),a=String(new i("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,c=s.test(a);n.exports=function(n,t){if(c&&"string"==typeof n&&!i.prepareStackTrace)for(;t--;)n=o(n,s,"");return n}},function(n,t,e){"use strict";var r=e(3),i=e(26);n.exports=!r((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,t,e){"use strict";var r=e(5),i=e(139),o=TypeError,a=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,t){if(i(n)&&!a(n,"length").writable)throw new o("Cannot set read only .length");return n.length=t}:function(n,t){return n.length=t}},function(n,t,e){"use strict";var r=e(16);n.exports=Array.isArray||function(n){return"Array"===r(n)}},function(n,t,e){"use strict";var r=TypeError;n.exports=function(n){if(n>9007199254740991)throw r("Maximum allowed index exceeded");return n}},function(n,t,e){var r=e(64),i=e(142);n.exports=function n(t,e,o,a,s){var c=-1,l=t.length;for(o||(o=i),s||(s=[]);++c<l;){var u=t[c];e>0&&o(u)?e>1?n(u,e-1,o,a,s):r(s,u):a||(s[s.length]=u)}return s}},function(n,t,e){var r=e(13),i=e(36),o=e(4),a=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||i(n)||!!(a&&n&&n[a])}},function(n,t,e){var r=e(11),i=e(10);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,t,e){var r=e(13),i=Object.prototype,o=i.hasOwnProperty,a=i.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var t=o.call(n,s),e=n[s];try{n[s]=void 0;var r=!0}catch(n){}var i=a.call(n);return r&&(t?n[s]=e:delete n[s]),i}},function(n,t){var e=Object.prototype.toString;n.exports=function(n){return e.call(n)}},function(n,t,e){var r=e(147),i=e(203),o=e(44),a=e(4),s=e(214);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?a(n)?i(n[0],n[1]):r(n):s(n)}},function(n,t,e){var r=e(148),i=e(202),o=e(81);n.exports=function(n){var t=i(n);return 1==t.length&&t[0][2]?o(t[0][0],t[0][1]):function(e){return e===n||r(e,n,t)}}},function(n,t,e){var r=e(66),i=e(70);n.exports=function(n,t,e,o){var a=e.length,s=a,c=!o;if(null==n)return!s;for(n=Object(n);a--;){var l=e[a];if(c&&l[2]?l[1]!==n[l[0]]:!(l[0]in n))return!1}for(;++a<s;){var u=(l=e[a])[0],p=n[u],d=l[1];if(c&&l[2]){if(void 0===p&&!(u in n))return!1}else{var f=new r;if(o)var h=o(p,d,u,n,t,f);if(!(void 0===h?i(d,p,3,o,f):h))return!1}}return!0}},function(n,t){n.exports=function(){this.__data__=[],this.size=0}},function(n,t,e){var r=e(18),i=Array.prototype.splice;n.exports=function(n){var t=this.__data__,e=r(t,n);return!(e<0)&&(e==t.length-1?t.pop():i.call(t,e,1),--this.size,!0)}},function(n,t,e){var r=e(18);n.exports=function(n){var t=this.__data__,e=r(t,n);return e<0?void 0:t[e][1]}},function(n,t,e){var r=e(18);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,t,e){var r=e(18);n.exports=function(n,t){var e=this.__data__,i=r(e,n);return i<0?(++this.size,e.push([n,t])):e[i][1]=t,this}},function(n,t,e){var r=e(17);n.exports=function(){this.__data__=new r,this.size=0}},function(n,t){n.exports=function(n){var t=this.__data__,e=t.delete(n);return this.size=t.size,e}},function(n,t){n.exports=function(n){return this.__data__.get(n)}},function(n,t){n.exports=function(n){return this.__data__.has(n)}},function(n,t,e){var r=e(17),i=e(37),o=e(39);n.exports=function(n,t){var e=this.__data__;if(e instanceof r){var a=e.__data__;if(!i||a.length<199)return a.push([n,t]),this.size=++e.size,this;e=this.__data__=new o(a)}return e.set(n,t),this.size=e.size,this}},function(n,t,e){var r=e(68),i=e(160),o=e(38),a=e(69),s=/^\[object .+?Constructor\]$/,c=Function.prototype,l=Object.prototype,u=c.toString,p=l.hasOwnProperty,d=RegExp("^"+u.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||i(n))&&(r(n)?d:s).test(a(n))}},function(n,t,e){var r,i=e(161),o=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,t,e){var r=e(7)["__core-js_shared__"];n.exports=r},function(n,t){n.exports=function(n,t){return null==n?void 0:n[t]}},function(n,t,e){var r=e(164),i=e(17),o=e(37);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||i),string:new r}}},function(n,t,e){var r=e(165),i=e(166),o=e(167),a=e(168),s=e(169);function c(n){var t=-1,e=null==n?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=a,c.prototype.set=s,n.exports=c},function(n,t,e){var r=e(19);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,t){n.exports=function(n){var t=this.has(n)&&delete this.__data__[n];return this.size-=t?1:0,t}},function(n,t,e){var r=e(19),i=Object.prototype.hasOwnProperty;n.exports=function(n){var t=this.__data__;if(r){var e=t[n];return"__lodash_hash_undefined__"===e?void 0:e}return i.call(t,n)?t[n]:void 0}},function(n,t,e){var r=e(19),i=Object.prototype.hasOwnProperty;n.exports=function(n){var t=this.__data__;return r?void 0!==t[n]:i.call(t,n)}},function(n,t,e){var r=e(19);n.exports=function(n,t){var e=this.__data__;return this.size+=this.has(n)?0:1,e[n]=r&&void 0===t?"__lodash_hash_undefined__":t,this}},function(n,t,e){var r=e(20);n.exports=function(n){var t=r(this,n).delete(n);return this.size-=t?1:0,t}},function(n,t){n.exports=function(n){var t=typeof n;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==n:null===n}},function(n,t,e){var r=e(20);n.exports=function(n){return r(this,n).get(n)}},function(n,t,e){var r=e(20);n.exports=function(n){return r(this,n).has(n)}},function(n,t,e){var r=e(20);n.exports=function(n,t){var e=r(this,n),i=e.size;return e.set(n,t),this.size+=e.size==i?0:1,this}},function(n,t,e){var r=e(66),i=e(71),o=e(179),a=e(182),s=e(198),c=e(4),l=e(75),u=e(77),p="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,t,e,f,h,m){var v=c(n),g=c(t),y=v?"[object Array]":s(n),b=g?"[object Array]":s(t),_=(y="[object Arguments]"==y?p:y)==p,x=(b="[object Arguments]"==b?p:b)==p,w=y==b;if(w&&l(n)){if(!l(t))return!1;v=!0,_=!1}if(w&&!_)return m||(m=new r),v||u(n)?i(n,t,e,f,h,m):o(n,t,y,e,f,h,m);if(!(1&e)){var C=_&&d.call(n,"__wrapped__"),k=x&&d.call(t,"__wrapped__");if(C||k){var A=C?n.value():n,P=k?t.value():t;return m||(m=new r),h(A,P,e,f,m)}}return!!w&&(m||(m=new r),a(n,t,e,f,h,m))}},function(n,t){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,t){n.exports=function(n){return this.__data__.has(n)}},function(n,t){n.exports=function(n,t){for(var e=-1,r=null==n?0:n.length;++e<r;)if(t(n[e],e,n))return!0;return!1}},function(n,t,e){var r=e(13),i=e(180),o=e(67),a=e(71),s=e(181),c=e(40),l=r?r.prototype:void 0,u=l?l.valueOf:void 0;n.exports=function(n,t,e,r,l,p,d){switch(e){case"[object DataView]":if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)return!1;n=n.buffer,t=t.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=t.byteLength||!p(new i(n),new i(t)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+t);case"[object Error]":return n.name==t.name&&n.message==t.message;case"[object RegExp]":case"[object String]":return n==t+"";case"[object Map]":var f=s;case"[object Set]":var h=1&r;if(f||(f=c),n.size!=t.size&&!h)return!1;var m=d.get(n);if(m)return m==t;r|=2,d.set(n,t);var v=a(f(n),f(t),r,l,p,d);return d.delete(n),v;case"[object Symbol]":if(u)return u.call(n)==u.call(t)}return!1}},function(n,t,e){var r=e(7).Uint8Array;n.exports=r},function(n,t){n.exports=function(n){var t=-1,e=Array(n.size);return n.forEach((function(n,r){e[++t]=[r,n]})),e}},function(n,t,e){var r=e(183),i=Object.prototype.hasOwnProperty;n.exports=function(n,t,e,o,a,s){var c=1&e,l=r(n),u=l.length;if(u!=r(t).length&&!c)return!1;for(var p=u;p--;){var d=l[p];if(!(c?d in t:i.call(t,d)))return!1}var f=s.get(n),h=s.get(t);if(f&&h)return f==t&&h==n;var m=!0;s.set(n,t),s.set(t,n);for(var v=c;++p<u;){var g=n[d=l[p]],y=t[d];if(o)var b=c?o(y,g,d,t,n,s):o(g,y,d,n,t,s);if(!(void 0===b?g===y||a(g,y,e,o,s):b)){m=!1;break}v||(v="constructor"==d)}if(m&&!v){var _=n.constructor,x=t.constructor;_==x||!("constructor"in n)||!("constructor"in t)||"function"==typeof _&&_ instanceof _&&"function"==typeof x&&x instanceof x||(m=!1)}return s.delete(n),s.delete(t),m}},function(n,t,e){var r=e(184),i=e(185),o=e(74);n.exports=function(n){return r(n,o,i)}},function(n,t,e){var r=e(64),i=e(4);n.exports=function(n,t,e){var o=t(n);return i(n)?o:r(o,e(n))}},function(n,t,e){var r=e(186),i=e(187),o=Object.prototype.propertyIsEnumerable,a=Object.getOwnPropertySymbols,s=a?function(n){return null==n?[]:(n=Object(n),r(a(n),(function(t){return o.call(n,t)})))}:i;n.exports=s},function(n,t){n.exports=function(n,t){for(var e=-1,r=null==n?0:n.length,i=0,o=[];++e<r;){var a=n[e];t(a,e,n)&&(o[i++]=a)}return o}},function(n,t){n.exports=function(){return[]}},function(n,t,e){var r=e(189),i=e(36),o=e(4),a=e(75),s=e(76),c=e(77),l=Object.prototype.hasOwnProperty;n.exports=function(n,t){var e=o(n),u=!e&&i(n),p=!e&&!u&&a(n),d=!e&&!u&&!p&&c(n),f=e||u||p||d,h=f?r(n.length,String):[],m=h.length;for(var v in n)!t&&!l.call(n,v)||f&&("length"==v||p&&("offset"==v||"parent"==v)||d&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||s(v,m))||h.push(v);return h}},function(n,t){n.exports=function(n,t){for(var e=-1,r=Array(n);++e<n;)r[e]=t(e);return r}},function(n,t){n.exports=function(){return!1}},function(n,t,e){var r=e(11),i=e(41),o=e(10),a={};a["[object Float32Array]"]=a["[object Float64Array]"]=a["[object Int8Array]"]=a["[object Int16Array]"]=a["[object Int32Array]"]=a["[object Uint8Array]"]=a["[object Uint8ClampedArray]"]=a["[object Uint16Array]"]=a["[object Uint32Array]"]=!0,a["[object Arguments]"]=a["[object Array]"]=a["[object ArrayBuffer]"]=a["[object Boolean]"]=a["[object DataView]"]=a["[object Date]"]=a["[object Error]"]=a["[object Function]"]=a["[object Map]"]=a["[object Number]"]=a["[object Object]"]=a["[object RegExp]"]=a["[object Set]"]=a["[object String]"]=a["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&i(n.length)&&!!a[r(n)]}},function(n,t){n.exports=function(n){return function(t){return n(t)}}},function(n,t,e){(function(n){var r=e(65),i=t&&!t.nodeType&&t,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,a=o&&o.exports===i&&r.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||a&&a.binding&&a.binding("util")}catch(n){}}();n.exports=s}).call(this,e(45)(n))},function(n,t,e){var r=e(195),i=e(196),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var t=[];for(var e in Object(n))o.call(n,e)&&"constructor"!=e&&t.push(e);return t}},function(n,t){var e=Object.prototype;n.exports=function(n){var t=n&&n.constructor;return n===("function"==typeof t&&t.prototype||e)}},function(n,t,e){var r=e(197)(Object.keys,Object);n.exports=r},function(n,t){n.exports=function(n,t){return function(e){return n(t(e))}}},function(n,t,e){var r=e(199),i=e(37),o=e(200),a=e(79),s=e(201),c=e(11),l=e(69),u=l(r),p=l(i),d=l(o),f=l(a),h=l(s),m=c;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=m(new i)||o&&"[object Promise]"!=m(o.resolve())||a&&"[object Set]"!=m(new a)||s&&"[object WeakMap]"!=m(new s))&&(m=function(n){var t=c(n),e="[object Object]"==t?n.constructor:void 0,r=e?l(e):"";if(r)switch(r){case u:return"[object DataView]";case p:return"[object Map]";case d:return"[object Promise]";case f:return"[object Set]";case h:return"[object WeakMap]"}return t}),n.exports=m},function(n,t,e){var r=e(9)(e(7),"DataView");n.exports=r},function(n,t,e){var r=e(9)(e(7),"Promise");n.exports=r},function(n,t,e){var r=e(9)(e(7),"WeakMap");n.exports=r},function(n,t,e){var r=e(80),i=e(74);n.exports=function(n){for(var t=i(n),e=t.length;e--;){var o=t[e],a=n[o];t[e]=[o,a,r(a)]}return t}},function(n,t,e){var r=e(70),i=e(204),o=e(211),a=e(42),s=e(80),c=e(81),l=e(21);n.exports=function(n,t){return a(n)&&s(t)?c(l(n),t):function(e){var a=i(e,n);return void 0===a&&a===t?o(e,n):r(t,a,3)}}},function(n,t,e){var r=e(82);n.exports=function(n,t,e){var i=null==n?void 0:r(n,t);return void 0===i?e:i}},function(n,t,e){var r=e(206),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,a=r((function(n){var t=[];return 46===n.charCodeAt(0)&&t.push(""),n.replace(i,(function(n,e,r,i){t.push(r?i.replace(o,"$1"):e||n)})),t}));n.exports=a},function(n,t,e){var r=e(207);n.exports=function(n){var t=r(n,(function(n){return 500===e.size&&e.clear(),n})),e=t.cache;return t}},function(n,t,e){var r=e(39);function i(n,t){if("function"!=typeof n||null!=t&&"function"!=typeof t)throw new TypeError("Expected a function");var e=function(){var r=arguments,i=t?t.apply(this,r):r[0],o=e.cache;if(o.has(i))return o.get(i);var a=n.apply(this,r);return e.cache=o.set(i,a)||o,a};return e.cache=new(i.Cache||r),e}i.Cache=r,n.exports=i},function(n,t,e){var r=e(209);n.exports=function(n){return null==n?"":r(n)}},function(n,t,e){var r=e(13),i=e(210),o=e(4),a=e(43),s=r?r.prototype:void 0,c=s?s.toString:void 0;n.exports=function n(t){if("string"==typeof t)return t;if(o(t))return i(t,n)+"";if(a(t))return c?c.call(t):"";var e=t+"";return"0"==e&&1/t==-1/0?"-0":e}},function(n,t){n.exports=function(n,t){for(var e=-1,r=null==n?0:n.length,i=Array(r);++e<r;)i[e]=t(n[e],e,n);return i}},function(n,t,e){var r=e(212),i=e(213);n.exports=function(n,t){return null!=n&&i(n,t,r)}},function(n,t){n.exports=function(n,t){return null!=n&&t in Object(n)}},function(n,t,e){var r=e(83),i=e(36),o=e(4),a=e(76),s=e(41),c=e(21);n.exports=function(n,t,e){for(var l=-1,u=(t=r(t,n)).length,p=!1;++l<u;){var d=c(t[l]);if(!(p=null!=n&&e(n,d)))break;n=n[d]}return p||++l!=u?p:!!(u=null==n?0:n.length)&&s(u)&&a(d,u)&&(o(n)||i(n))}},function(n,t,e){var r=e(215),i=e(216),o=e(42),a=e(21);n.exports=function(n){return o(n)?r(a(n)):i(n)}},function(n,t){n.exports=function(n){return function(t){return null==t?void 0:t[n]}}},function(n,t,e){var r=e(82);n.exports=function(n){return function(t){return r(t,n)}}},function(n,t,e){var r=e(44),i=e(218),o=e(220);n.exports=function(n,t){return o(i(n,t,r),n+"")}},function(n,t,e){var r=e(219),i=Math.max;n.exports=function(n,t,e){return t=i(void 0===t?n.length-1:t,0),function(){for(var o=arguments,a=-1,s=i(o.length-t,0),c=Array(s);++a<s;)c[a]=o[t+a];a=-1;for(var l=Array(t+1);++a<t;)l[a]=o[a];return l[t]=e(c),r(n,this,l)}}},function(n,t){n.exports=function(n,t,e){switch(e.length){case 0:return n.call(t);case 1:return n.call(t,e[0]);case 2:return n.call(t,e[0],e[1]);case 3:return n.call(t,e[0],e[1],e[2])}return n.apply(t,e)}},function(n,t,e){var r=e(221),i=e(224)(r);n.exports=i},function(n,t,e){var r=e(222),i=e(223),o=e(44),a=i?function(n,t){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(t),writable:!0})}:o;n.exports=a},function(n,t){n.exports=function(n){return function(){return n}}},function(n,t,e){var r=e(9),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,t){var e=Date.now;n.exports=function(n){var t=0,r=0;return function(){var i=e(),o=16-(i-r);if(r=i,o>0){if(++t>=800)return arguments[0]}else t=0;return n.apply(void 0,arguments)}}},function(n,t,e){var r=e(72),i=e(226),o=e(231),a=e(73),s=e(232),c=e(40);n.exports=function(n,t,e){var l=-1,u=i,p=n.length,d=!0,f=[],h=f;if(e)d=!1,u=o;else if(p>=200){var m=t?null:s(n);if(m)return c(m);d=!1,u=a,h=new r}else h=t?[]:f;n:for(;++l<p;){var v=n[l],g=t?t(v):v;if(v=e||0!==v?v:0,d&&g==g){for(var y=h.length;y--;)if(h[y]===g)continue n;t&&h.push(g),f.push(v)}else u(h,g,e)||(h!==f&&h.push(g),f.push(v))}return f}},function(n,t,e){var r=e(227);n.exports=function(n,t){return!!(null==n?0:n.length)&&r(n,t,0)>-1}},function(n,t,e){var r=e(228),i=e(229),o=e(230);n.exports=function(n,t,e){return t==t?o(n,t,e):r(n,i,e)}},function(n,t){n.exports=function(n,t,e,r){for(var i=n.length,o=e+(r?1:-1);r?o--:++o<i;)if(t(n[o],o,n))return o;return-1}},function(n,t){n.exports=function(n){return n!=n}},function(n,t){n.exports=function(n,t,e){for(var r=e-1,i=n.length;++r<i;)if(n[r]===t)return r;return-1}},function(n,t){n.exports=function(n,t,e){for(var r=-1,i=null==n?0:n.length;++r<i;)if(e(t,n[r]))return!0;return!1}},function(n,t,e){var r=e(79),i=e(233),o=e(40),a=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=a},function(n,t){n.exports=function(){}},function(n,t,e){var r=e(78),i=e(10);n.exports=function(n){return i(n)&&r(n)}},function(n,t,e){},function(n,t,e){},function(n,t,e){},function(n,t,e){"use strict";e(84)},function(n,t,e){"use strict";e(85)},function(n,t,e){"use strict";e.r(t);
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),i=Array.isArray;function o(n){return null==n}function a(n){return null!=n}function s(n){return!0===n}function c(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function l(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var p=Object.prototype.toString;function d(n){return"[object Object]"===p.call(n)}function f(n){return"[object RegExp]"===p.call(n)}function h(n){var t=parseFloat(String(n));return t>=0&&Math.floor(t)===t&&isFinite(n)}function m(n){return a(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function v(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===p?JSON.stringify(n,g,2):String(n)}function g(n,t){return t&&t.__v_isRef?t.value:t}function y(n){var t=parseFloat(n);return isNaN(t)?n:t}function b(n,t){for(var e=Object.create(null),r=n.split(","),i=0;i<r.length;i++)e[r[i]]=!0;return t?function(n){return e[n.toLowerCase()]}:function(n){return e[n]}}b("slot,component",!0);var _=b("key,ref,slot,slot-scope,is");function x(n,t){var e=n.length;if(e){if(t===n[e-1])return void(n.length=e-1);var r=n.indexOf(t);if(r>-1)return n.splice(r,1)}}var w=Object.prototype.hasOwnProperty;function C(n,t){return w.call(n,t)}function k(n){var t=Object.create(null);return function(e){return t[e]||(t[e]=n(e))}}var A=/-(\w)/g,P=k((function(n){return n.replace(A,(function(n,t){return t?t.toUpperCase():""}))})),S=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),j=/\B([A-Z])/g,O=k((function(n){return n.replace(j,"-$1").toLowerCase()}));var L=Function.prototype.bind?function(n,t){return n.bind(t)}:function(n,t){function e(e){var r=arguments.length;return r?r>1?n.apply(t,arguments):n.call(t,e):n.call(t)}return e._length=n.length,e};function E(n,t){t=t||0;for(var e=n.length-t,r=new Array(e);e--;)r[e]=n[e+t];return r}function N(n,t){for(var e in t)n[e]=t[e];return n}function T(n){for(var t={},e=0;e<n.length;e++)n[e]&&N(t,n[e]);return t}function B(n,t,e){}var $=function(n,t,e){return!1},I=function(n){return n};function R(n,t){if(n===t)return!0;var e=u(n),r=u(t);if(!e||!r)return!e&&!r&&String(n)===String(t);try{var i=Array.isArray(n),o=Array.isArray(t);if(i&&o)return n.length===t.length&&n.every((function(n,e){return R(n,t[e])}));if(n instanceof Date&&t instanceof Date)return n.getTime()===t.getTime();if(i||o)return!1;var a=Object.keys(n),s=Object.keys(t);return a.length===s.length&&a.every((function(e){return R(n[e],t[e])}))}catch(n){return!1}}function M(n,t){for(var e=0;e<n.length;e++)if(R(n[e],t))return e;return-1}function D(n){var t=!1;return function(){t||(t=!0,n.apply(this,arguments))}}function U(n,t){return n===t?0===n&&1/n!=1/t:n==n||t==t}var z=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],H={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:$,isReservedAttr:$,isUnknownElement:$,getTagNamespace:B,parsePlatformTagName:I,mustUseProp:$,async:!0,_lifecycleHooks:F},q=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function W(n){var t=(n+"").charCodeAt(0);return 36===t||95===t}function V(n,t,e,r){Object.defineProperty(n,t,{value:e,enumerable:!!r,writable:!0,configurable:!0})}var G=new RegExp("[^".concat(q.source,".$_\\d]"));var K="__proto__"in{},X="undefined"!=typeof window,Y=X&&window.navigator.userAgent.toLowerCase(),J=Y&&/msie|trident/.test(Y),Q=Y&&Y.indexOf("msie 9.0")>0,Z=Y&&Y.indexOf("edge/")>0;Y&&Y.indexOf("android");var nn=Y&&/iphone|ipad|ipod|ios/.test(Y);Y&&/chrome\/\d+/.test(Y),Y&&/phantomjs/.test(Y);var tn,en=Y&&Y.match(/firefox\/(\d+)/),rn={}.watch,on=!1;if(X)try{var an={};Object.defineProperty(an,"passive",{get:function(){on=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var sn=function(){return void 0===tn&&(tn=!X&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),tn},cn=X&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var un,pn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);un="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function fn(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var hn=function(){function n(n,t,e,r,i,o,a,s){this.tag=n,this.data=t,this.children=e,this.text=r,this.elm=i,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),mn=function(n){void 0===n&&(n="");var t=new hn;return t.text=n,t.isComment=!0,t};function vn(n){return new hn(void 0,void 0,void 0,String(n))}function gn(n){var t=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return t.ns=n.ns,t.isStatic=n.isStatic,t.key=n.key,t.isComment=n.isComment,t.fnContext=n.fnContext,t.fnOptions=n.fnOptions,t.fnScopeId=n.fnScopeId,t.asyncMeta=n.asyncMeta,t.isCloned=!0,t}"function"==typeof SuppressedError&&SuppressedError;var yn=0,bn=[],_n=function(){function n(){this._pending=!1,this.id=yn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(t){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var t=this.subs.filter((function(n){return n}));for(var e=0,r=t.length;e<r;e++){0,t[e].update()}},n}();_n.target=null;var xn=[];function wn(n){xn.push(n),_n.target=n}function Cn(){xn.pop(),_n.target=xn[xn.length-1]}var kn=Array.prototype,An=Object.create(kn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var t=kn[n];V(An,n,(function(){for(var e=[],r=0;r<arguments.length;r++)e[r]=arguments[r];var i,o=t.apply(this,e),a=this.__ob__;switch(n){case"push":case"unshift":i=e;break;case"splice":i=e.slice(2)}return i&&a.observeArray(i),a.dep.notify(),o}))}));var Pn=Object.getOwnPropertyNames(An),Sn={},jn=!0;function On(n){jn=n}var Ln={notify:B,depend:B,addSub:B,removeSub:B},En=function(){function n(n,t,e){if(void 0===t&&(t=!1),void 0===e&&(e=!1),this.value=n,this.shallow=t,this.mock=e,this.dep=e?Ln:new _n,this.vmCount=0,V(n,"__ob__",this),i(n)){if(!e)if(K)n.__proto__=An;else for(var r=0,o=Pn.length;r<o;r++){V(n,s=Pn[r],An[s])}t||this.observeArray(n)}else{var a=Object.keys(n);for(r=0;r<a.length;r++){var s;Tn(n,s=a[r],Sn,void 0,t,e)}}}return n.prototype.observeArray=function(n){for(var t=0,e=n.length;t<e;t++)Nn(n[t],!1,this.mock)},n}();function Nn(n,t,e){return n&&C(n,"__ob__")&&n.__ob__ instanceof En?n.__ob__:!jn||!e&&sn()||!i(n)&&!d(n)||!Object.isExtensible(n)||n.__v_skip||Un(n)||n instanceof hn?void 0:new En(n,t,e)}function Tn(n,t,e,r,o,a,s){void 0===s&&(s=!1);var c=new _n,l=Object.getOwnPropertyDescriptor(n,t);if(!l||!1!==l.configurable){var u=l&&l.get,p=l&&l.set;u&&!p||e!==Sn&&2!==arguments.length||(e=n[t]);var d=o?e&&e.__ob__:Nn(e,!1,a);return Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var t=u?u.call(n):e;return _n.target&&(c.depend(),d&&(d.dep.depend(),i(t)&&In(t))),Un(t)&&!o?t.value:t},set:function(t){var r=u?u.call(n):e;if(U(r,t)){if(p)p.call(n,t);else{if(u)return;if(!o&&Un(r)&&!Un(t))return void(r.value=t);e=t}d=o?t&&t.__ob__:Nn(t,!1,a),c.notify()}}}),c}}function Bn(n,t,e){if(!Dn(n)){var r=n.__ob__;return i(n)&&h(t)?(n.length=Math.max(n.length,t),n.splice(t,1,e),r&&!r.shallow&&r.mock&&Nn(e,!1,!0),e):t in n&&!(t in Object.prototype)?(n[t]=e,e):n._isVue||r&&r.vmCount?e:r?(Tn(r.value,t,e,void 0,r.shallow,r.mock),r.dep.notify(),e):(n[t]=e,e)}}function $n(n,t){if(i(n)&&h(t))n.splice(t,1);else{var e=n.__ob__;n._isVue||e&&e.vmCount||Dn(n)||C(n,t)&&(delete n[t],e&&e.dep.notify())}}function In(n){for(var t=void 0,e=0,r=n.length;e<r;e++)(t=n[e])&&t.__ob__&&t.__ob__.dep.depend(),i(t)&&In(t)}function Rn(n){return Mn(n,!0),V(n,"__v_isShallow",!0),n}function Mn(n,t){if(!Dn(n)){Nn(n,t,sn());0}}function Dn(n){return!(!n||!n.__v_isReadonly)}function Un(n){return!(!n||!0!==n.__v_isRef)}function zn(n,t,e){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var n=t[e];if(Un(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=t[e];Un(r)&&!Un(n)?r.value=n:t[e]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Fn;var Hn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Fn,!n&&Fn&&(this.index=(Fn.scopes||(Fn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var t=Fn;try{return Fn=this,n()}finally{Fn=t}}else 0},n.prototype.on=function(){Fn=this},n.prototype.off=function(){Fn=this.parent},n.prototype.stop=function(n){if(this.active){var t=void 0,e=void 0;for(t=0,e=this.effects.length;t<e;t++)this.effects[t].teardown();for(t=0,e=this.cleanups.length;t<e;t++)this.cleanups[t]();if(this.scopes)for(t=0,e=this.scopes.length;t<e;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function qn(n){var t=n._provided,e=n.$parent&&n.$parent._provided;return e===t?n._provided=Object.create(e):t}var Wn=k((function(n){var t="&"===n.charAt(0),e="~"===(n=t?n.slice(1):n).charAt(0),r="!"===(n=e?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:e,capture:r,passive:t}}));function Vn(n,t){function e(){var n=e.fns;if(!i(n))return jt(n,null,arguments,t,"v-on handler");for(var r=n.slice(),o=0;o<r.length;o++)jt(r[o],null,arguments,t,"v-on handler")}return e.fns=n,e}function Gn(n,t,e,r,i,a){var c,l,u,p;for(c in n)l=n[c],u=t[c],p=Wn(c),o(l)||(o(u)?(o(l.fns)&&(l=n[c]=Vn(l,a)),s(p.once)&&(l=n[c]=i(p.name,l,p.capture)),e(p.name,l,p.capture,p.passive,p.params)):l!==u&&(u.fns=l,n[c]=u));for(c in t)o(n[c])&&r((p=Wn(c)).name,t[c],p.capture)}function Kn(n,t,e){var r;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var i=n[t];function c(){e.apply(this,arguments),x(r.fns,c)}o(i)?r=Vn([c]):a(i.fns)&&s(i.merged)?(r=i).fns.push(c):r=Vn([i,c]),r.merged=!0,n[t]=r}function Xn(n,t,e,r,i){if(a(t)){if(C(t,e))return n[e]=t[e],i||delete t[e],!0;if(C(t,r))return n[e]=t[r],i||delete t[r],!0}return!1}function Yn(n){return c(n)?[vn(n)]:i(n)?function n(t,e){var r,l,u,p,d=[];for(r=0;r<t.length;r++)o(l=t[r])||"boolean"==typeof l||(u=d.length-1,p=d[u],i(l)?l.length>0&&(Jn((l=n(l,"".concat(e||"","_").concat(r)))[0])&&Jn(p)&&(d[u]=vn(p.text+l[0].text),l.shift()),d.push.apply(d,l)):c(l)?Jn(p)?d[u]=vn(p.text+l):""!==l&&d.push(vn(l)):Jn(l)&&Jn(p)?d[u]=vn(p.text+l.text):(s(t._isVList)&&a(l.tag)&&o(l.key)&&a(e)&&(l.key="__vlist".concat(e,"_").concat(r,"__")),d.push(l)));return d}(n):void 0}function Jn(n){return a(n)&&a(n.text)&&!1===n.isComment}function Qn(n,t){var e,r,o,s,c=null;if(i(n)||"string"==typeof n)for(c=new Array(n.length),e=0,r=n.length;e<r;e++)c[e]=t(n[e],e);else if("number"==typeof n)for(c=new Array(n),e=0;e<n;e++)c[e]=t(e+1,e);else if(u(n))if(pn&&n[Symbol.iterator]){c=[];for(var l=n[Symbol.iterator](),p=l.next();!p.done;)c.push(t(p.value,c.length)),p=l.next()}else for(o=Object.keys(n),c=new Array(o.length),e=0,r=o.length;e<r;e++)s=o[e],c[e]=t(n[s],s,e);return a(c)||(c=[]),c._isVList=!0,c}function Zn(n,t,e,r){var i,o=this.$scopedSlots[n];o?(e=e||{},r&&(e=N(N({},r),e)),i=o(e)||(l(t)?t():t)):i=this.$slots[n]||(l(t)?t():t);var a=e&&e.slot;return a?this.$createElement("template",{slot:a},i):i}function nt(n){return Ee(this.$options,"filters",n,!0)||I}function tt(n,t){return i(n)?-1===n.indexOf(t):n!==t}function et(n,t,e,r,i){var o=H.keyCodes[t]||e;return i&&r&&!H.keyCodes[t]?tt(i,r):o?tt(o,n):r?O(r)!==t:void 0===n}function rt(n,t,e,r,o){if(e)if(u(e)){i(e)&&(e=T(e));var a=void 0,s=function(i){if("class"===i||"style"===i||_(i))a=n;else{var s=n.attrs&&n.attrs.type;a=r||H.mustUseProp(t,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var c=P(i),l=O(i);c in a||l in a||(a[i]=e[i],o&&((n.on||(n.on={}))["update:".concat(i)]=function(n){e[i]=n}))};for(var c in e)s(c)}else;return n}function it(n,t){var e=this._staticTrees||(this._staticTrees=[]),r=e[n];return r&&!t||at(r=e[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ot(n,t,e){return at(n,"__once__".concat(t).concat(e?"_".concat(e):""),!0),n}function at(n,t,e){if(i(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&st(n[r],"".concat(t,"_").concat(r),e);else st(n,t,e)}function st(n,t,e){n.isStatic=!0,n.key=t,n.isOnce=e}function ct(n,t){if(t)if(d(t)){var e=n.on=n.on?N({},n.on):{};for(var r in t){var i=e[r],o=t[r];e[r]=i?[].concat(i,o):o}}else;return n}function lt(n,t,e,r){t=t||{$stable:!e};for(var o=0;o<n.length;o++){var a=n[o];i(a)?lt(a,t,e):a&&(a.proxy&&(a.fn.proxy=!0),t[a.key]=a.fn)}return r&&(t.$key=r),t}function ut(n,t){for(var e=0;e<t.length;e+=2){var r=t[e];"string"==typeof r&&r&&(n[t[e]]=t[e+1])}return n}function pt(n,t){return"string"==typeof n?t+n:n}function dt(n){n._o=ot,n._n=y,n._s=v,n._l=Qn,n._t=Zn,n._q=R,n._i=M,n._m=it,n._f=nt,n._k=et,n._b=rt,n._v=vn,n._e=mn,n._u=lt,n._g=ct,n._d=ut,n._p=pt}function ft(n,t){if(!n||!n.length)return{};for(var e={},r=0,i=n.length;r<i;r++){var o=n[r],a=o.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,o.context!==t&&o.fnContext!==t||!a||null==a.slot)(e.default||(e.default=[])).push(o);else{var s=a.slot,c=e[s]||(e[s]=[]);"template"===o.tag?c.push.apply(c,o.children||[]):c.push(o)}}for(var l in e)e[l].every(ht)&&delete e[l];return e}function ht(n){return n.isComment&&!n.asyncFactory||" "===n.text}function mt(n){return n.isComment&&n.asyncFactory}function vt(n,t,e,i){var o,a=Object.keys(e).length>0,s=t?!!t.$stable:!a,c=t&&t.$key;if(t){if(t._normalized)return t._normalized;if(s&&i&&i!==r&&c===i.$key&&!a&&!i.$hasNormal)return i;for(var l in o={},t)t[l]&&"$"!==l[0]&&(o[l]=gt(n,e,l,t[l]))}else o={};for(var u in e)u in o||(o[u]=yt(e,u));return t&&Object.isExtensible(t)&&(t._normalized=o),V(o,"$stable",s),V(o,"$key",c),V(o,"$hasNormal",a),o}function gt(n,t,e,r){var o=function(){var t=dn;fn(n);var e=arguments.length?r.apply(null,arguments):r({}),o=(e=e&&"object"==typeof e&&!i(e)?[e]:Yn(e))&&e[0];return fn(t),e&&(!o||1===e.length&&o.isComment&&!mt(o))?void 0:e};return r.proxy&&Object.defineProperty(t,e,{get:o,enumerable:!0,configurable:!0}),o}function yt(n,t){return function(){return n[t]}}function bt(n){return{get attrs(){if(!n._attrsProxy){var t=n._attrsProxy={};V(t,"_v_attr_proxy",!0),_t(t,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||_t(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||wt(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:L(n.$emit,n),expose:function(t){t&&Object.keys(t).forEach((function(e){return zn(n,t,e)}))}}}function _t(n,t,e,r,i){var o=!1;for(var a in t)a in n?t[a]!==e[a]&&(o=!0):(o=!0,xt(n,a,r,i));for(var a in n)a in t||(o=!0,delete n[a]);return o}function xt(n,t,e,r){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){return e[r][t]}})}function wt(n,t){for(var e in t)n[e]=t[e];for(var e in n)e in t||delete n[e]}var Ct=null;function kt(n,t){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?t.extend(n):n}function At(n){if(i(n))for(var t=0;t<n.length;t++){var e=n[t];if(a(e)&&(a(e.componentOptions)||mt(e)))return e}}function Pt(n,t,e,r,p,d){return(i(e)||c(e))&&(p=r,r=e,e=void 0),s(d)&&(p=2),function(n,t,e,r,c){if(a(e)&&a(e.__ob__))return mn();a(e)&&a(e.is)&&(t=e.is);if(!t)return mn();0;i(r)&&l(r[0])&&((e=e||{}).scopedSlots={default:r[0]},r.length=0);2===c?r=Yn(r):1===c&&(r=function(n){for(var t=0;t<n.length;t++)if(i(n[t]))return Array.prototype.concat.apply([],n);return n}(r));var p,d;if("string"==typeof t){var f=void 0;d=n.$vnode&&n.$vnode.ns||H.getTagNamespace(t),p=H.isReservedTag(t)?new hn(H.parsePlatformTagName(t),e,r,void 0,void 0,n):e&&e.pre||!a(f=Ee(n.$options,"components",t))?new hn(t,e,r,void 0,void 0,n):xe(f,e,n,r,t)}else p=xe(t,e,n,r);return i(p)?p:a(p)?(a(d)&&function n(t,e,r){t.ns=e,"foreignObject"===t.tag&&(e=void 0,r=!0);if(a(t.children))for(var i=0,c=t.children.length;i<c;i++){var l=t.children[i];a(l.tag)&&(o(l.ns)||s(r)&&"svg"!==l.tag)&&n(l,e,r)}}(p,d),a(e)&&function(n){u(n.style)&&Ht(n.style);u(n.class)&&Ht(n.class)}(e),p):mn()}(n,t,e,r,p)}function St(n,t,e){wn();try{if(t)for(var r=t;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var o=0;o<i.length;o++)try{if(!1===i[o].call(r,n,t,e))return}catch(n){Ot(n,r,"errorCaptured hook")}}Ot(n,t,e)}finally{Cn()}}function jt(n,t,e,r,i){var o;try{(o=e?n.apply(t,e):n.call(t))&&!o._isVue&&m(o)&&!o._handled&&(o.catch((function(n){return St(n,r,i+" (Promise/async)")})),o._handled=!0)}catch(n){St(n,r,i)}return o}function Ot(n,t,e){if(H.errorHandler)try{return H.errorHandler.call(null,n,t,e)}catch(t){t!==n&&Lt(t,null,"config.errorHandler")}Lt(n,t,e)}function Lt(n,t,e){if(!X||"undefined"==typeof console)throw n;console.error(n)}var Et,Nt=!1,Tt=[],Bt=!1;function $t(){Bt=!1;var n=Tt.slice(0);Tt.length=0;for(var t=0;t<n.length;t++)n[t]()}if("undefined"!=typeof Promise&&ln(Promise)){var It=Promise.resolve();Et=function(){It.then($t),nn&&setTimeout(B)},Nt=!0}else if(J||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Et="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate($t)}:function(){setTimeout($t,0)};else{var Rt=1,Mt=new MutationObserver($t),Dt=document.createTextNode(String(Rt));Mt.observe(Dt,{characterData:!0}),Et=function(){Rt=(Rt+1)%2,Dt.data=String(Rt)},Nt=!0}function Ut(n,t){var e;if(Tt.push((function(){if(n)try{n.call(t)}catch(n){St(n,t,"nextTick")}else e&&e(t)})),Bt||(Bt=!0,Et()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){e=n}))}function zt(n){return function(t,e){if(void 0===e&&(e=dn),e)return function(n,t,e){var r=n.$options;r[t]=Se(r[t],e)}(e,n,t)}}zt("beforeMount"),zt("mounted"),zt("beforeUpdate"),zt("updated"),zt("beforeDestroy"),zt("destroyed"),zt("activated"),zt("deactivated"),zt("serverPrefetch"),zt("renderTracked"),zt("renderTriggered"),zt("errorCaptured");var Ft=new un;function Ht(n){return function n(t,e){var r,o,a=i(t);if(!a&&!u(t)||t.__v_skip||Object.isFrozen(t)||t instanceof hn)return;if(t.__ob__){var s=t.__ob__.dep.id;if(e.has(s))return;e.add(s)}if(a)for(r=t.length;r--;)n(t[r],e);else if(Un(t))n(t.value,e);else for(o=Object.keys(t),r=o.length;r--;)n(t[o[r]],e)}(n,Ft),Ft.clear(),n}var qt,Wt=0,Vt=function(){function n(n,t,e,r,i){var o,a;o=this,void 0===(a=Fn&&!Fn._vm?Fn:n?n._scope:void 0)&&(a=Fn),a&&a.active&&a.effects.push(o),(this.vm=n)&&i&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=e,this.id=++Wt,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new un,this.newDepIds=new un,this.expression="",l(t)?this.getter=t:(this.getter=function(n){if(!G.test(n)){var t=n.split(".");return function(n){for(var e=0;e<t.length;e++){if(!n)return;n=n[t[e]]}return n}}}(t),this.getter||(this.getter=B)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var t=this.vm;try{n=this.getter.call(t,t)}catch(n){if(!this.user)throw n;St(n,t,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ht(n),Cn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var t=n.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(n),this.depIds.has(t)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var t=this.deps[n];this.newDepIds.has(t.id)||t.removeSub(this)}var e=this.depIds;this.depIds=this.newDepIds,this.newDepIds=e,this.newDepIds.clear(),e=this.deps,this.deps=this.newDeps,this.newDeps=e,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():fe(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var t=this.value;if(this.value=n,this.user){var e='callback for watcher "'.concat(this.expression,'"');jt(this.cb,this.vm,[n,t],this.vm,e)}else this.cb.call(this.vm,n,t)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Gt(n,t){qt.$on(n,t)}function Kt(n,t){qt.$off(n,t)}function Xt(n,t){var e=qt;return function r(){var i=t.apply(null,arguments);null!==i&&e.$off(n,r)}}function Yt(n,t,e){qt=n,Gn(t,e||{},Gt,Kt,Xt,n),qt=void 0}var Jt=null;function Qt(n){var t=Jt;return Jt=n,function(){Jt=t}}function Zt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function ne(n,t){if(t){if(n._directInactive=!1,Zt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var e=0;e<n.$children.length;e++)ne(n.$children[e]);te(n,"activated")}}function te(n,t,e,r){void 0===r&&(r=!0),wn();var i=dn,o=Fn;r&&fn(n);var a=n.$options[t],s="".concat(t," hook");if(a)for(var c=0,l=a.length;c<l;c++)jt(a[c],n,e||null,n,s);n._hasHookEvent&&n.$emit("hook:"+t),r&&(fn(i),o&&o.on()),Cn()}var ee=[],re=[],ie={},oe=!1,ae=!1,se=0;var ce=0,le=Date.now;if(X&&!J){var ue=window.performance;ue&&"function"==typeof ue.now&&le()>document.createEvent("Event").timeStamp&&(le=function(){return ue.now()})}var pe=function(n,t){if(n.post){if(!t.post)return 1}else if(t.post)return-1;return n.id-t.id};function de(){var n,t;for(ce=le(),ae=!0,ee.sort(pe),se=0;se<ee.length;se++)(n=ee[se]).before&&n.before(),t=n.id,ie[t]=null,n.run();var e=re.slice(),r=ee.slice();se=ee.length=re.length=0,ie={},oe=ae=!1,function(n){for(var t=0;t<n.length;t++)n[t]._inactive=!0,ne(n[t],!0)}(e),function(n){var t=n.length;for(;t--;){var e=n[t],r=e.vm;r&&r._watcher===e&&r._isMounted&&!r._isDestroyed&&te(r,"updated")}}(r),function(){for(var n=0;n<bn.length;n++){var t=bn[n];t.subs=t.subs.filter((function(n){return n})),t._pending=!1}bn.length=0}(),cn&&H.devtools&&cn.emit("flush")}function fe(n){var t=n.id;if(null==ie[t]&&(n!==_n.target||!n.noRecurse)){if(ie[t]=!0,ae){for(var e=ee.length-1;e>se&&ee[e].id>n.id;)e--;ee.splice(e+1,0,n)}else ee.push(n);oe||(oe=!0,Ut(de))}}function he(n,t){if(n){for(var e=Object.create(null),r=pn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var o=r[i];if("__ob__"!==o){var a=n[o].from;if(a in t._provided)e[o]=t._provided[a];else if("default"in n[o]){var s=n[o].default;e[o]=l(s)?s.call(t):s}else 0}}return e}}function me(n,t,e,o,a){var c,l=this,u=a.options;C(o,"_uid")?(c=Object.create(o))._original=o:(c=o,o=o._original);var p=s(u._compiled),d=!p;this.data=n,this.props=t,this.children=e,this.parent=o,this.listeners=n.on||r,this.injections=he(u.inject,o),this.slots=function(){return l.$slots||vt(o,n.scopedSlots,l.$slots=ft(e,o)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return vt(o,n.scopedSlots,this.slots())}}),p&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=vt(o,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,t,e,r){var a=Pt(c,n,t,e,r,d);return a&&!i(a)&&(a.fnScopeId=u._scopeId,a.fnContext=o),a}:this._c=function(n,t,e,r){return Pt(c,n,t,e,r,d)}}function ve(n,t,e,r,i){var o=gn(n);return o.fnContext=e,o.fnOptions=r,t.slot&&((o.data||(o.data={})).slot=t.slot),o}function ge(n,t){for(var e in t)n[P(e)]=t[e]}function ye(n){return n.name||n.__name||n._componentTag}dt(me.prototype);var be={init:function(n,t){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var e=n;be.prepatch(e,e)}else{(n.componentInstance=function(n,t){var e={_isComponent:!0,_parentVnode:n,parent:t},r=n.data.inlineTemplate;a(r)&&(e.render=r.render,e.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(e)}(n,Jt)).$mount(t?n.elm:void 0,t)}},prepatch:function(n,t){var e=t.componentOptions;!function(n,t,e,i,o){var a=i.data.scopedSlots,s=n.$scopedSlots,c=!!(a&&!a.$stable||s!==r&&!s.$stable||a&&n.$scopedSlots.$key!==a.$key||!a&&n.$scopedSlots.$key),l=!!(o||n.$options._renderChildren||c),u=n.$vnode;n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i),n.$options._renderChildren=o;var p=i.data.attrs||r;n._attrsProxy&&_t(n._attrsProxy,p,u.data&&u.data.attrs||r,n,"$attrs")&&(l=!0),n.$attrs=p,e=e||r;var d=n.$options._parentListeners;if(n._listenersProxy&&_t(n._listenersProxy,e,d||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=e,Yt(n,e,d),t&&n.$options.props){On(!1);for(var f=n._props,h=n.$options._propKeys||[],m=0;m<h.length;m++){var v=h[m],g=n.$options.props;f[v]=Ne(v,g,t,n)}On(!0),n.$options.propsData=t}l&&(n.$slots=ft(o,i.context),n.$forceUpdate())}(t.componentInstance=n.componentInstance,e.propsData,e.listeners,t,e.children)},insert:function(n){var t,e=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,te(r,"mounted")),n.data.keepAlive&&(e._isMounted?((t=r)._inactive=!1,re.push(t)):ne(r,!0))},destroy:function(n){var t=n.componentInstance;t._isDestroyed||(n.data.keepAlive?function n(t,e){if(!(e&&(t._directInactive=!0,Zt(t))||t._inactive)){t._inactive=!0;for(var r=0;r<t.$children.length;r++)n(t.$children[r]);te(t,"deactivated")}}(t,!0):t.$destroy())}},_e=Object.keys(be);function xe(n,t,e,c,l){if(!o(n)){var p=e.$options._base;if(u(n)&&(n=p.extend(n)),"function"==typeof n){var d;if(o(n.cid)&&void 0===(n=function(n,t){if(s(n.error)&&a(n.errorComp))return n.errorComp;if(a(n.resolved))return n.resolved;var e=Ct;if(e&&a(n.owners)&&-1===n.owners.indexOf(e)&&n.owners.push(e),s(n.loading)&&a(n.loadingComp))return n.loadingComp;if(e&&!a(n.owners)){var r=n.owners=[e],i=!0,c=null,l=null;e.$on("hook:destroyed",(function(){return x(r,e)}));var p=function(n){for(var t=0,e=r.length;t<e;t++)r[t].$forceUpdate();n&&(r.length=0,null!==c&&(clearTimeout(c),c=null),null!==l&&(clearTimeout(l),l=null))},d=D((function(e){n.resolved=kt(e,t),i?r.length=0:p(!0)})),f=D((function(t){a(n.errorComp)&&(n.error=!0,p(!0))})),h=n(d,f);return u(h)&&(m(h)?o(n.resolved)&&h.then(d,f):m(h.component)&&(h.component.then(d,f),a(h.error)&&(n.errorComp=kt(h.error,t)),a(h.loading)&&(n.loadingComp=kt(h.loading,t),0===h.delay?n.loading=!0:c=setTimeout((function(){c=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,p(!1))}),h.delay||200)),a(h.timeout)&&(l=setTimeout((function(){l=null,o(n.resolved)&&f(null)}),h.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(d=n,p)))return function(n,t,e,r,i){var o=mn();return o.asyncFactory=n,o.asyncMeta={data:t,context:e,children:r,tag:i},o}(d,t,e,c,l);t=t||{},Ve(n),a(t.model)&&function(n,t){var e=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(t.attrs||(t.attrs={}))[e]=t.model.value;var o=t.on||(t.on={}),s=o[r],c=t.model.callback;a(s)?(i(s)?-1===s.indexOf(c):s!==c)&&(o[r]=[c].concat(s)):o[r]=c}(n.options,t);var f=function(n,t,e){var r=t.options.props;if(!o(r)){var i={},s=n.attrs,c=n.props;if(a(s)||a(c))for(var l in r){var u=O(l);Xn(i,c,l,u,!0)||Xn(i,s,l,u,!1)}return i}}(t,n);if(s(n.options.functional))return function(n,t,e,o,s){var c=n.options,l={},u=c.props;if(a(u))for(var p in u)l[p]=Ne(p,u,t||r);else a(e.attrs)&&ge(l,e.attrs),a(e.props)&&ge(l,e.props);var d=new me(e,l,s,o,n),f=c.render.call(null,d._c,d);if(f instanceof hn)return ve(f,e,d.parent,c,d);if(i(f)){for(var h=Yn(f)||[],m=new Array(h.length),v=0;v<h.length;v++)m[v]=ve(h[v],e,d.parent,c,d);return m}}(n,f,t,e,c);var h=t.on;if(t.on=t.nativeOn,s(n.options.abstract)){var v=t.slot;t={},v&&(t.slot=v)}!function(n){for(var t=n.hook||(n.hook={}),e=0;e<_e.length;e++){var r=_e[e],i=t[r],o=be[r];i===o||i&&i._merged||(t[r]=i?we(o,i):o)}}(t);var g=ye(n.options)||l;return new hn("vue-component-".concat(n.cid).concat(g?"-".concat(g):""),t,void 0,void 0,void 0,e,{Ctor:n,propsData:f,listeners:h,tag:l,children:c},d)}}}function we(n,t){var e=function(e,r){n(e,r),t(e,r)};return e._merged=!0,e}var Ce=B,ke=H.optionMergeStrategies;function Ae(n,t,e){if(void 0===e&&(e=!0),!t)return n;for(var r,i,o,a=pn?Reflect.ownKeys(t):Object.keys(t),s=0;s<a.length;s++)"__ob__"!==(r=a[s])&&(i=n[r],o=t[r],e&&C(n,r)?i!==o&&d(i)&&d(o)&&Ae(i,o):Bn(n,r,o));return n}function Pe(n,t,e){return e?function(){var r=l(t)?t.call(e,e):t,i=l(n)?n.call(e,e):n;return r?Ae(r,i):i}:t?n?function(){return Ae(l(t)?t.call(this,this):t,l(n)?n.call(this,this):n)}:t:n}function Se(n,t){var e=t?n?n.concat(t):i(t)?t:[t]:n;return e?function(n){for(var t=[],e=0;e<n.length;e++)-1===t.indexOf(n[e])&&t.push(n[e]);return t}(e):e}function je(n,t,e,r){var i=Object.create(n||null);return t?N(i,t):i}ke.data=function(n,t,e){return e?Pe(n,t,e):t&&"function"!=typeof t?n:Pe(n,t)},F.forEach((function(n){ke[n]=Se})),z.forEach((function(n){ke[n+"s"]=je})),ke.watch=function(n,t,e,r){if(n===rn&&(n=void 0),t===rn&&(t=void 0),!t)return Object.create(n||null);if(!n)return t;var o={};for(var a in N(o,n),t){var s=o[a],c=t[a];s&&!i(s)&&(s=[s]),o[a]=s?s.concat(c):i(c)?c:[c]}return o},ke.props=ke.methods=ke.inject=ke.computed=function(n,t,e,r){if(!n)return t;var i=Object.create(null);return N(i,n),t&&N(i,t),i},ke.provide=function(n,t){return n?function(){var e=Object.create(null);return Ae(e,l(n)?n.call(this):n),t&&Ae(e,l(t)?t.call(this):t,!1),e}:t};var Oe=function(n,t){return void 0===t?n:t};function Le(n,t,e){if(l(t)&&(t=t.options),function(n,t){var e=n.props;if(e){var r,o,a={};if(i(e))for(r=e.length;r--;)"string"==typeof(o=e[r])&&(a[P(o)]={type:null});else if(d(e))for(var s in e)o=e[s],a[P(s)]=d(o)?o:{type:o};else 0;n.props=a}}(t),function(n,t){var e=n.inject;if(e){var r=n.inject={};if(i(e))for(var o=0;o<e.length;o++)r[e[o]]={from:e[o]};else if(d(e))for(var a in e){var s=e[a];r[a]=d(s)?N({from:a},s):{from:s}}else 0}}(t),function(n){var t=n.directives;if(t)for(var e in t){var r=t[e];l(r)&&(t[e]={bind:r,update:r})}}(t),!t._base&&(t.extends&&(n=Le(n,t.extends,e)),t.mixins))for(var r=0,o=t.mixins.length;r<o;r++)n=Le(n,t.mixins[r],e);var a,s={};for(a in n)c(a);for(a in t)C(n,a)||c(a);function c(r){var i=ke[r]||Oe;s[r]=i(n[r],t[r],e,r)}return s}function Ee(n,t,e,r){if("string"==typeof e){var i=n[t];if(C(i,e))return i[e];var o=P(e);if(C(i,o))return i[o];var a=S(o);return C(i,a)?i[a]:i[e]||i[o]||i[a]}}function Ne(n,t,e,r){var i=t[n],o=!C(e,n),a=e[n],s=Ie(Boolean,i.type);if(s>-1)if(o&&!C(i,"default"))a=!1;else if(""===a||a===O(n)){var c=Ie(String,i.type);(c<0||s<c)&&(a=!0)}if(void 0===a){a=function(n,t,e){if(!C(t,"default"))return;var r=t.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[e]&&void 0!==n._props[e])return n._props[e];return l(r)&&"Function"!==Be(t.type)?r.call(n):r}(r,i,n);var u=jn;On(!0),Nn(a),On(u)}return a}var Te=/^\s*function (\w+)/;function Be(n){var t=n&&n.toString().match(Te);return t?t[1]:""}function $e(n,t){return Be(n)===Be(t)}function Ie(n,t){if(!i(t))return $e(t,n)?0:-1;for(var e=0,r=t.length;e<r;e++)if($e(t[e],n))return e;return-1}var Re={enumerable:!0,configurable:!0,get:B,set:B};function Me(n,t,e){Re.get=function(){return this[t][e]},Re.set=function(n){this[t][e]=n},Object.defineProperty(n,e,Re)}function De(n){var t=n.$options;if(t.props&&function(n,t){var e=n.$options.propsData||{},r=n._props=Rn({}),i=n.$options._propKeys=[];n.$parent&&On(!1);var o=function(o){i.push(o);var a=Ne(o,t,e,n);Tn(r,o,a,void 0,!0),o in n||Me(n,"_props",o)};for(var a in t)o(a);On(!0)}(n,t.props),function(n){var t=n.$options,e=t.setup;if(e){var r=n._setupContext=bt(n);fn(n),wn();var i=jt(e,null,[n._props||Rn({}),r],n,"setup");if(Cn(),fn(),l(i))t.render=i;else if(u(i))if(n._setupState=i,i.__sfc){var o=n._setupProxy={};for(var a in i)"__sfc"!==a&&zn(o,i,a)}else for(var a in i)W(a)||zn(n,i,a);else 0}}(n),t.methods&&function(n,t){n.$options.props;for(var e in t)n[e]="function"!=typeof t[e]?B:L(t[e],n)}(n,t.methods),t.data)!function(n){var t=n.$options.data;d(t=n._data=l(t)?function(n,t){wn();try{return n.call(t,t)}catch(n){return St(n,t,"data()"),{}}finally{Cn()}}(t,n):t||{})||(t={});var e=Object.keys(t),r=n.$options.props,i=(n.$options.methods,e.length);for(;i--;){var o=e[i];0,r&&C(r,o)||W(o)||Me(n,"_data",o)}var a=Nn(t);a&&a.vmCount++}(n);else{var e=Nn(n._data={});e&&e.vmCount++}t.computed&&function(n,t){var e=n._computedWatchers=Object.create(null),r=sn();for(var i in t){var o=t[i],a=l(o)?o:o.get;0,r||(e[i]=new Vt(n,a||B,B,Ue)),i in n||ze(n,i,o)}}(n,t.computed),t.watch&&t.watch!==rn&&function(n,t){for(var e in t){var r=t[e];if(i(r))for(var o=0;o<r.length;o++)qe(n,e,r[o]);else qe(n,e,r)}}(n,t.watch)}var Ue={lazy:!0};function ze(n,t,e){var r=!sn();l(e)?(Re.get=r?Fe(t):He(e),Re.set=B):(Re.get=e.get?r&&!1!==e.cache?Fe(t):He(e.get):B,Re.set=e.set||B),Object.defineProperty(n,t,Re)}function Fe(n){return function(){var t=this._computedWatchers&&this._computedWatchers[n];if(t)return t.dirty&&t.evaluate(),_n.target&&t.depend(),t.value}}function He(n){return function(){return n.call(this,this)}}function qe(n,t,e,r){return d(e)&&(r=e,e=e.handler),"string"==typeof e&&(e=n[e]),n.$watch(t,e,r)}var We=0;function Ve(n){var t=n.options;if(n.super){var e=Ve(n.super);if(e!==n.superOptions){n.superOptions=e;var r=function(n){var t,e=n.options,r=n.sealedOptions;for(var i in e)e[i]!==r[i]&&(t||(t={}),t[i]=e[i]);return t}(n);r&&N(n.extendOptions,r),(t=n.options=Le(e,n.extendOptions)).name&&(t.components[t.name]=n)}}return t}function Ge(n){this._init(n)}function Ke(n){n.cid=0;var t=1;n.extend=function(n){n=n||{};var e=this,r=e.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var o=ye(n)||ye(e.options);var a=function(n){this._init(n)};return(a.prototype=Object.create(e.prototype)).constructor=a,a.cid=t++,a.options=Le(e.options,n),a.super=e,a.options.props&&function(n){var t=n.options.props;for(var e in t)Me(n.prototype,"_props",e)}(a),a.options.computed&&function(n){var t=n.options.computed;for(var e in t)ze(n.prototype,e,t[e])}(a),a.extend=e.extend,a.mixin=e.mixin,a.use=e.use,z.forEach((function(n){a[n]=e[n]})),o&&(a.options.components[o]=a),a.superOptions=e.options,a.extendOptions=n,a.sealedOptions=N({},a.options),i[r]=a,a}}function Xe(n){return n&&(ye(n.Ctor.options)||n.tag)}function Ye(n,t){return i(n)?n.indexOf(t)>-1:"string"==typeof n?n.split(",").indexOf(t)>-1:!!f(n)&&n.test(t)}function Je(n,t){var e=n.cache,r=n.keys,i=n._vnode,o=n.$vnode;for(var a in e){var s=e[a];if(s){var c=s.name;c&&!t(c)&&Qe(e,a,r,i)}}o.componentOptions.children=void 0}function Qe(n,t,e,r){var i=n[t];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[t]=null,x(e,t)}Ge.prototype._init=function(n){var t=this;t._uid=We++,t._isVue=!0,t.__v_skip=!0,t._scope=new Hn(!0),t._scope.parent=void 0,t._scope._vm=!0,n&&n._isComponent?function(n,t){var e=n.$options=Object.create(n.constructor.options),r=t._parentVnode;e.parent=t.parent,e._parentVnode=r;var i=r.componentOptions;e.propsData=i.propsData,e._parentListeners=i.listeners,e._renderChildren=i.children,e._componentTag=i.tag,t.render&&(e.render=t.render,e.staticRenderFns=t.staticRenderFns)}(t,n):t.$options=Le(Ve(t.constructor),n||{},t),t._renderProxy=t,t._self=t,function(n){var t=n.$options,e=t.parent;if(e&&!t.abstract){for(;e.$options.abstract&&e.$parent;)e=e.$parent;e.$children.push(n)}n.$parent=e,n.$root=e?e.$root:n,n.$children=[],n.$refs={},n._provided=e?e._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(t),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var t=n.$options._parentListeners;t&&Yt(n,t)}(t),function(n){n._vnode=null,n._staticTrees=null;var t=n.$options,e=n.$vnode=t._parentVnode,i=e&&e.context;n.$slots=ft(t._renderChildren,i),n.$scopedSlots=e?vt(n.$parent,e.data.scopedSlots,n.$slots):r,n._c=function(t,e,r,i){return Pt(n,t,e,r,i,!1)},n.$createElement=function(t,e,r,i){return Pt(n,t,e,r,i,!0)};var o=e&&e.data;Tn(n,"$attrs",o&&o.attrs||r,null,!0),Tn(n,"$listeners",t._parentListeners||r,null,!0)}(t),te(t,"beforeCreate",void 0,!1),function(n){var t=he(n.$options.inject,n);t&&(On(!1),Object.keys(t).forEach((function(e){Tn(n,e,t[e])})),On(!0))}(t),De(t),function(n){var t=n.$options.provide;if(t){var e=l(t)?t.call(n):t;if(!u(e))return;for(var r=qn(n),i=pn?Reflect.ownKeys(e):Object.keys(e),o=0;o<i.length;o++){var a=i[o];Object.defineProperty(r,a,Object.getOwnPropertyDescriptor(e,a))}}}(t),te(t,"created"),t.$options.el&&t.$mount(t.$options.el)},function(n){var t={get:function(){return this._data}},e={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",t),Object.defineProperty(n.prototype,"$props",e),n.prototype.$set=Bn,n.prototype.$delete=$n,n.prototype.$watch=function(n,t,e){if(d(t))return qe(this,n,t,e);(e=e||{}).user=!0;var r=new Vt(this,n,t,e);if(e.immediate){var i='callback for immediate watcher "'.concat(r.expression,'"');wn(),jt(t,this,[r.value],this,i),Cn()}return function(){r.teardown()}}}(Ge),function(n){var t=/^hook:/;n.prototype.$on=function(n,e){var r=this;if(i(n))for(var o=0,a=n.length;o<a;o++)r.$on(n[o],e);else(r._events[n]||(r._events[n]=[])).push(e),t.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,t){var e=this;function r(){e.$off(n,r),t.apply(e,arguments)}return r.fn=t,e.$on(n,r),e},n.prototype.$off=function(n,t){var e=this;if(!arguments.length)return e._events=Object.create(null),e;if(i(n)){for(var r=0,o=n.length;r<o;r++)e.$off(n[r],t);return e}var a,s=e._events[n];if(!s)return e;if(!t)return e._events[n]=null,e;for(var c=s.length;c--;)if((a=s[c])===t||a.fn===t){s.splice(c,1);break}return e},n.prototype.$emit=function(n){var t=this,e=t._events[n];if(e){e=e.length>1?E(e):e;for(var r=E(arguments,1),i='event handler for "'.concat(n,'"'),o=0,a=e.length;o<a;o++)jt(e[o],t,r,t,i)}return t}}(Ge),function(n){n.prototype._update=function(n,t){var e=this,r=e.$el,i=e._vnode,o=Qt(e);e._vnode=n,e.$el=i?e.__patch__(i,n):e.__patch__(e.$el,n,t,!1),o(),r&&(r.__vue__=null),e.$el&&(e.$el.__vue__=e);for(var a=e;a&&a.$vnode&&a.$parent&&a.$vnode===a.$parent._vnode;)a.$parent.$el=a.$el,a=a.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){te(n,"beforeDestroy"),n._isBeingDestroyed=!0;var t=n.$parent;!t||t._isBeingDestroyed||n.$options.abstract||x(t.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),te(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Ge),function(n){dt(n.prototype),n.prototype.$nextTick=function(n){return Ut(n,this)},n.prototype._render=function(){var n=this,t=n.$options,e=t.render,r=t._parentVnode;r&&n._isMounted&&(n.$scopedSlots=vt(n.$parent,r.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&wt(n._slotsProxy,n.$scopedSlots)),n.$vnode=r;var o,a=dn,s=Ct;try{fn(n),Ct=n,o=e.call(n._renderProxy,n.$createElement)}catch(t){St(t,n,"render"),o=n._vnode}finally{Ct=s,fn(a)}return i(o)&&1===o.length&&(o=o[0]),o instanceof hn||(o=mn()),o.parent=r,o}}(Ge);var Ze=[String,RegExp,Array],nr={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Ze,exclude:Ze,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,t=this.keys,e=this.vnodeToCache,r=this.keyToCache;if(e){var i=e.tag,o=e.componentInstance,a=e.componentOptions;n[r]={name:Xe(a),tag:i,componentInstance:o},t.push(r),this.max&&t.length>parseInt(this.max)&&Qe(n,t[0],t,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Qe(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(t){Je(n,(function(n){return Ye(t,n)}))})),this.$watch("exclude",(function(t){Je(n,(function(n){return!Ye(t,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,t=At(n),e=t&&t.componentOptions;if(e){var r=Xe(e),i=this.include,o=this.exclude;if(i&&(!r||!Ye(i,r))||o&&r&&Ye(o,r))return t;var a=this.cache,s=this.keys,c=null==t.key?e.Ctor.cid+(e.tag?"::".concat(e.tag):""):t.key;a[c]?(t.componentInstance=a[c].componentInstance,x(s,c),s.push(c)):(this.vnodeToCache=t,this.keyToCache=c),t.data.keepAlive=!0}return t||n&&n[0]}}};!function(n){var t={get:function(){return H}};Object.defineProperty(n,"config",t),n.util={warn:Ce,extend:N,mergeOptions:Le,defineReactive:Tn},n.set=Bn,n.delete=$n,n.nextTick=Ut,n.observable=function(n){return Nn(n),n},n.options=Object.create(null),z.forEach((function(t){n.options[t+"s"]=Object.create(null)})),n.options._base=n,N(n.options.components,nr),function(n){n.use=function(n){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(n)>-1)return this;var e=E(arguments,1);return e.unshift(this),l(n.install)?n.install.apply(n,e):l(n)&&n.apply(null,e),t.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Le(this.options,n),this}}(n),Ke(n),function(n){z.forEach((function(t){n[t]=function(n,e){return e?("component"===t&&d(e)&&(e.name=e.name||n,e=this.options._base.extend(e)),"directive"===t&&l(e)&&(e={bind:e,update:e}),this.options[t+"s"][n]=e,e):this.options[t+"s"][n]}}))}(n)}(Ge),Object.defineProperty(Ge.prototype,"$isServer",{get:sn}),Object.defineProperty(Ge.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Ge,"FunctionalRenderContext",{value:me}),Ge.version="2.7.16";var tr=b("style,class"),er=b("input,textarea,option,select,progress"),rr=b("contenteditable,draggable,spellcheck"),ir=b("events,caret,typing,plaintext-only"),or=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ar="http://www.w3.org/1999/xlink",sr=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},cr=function(n){return sr(n)?n.slice(6,n.length):""},lr=function(n){return null==n||!1===n};function ur(n){for(var t=n.data,e=n,r=n;a(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(t=pr(r.data,t));for(;a(e=e.parent);)e&&e.data&&(t=pr(t,e.data));return function(n,t){if(a(n)||a(t))return dr(n,fr(t));return""}(t.staticClass,t.class)}function pr(n,t){return{staticClass:dr(n.staticClass,t.staticClass),class:a(n.class)?[n.class,t.class]:t.class}}function dr(n,t){return n?t?n+" "+t:n:t||""}function fr(n){return Array.isArray(n)?function(n){for(var t,e="",r=0,i=n.length;r<i;r++)a(t=fr(n[r]))&&""!==t&&(e&&(e+=" "),e+=t);return e}(n):u(n)?function(n){var t="";for(var e in n)n[e]&&(t&&(t+=" "),t+=e);return t}(n):"string"==typeof n?n:""}var hr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},mr=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),vr=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),gr=function(n){return mr(n)||vr(n)};var yr=Object.create(null);var br=b("text,number,password,search,email,tel,url");var _r=Object.freeze({__proto__:null,createElement:function(n,t){var e=document.createElement(n);return"select"!==n||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&e.setAttribute("multiple","multiple"),e},createElementNS:function(n,t){return document.createElementNS(hr[n],t)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,t,e){n.insertBefore(t,e)},removeChild:function(n,t){n.removeChild(t)},appendChild:function(n,t){n.appendChild(t)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,t){n.textContent=t},setStyleScope:function(n,t){n.setAttribute(t,"")}}),xr={create:function(n,t){wr(t)},update:function(n,t){n.data.ref!==t.data.ref&&(wr(n,!0),wr(t))},destroy:function(n){wr(n,!0)}};function wr(n,t){var e=n.data.ref;if(a(e)){var r=n.context,o=n.componentInstance||n.elm,s=t?null:o,c=t?void 0:o;if(l(e))jt(e,r,[s],r,"template ref function");else{var u=n.data.refInFor,p="string"==typeof e||"number"==typeof e,d=Un(e),f=r.$refs;if(p||d)if(u){var h=p?f[e]:e.value;t?i(h)&&x(h,o):i(h)?h.includes(o)||h.push(o):p?(f[e]=[o],Cr(r,e,f[e])):e.value=[o]}else if(p){if(t&&f[e]!==o)return;f[e]=c,Cr(r,e,s)}else if(d){if(t&&e.value!==o)return;e.value=s}else 0}}}function Cr(n,t,e){var r=n._setupState;r&&C(r,t)&&(Un(r[t])?r[t].value=e:r[t]=e)}var kr=new hn("",{},[]),Ar=["create","activate","update","remove","destroy"];function Pr(n,t){return n.key===t.key&&n.asyncFactory===t.asyncFactory&&(n.tag===t.tag&&n.isComment===t.isComment&&a(n.data)===a(t.data)&&function(n,t){if("input"!==n.tag)return!0;var e,r=a(e=n.data)&&a(e=e.attrs)&&e.type,i=a(e=t.data)&&a(e=e.attrs)&&e.type;return r===i||br(r)&&br(i)}(n,t)||s(n.isAsyncPlaceholder)&&o(t.asyncFactory.error))}function Sr(n,t,e){var r,i,o={};for(r=t;r<=e;++r)a(i=n[r].key)&&(o[i]=r);return o}var jr={create:Or,update:Or,destroy:function(n){Or(n,kr)}};function Or(n,t){(n.data.directives||t.data.directives)&&function(n,t){var e,r,i,o=n===kr,a=t===kr,s=Er(n.data.directives,n.context),c=Er(t.data.directives,t.context),l=[],u=[];for(e in c)r=s[e],i=c[e],r?(i.oldValue=r.value,i.oldArg=r.arg,Tr(i,"update",t,n),i.def&&i.def.componentUpdated&&u.push(i)):(Tr(i,"bind",t,n),i.def&&i.def.inserted&&l.push(i));if(l.length){var p=function(){for(var e=0;e<l.length;e++)Tr(l[e],"inserted",t,n)};o?Kn(t,"insert",p):p()}u.length&&Kn(t,"postpatch",(function(){for(var e=0;e<u.length;e++)Tr(u[e],"componentUpdated",t,n)}));if(!o)for(e in s)c[e]||Tr(s[e],"unbind",n,n,a)}(n,t)}var Lr=Object.create(null);function Er(n,t){var e,r,i=Object.create(null);if(!n)return i;for(e=0;e<n.length;e++){if((r=n[e]).modifiers||(r.modifiers=Lr),i[Nr(r)]=r,t._setupState&&t._setupState.__sfc){var o=r.def||Ee(t,"_setupState","v-"+r.name);r.def="function"==typeof o?{bind:o,update:o}:o}r.def=r.def||Ee(t.$options,"directives",r.name)}return i}function Nr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Tr(n,t,e,r,i){var o=n.def&&n.def[t];if(o)try{o(e.elm,n,e,r,i)}catch(r){St(r,e.context,"directive ".concat(n.name," ").concat(t," hook"))}}var Br=[xr,jr];function $r(n,t){var e=t.componentOptions;if(!(a(e)&&!1===e.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(t.data.attrs))){var r,i,c=t.elm,l=n.data.attrs||{},u=t.data.attrs||{};for(r in(a(u.__ob__)||s(u._v_attr_proxy))&&(u=t.data.attrs=N({},u)),u)i=u[r],l[r]!==i&&Ir(c,r,i,t.data.pre);for(r in(J||Z)&&u.value!==l.value&&Ir(c,"value",u.value),l)o(u[r])&&(sr(r)?c.removeAttributeNS(ar,cr(r)):rr(r)||c.removeAttribute(r))}}function Ir(n,t,e,r){r||n.tagName.indexOf("-")>-1?Rr(n,t,e):or(t)?lr(e)?n.removeAttribute(t):(e="allowfullscreen"===t&&"EMBED"===n.tagName?"true":t,n.setAttribute(t,e)):rr(t)?n.setAttribute(t,function(n,t){return lr(t)||"false"===t?"false":"contenteditable"===n&&ir(t)?t:"true"}(t,e)):sr(t)?lr(e)?n.removeAttributeNS(ar,cr(t)):n.setAttributeNS(ar,t,e):Rr(n,t,e)}function Rr(n,t,e){if(lr(e))n.removeAttribute(t);else{if(J&&!Q&&"TEXTAREA"===n.tagName&&"placeholder"===t&&""!==e&&!n.__ieph){var r=function(t){t.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(t,e)}}var Mr={create:$r,update:$r};function Dr(n,t){var e=t.elm,r=t.data,i=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(i)||o(i.staticClass)&&o(i.class)))){var s=ur(t),c=e._transitionClasses;a(c)&&(s=dr(s,fr(c))),s!==e._prevClass&&(e.setAttribute("class",s),e._prevClass=s)}}var Ur,zr={create:Dr,update:Dr};function Fr(n,t,e){var r=Ur;return function i(){var o=t.apply(null,arguments);null!==o&&Wr(n,i,e,r)}}var Hr=Nt&&!(en&&Number(en[1])<=53);function qr(n,t,e,r){if(Hr){var i=ce,o=t;t=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}Ur.addEventListener(n,t,on?{capture:e,passive:r}:e)}function Wr(n,t,e,r){(r||Ur).removeEventListener(n,t._wrapper||t,e)}function Vr(n,t){if(!o(n.data.on)||!o(t.data.on)){var e=t.data.on||{},r=n.data.on||{};Ur=t.elm||n.elm,function(n){if(a(n.__r)){var t=J?"change":"input";n[t]=[].concat(n.__r,n[t]||[]),delete n.__r}a(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(e),Gn(e,r,qr,Wr,Fr,t.context),Ur=void 0}}var Gr,Kr={create:Vr,update:Vr,destroy:function(n){return Vr(n,kr)}};function Xr(n,t){if(!o(n.data.domProps)||!o(t.data.domProps)){var e,r,i=t.elm,c=n.data.domProps||{},l=t.data.domProps||{};for(e in(a(l.__ob__)||s(l._v_attr_proxy))&&(l=t.data.domProps=N({},l)),c)e in l||(i[e]="");for(e in l){if(r=l[e],"textContent"===e||"innerHTML"===e){if(t.children&&(t.children.length=0),r===c[e])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===e&&"PROGRESS"!==i.tagName){i._value=r;var u=o(r)?"":String(r);Yr(i,u)&&(i.value=u)}else if("innerHTML"===e&&vr(i.tagName)&&o(i.innerHTML)){(Gr=Gr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var p=Gr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;p.firstChild;)i.appendChild(p.firstChild)}else if(r!==c[e])try{i[e]=r}catch(n){}}}}function Yr(n,t){return!n.composing&&("OPTION"===n.tagName||function(n,t){var e=!0;try{e=document.activeElement!==n}catch(n){}return e&&n.value!==t}(n,t)||function(n,t){var e=n.value,r=n._vModifiers;if(a(r)){if(r.number)return y(e)!==y(t);if(r.trim)return e.trim()!==t.trim()}return e!==t}(n,t))}var Jr={create:Xr,update:Xr},Qr=k((function(n){var t={},e=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(e);r.length>1&&(t[r[0].trim()]=r[1].trim())}})),t}));function Zr(n){var t=ni(n.style);return n.staticStyle?N(n.staticStyle,t):t}function ni(n){return Array.isArray(n)?T(n):"string"==typeof n?Qr(n):n}var ti,ei=/^--/,ri=/\s*!important$/,ii=function(n,t,e){if(ei.test(t))n.style.setProperty(t,e);else if(ri.test(e))n.style.setProperty(O(t),e.replace(ri,""),"important");else{var r=ai(t);if(Array.isArray(e))for(var i=0,o=e.length;i<o;i++)n.style[r]=e[i];else n.style[r]=e}},oi=["Webkit","Moz","ms"],ai=k((function(n){if(ti=ti||document.createElement("div").style,"filter"!==(n=P(n))&&n in ti)return n;for(var t=n.charAt(0).toUpperCase()+n.slice(1),e=0;e<oi.length;e++){var r=oi[e]+t;if(r in ti)return r}}));function si(n,t){var e=t.data,r=n.data;if(!(o(e.staticStyle)&&o(e.style)&&o(r.staticStyle)&&o(r.style))){var i,s,c=t.elm,l=r.staticStyle,u=r.normalizedStyle||r.style||{},p=l||u,d=ni(t.data.style)||{};t.data.normalizedStyle=a(d.__ob__)?N({},d):d;var f=function(n,t){var e,r={};if(t)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(e=Zr(i.data))&&N(r,e);(e=Zr(n.data))&&N(r,e);for(var o=n;o=o.parent;)o.data&&(e=Zr(o.data))&&N(r,e);return r}(t,!0);for(s in p)o(f[s])&&ii(c,s,"");for(s in f)i=f[s],ii(c,s,null==i?"":i)}}var ci={create:si,update:si},li=/\s+/;function ui(n,t){if(t&&(t=t.trim()))if(n.classList)t.indexOf(" ")>-1?t.split(li).forEach((function(t){return n.classList.add(t)})):n.classList.add(t);else{var e=" ".concat(n.getAttribute("class")||""," ");e.indexOf(" "+t+" ")<0&&n.setAttribute("class",(e+t).trim())}}function pi(n,t){if(t&&(t=t.trim()))if(n.classList)t.indexOf(" ")>-1?t.split(li).forEach((function(t){return n.classList.remove(t)})):n.classList.remove(t),n.classList.length||n.removeAttribute("class");else{for(var e=" ".concat(n.getAttribute("class")||""," "),r=" "+t+" ";e.indexOf(r)>=0;)e=e.replace(r," ");(e=e.trim())?n.setAttribute("class",e):n.removeAttribute("class")}}function di(n){if(n){if("object"==typeof n){var t={};return!1!==n.css&&N(t,fi(n.name||"v")),N(t,n),t}return"string"==typeof n?fi(n):void 0}}var fi=k((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),hi=X&&!Q,mi="transition",vi="transitionend",gi="animation",yi="animationend";hi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(mi="WebkitTransition",vi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(gi="WebkitAnimation",yi="webkitAnimationEnd"));var bi=X?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function _i(n){bi((function(){bi(n)}))}function xi(n,t){var e=n._transitionClasses||(n._transitionClasses=[]);e.indexOf(t)<0&&(e.push(t),ui(n,t))}function wi(n,t){n._transitionClasses&&x(n._transitionClasses,t),pi(n,t)}function Ci(n,t,e){var r=Ai(n,t),i=r.type,o=r.timeout,a=r.propCount;if(!i)return e();var s="transition"===i?vi:yi,c=0,l=function(){n.removeEventListener(s,u),e()},u=function(t){t.target===n&&++c>=a&&l()};setTimeout((function(){c<a&&l()}),o+1),n.addEventListener(s,u)}var ki=/\b(transform|all)(,|$)/;function Ai(n,t){var e,r=window.getComputedStyle(n),i=(r[mi+"Delay"]||"").split(", "),o=(r[mi+"Duration"]||"").split(", "),a=Pi(i,o),s=(r[gi+"Delay"]||"").split(", "),c=(r[gi+"Duration"]||"").split(", "),l=Pi(s,c),u=0,p=0;return"transition"===t?a>0&&(e="transition",u=a,p=o.length):"animation"===t?l>0&&(e="animation",u=l,p=c.length):p=(e=(u=Math.max(a,l))>0?a>l?"transition":"animation":null)?"transition"===e?o.length:c.length:0,{type:e,timeout:u,propCount:p,hasTransform:"transition"===e&&ki.test(r[mi+"Property"])}}function Pi(n,t){for(;n.length<t.length;)n=n.concat(n);return Math.max.apply(null,t.map((function(t,e){return Si(t)+Si(n[e])})))}function Si(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ji(n,t){var e=n.elm;a(e._leaveCb)&&(e._leaveCb.cancelled=!0,e._leaveCb());var r=di(n.data.transition);if(!o(r)&&!a(e._enterCb)&&1===e.nodeType){for(var i=r.css,s=r.type,c=r.enterClass,p=r.enterToClass,d=r.enterActiveClass,f=r.appearClass,h=r.appearToClass,m=r.appearActiveClass,v=r.beforeEnter,g=r.enter,b=r.afterEnter,_=r.enterCancelled,x=r.beforeAppear,w=r.appear,C=r.afterAppear,k=r.appearCancelled,A=r.duration,P=Jt,S=Jt.$vnode;S&&S.parent;)P=S.context,S=S.parent;var j=!P._isMounted||!n.isRootInsert;if(!j||w||""===w){var O=j&&f?f:c,L=j&&m?m:d,E=j&&h?h:p,N=j&&x||v,T=j&&l(w)?w:g,B=j&&C||b,$=j&&k||_,I=y(u(A)?A.enter:A);0;var R=!1!==i&&!Q,M=Ei(T),U=e._enterCb=D((function(){R&&(wi(e,E),wi(e,L)),U.cancelled?(R&&wi(e,O),$&&$(e)):B&&B(e),e._enterCb=null}));n.data.show||Kn(n,"insert",(function(){var t=e.parentNode,r=t&&t._pending&&t._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),T&&T(e,U)})),N&&N(e),R&&(xi(e,O),xi(e,L),_i((function(){wi(e,O),U.cancelled||(xi(e,E),M||(Li(I)?setTimeout(U,I):Ci(e,s,U)))}))),n.data.show&&(t&&t(),T&&T(e,U)),R||M||U()}}}function Oi(n,t){var e=n.elm;a(e._enterCb)&&(e._enterCb.cancelled=!0,e._enterCb());var r=di(n.data.transition);if(o(r)||1!==e.nodeType)return t();if(!a(e._leaveCb)){var i=r.css,s=r.type,c=r.leaveClass,l=r.leaveToClass,p=r.leaveActiveClass,d=r.beforeLeave,f=r.leave,h=r.afterLeave,m=r.leaveCancelled,v=r.delayLeave,g=r.duration,b=!1!==i&&!Q,_=Ei(f),x=y(u(g)?g.leave:g);0;var w=e._leaveCb=D((function(){e.parentNode&&e.parentNode._pending&&(e.parentNode._pending[n.key]=null),b&&(wi(e,l),wi(e,p)),w.cancelled?(b&&wi(e,c),m&&m(e)):(t(),h&&h(e)),e._leaveCb=null}));v?v(C):C()}function C(){w.cancelled||(!n.data.show&&e.parentNode&&((e.parentNode._pending||(e.parentNode._pending={}))[n.key]=n),d&&d(e),b&&(xi(e,c),xi(e,p),_i((function(){wi(e,c),w.cancelled||(xi(e,l),_||(Li(x)?setTimeout(w,x):Ci(e,s,w)))}))),f&&f(e,w),b||_||w())}}function Li(n){return"number"==typeof n&&!isNaN(n)}function Ei(n){if(o(n))return!1;var t=n.fns;return a(t)?Ei(Array.isArray(t)?t[0]:t):(n._length||n.length)>1}function Ni(n,t){!0!==t.data.show&&ji(t)}var Ti=function(n){var t,e,r={},l=n.modules,u=n.nodeOps;for(t=0;t<Ar.length;++t)for(r[Ar[t]]=[],e=0;e<l.length;++e)a(l[e][Ar[t]])&&r[Ar[t]].push(l[e][Ar[t]]);function p(n){var t=u.parentNode(n);a(t)&&u.removeChild(t,n)}function d(n,t,e,i,o,c,l){if(a(n.elm)&&a(c)&&(n=c[l]=gn(n)),n.isRootInsert=!o,!function(n,t,e,i){var o=n.data;if(a(o)){var c=a(n.componentInstance)&&o.keepAlive;if(a(o=o.hook)&&a(o=o.init)&&o(n,!1),a(n.componentInstance))return f(n,t),h(e,n.elm,i),s(c)&&function(n,t,e,i){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,a(o=s.data)&&a(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](kr,s);t.push(s);break}h(e,n.elm,i)}(n,t,e,i),!0}}(n,t,e,i)){var p=n.data,d=n.children,v=n.tag;a(v)?(n.elm=n.ns?u.createElementNS(n.ns,v):u.createElement(v,n),y(n),m(n,d,t),a(p)&&g(n,t),h(e,n.elm,i)):s(n.isComment)?(n.elm=u.createComment(n.text),h(e,n.elm,i)):(n.elm=u.createTextNode(n.text),h(e,n.elm,i))}}function f(n,t){a(n.data.pendingInsert)&&(t.push.apply(t,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,v(n)?(g(n,t),y(n)):(wr(n),t.push(n))}function h(n,t,e){a(n)&&(a(e)?u.parentNode(e)===n&&u.insertBefore(n,t,e):u.appendChild(n,t))}function m(n,t,e){if(i(t)){0;for(var r=0;r<t.length;++r)d(t[r],e,n.elm,null,!0,t,r)}else c(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function v(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return a(n.tag)}function g(n,e){for(var i=0;i<r.create.length;++i)r.create[i](kr,n);a(t=n.data.hook)&&(a(t.create)&&t.create(kr,n),a(t.insert)&&e.push(n))}function y(n){var t;if(a(t=n.fnScopeId))u.setStyleScope(n.elm,t);else for(var e=n;e;)a(t=e.context)&&a(t=t.$options._scopeId)&&u.setStyleScope(n.elm,t),e=e.parent;a(t=Jt)&&t!==n.context&&t!==n.fnContext&&a(t=t.$options._scopeId)&&u.setStyleScope(n.elm,t)}function _(n,t,e,r,i,o){for(;r<=i;++r)d(e[r],o,n,t,!1,e,r)}function x(n){var t,e,i=n.data;if(a(i))for(a(t=i.hook)&&a(t=t.destroy)&&t(n),t=0;t<r.destroy.length;++t)r.destroy[t](n);if(a(t=n.children))for(e=0;e<n.children.length;++e)x(n.children[e])}function w(n,t,e){for(;t<=e;++t){var r=n[t];a(r)&&(a(r.tag)?(C(r),x(r)):p(r.elm))}}function C(n,t){if(a(t)||a(n.data)){var e,i=r.remove.length+1;for(a(t)?t.listeners+=i:t=function(n,t){function e(){0==--e.listeners&&p(n)}return e.listeners=t,e}(n.elm,i),a(e=n.componentInstance)&&a(e=e._vnode)&&a(e.data)&&C(e,t),e=0;e<r.remove.length;++e)r.remove[e](n,t);a(e=n.data.hook)&&a(e=e.remove)?e(n,t):t()}else p(n.elm)}function k(n,t,e,r){for(var i=e;i<r;i++){var o=t[i];if(a(o)&&Pr(n,o))return i}}function A(n,t,e,i,c,l){if(n!==t){a(t.elm)&&a(i)&&(t=i[c]=gn(t));var p=t.elm=n.elm;if(s(n.isAsyncPlaceholder))a(t.asyncFactory.resolved)?j(n.elm,t,e):t.isAsyncPlaceholder=!0;else if(s(t.isStatic)&&s(n.isStatic)&&t.key===n.key&&(s(t.isCloned)||s(t.isOnce)))t.componentInstance=n.componentInstance;else{var f,h=t.data;a(h)&&a(f=h.hook)&&a(f=f.prepatch)&&f(n,t);var m=n.children,g=t.children;if(a(h)&&v(t)){for(f=0;f<r.update.length;++f)r.update[f](n,t);a(f=h.hook)&&a(f=f.update)&&f(n,t)}o(t.text)?a(m)&&a(g)?m!==g&&function(n,t,e,r,i){var s,c,l,p=0,f=0,h=t.length-1,m=t[0],v=t[h],g=e.length-1,y=e[0],b=e[g],x=!i;for(0;p<=h&&f<=g;)o(m)?m=t[++p]:o(v)?v=t[--h]:Pr(m,y)?(A(m,y,r,e,f),m=t[++p],y=e[++f]):Pr(v,b)?(A(v,b,r,e,g),v=t[--h],b=e[--g]):Pr(m,b)?(A(m,b,r,e,g),x&&u.insertBefore(n,m.elm,u.nextSibling(v.elm)),m=t[++p],b=e[--g]):Pr(v,y)?(A(v,y,r,e,f),x&&u.insertBefore(n,v.elm,m.elm),v=t[--h],y=e[++f]):(o(s)&&(s=Sr(t,p,h)),o(c=a(y.key)?s[y.key]:k(y,t,p,h))?d(y,r,n,m.elm,!1,e,f):Pr(l=t[c],y)?(A(l,y,r,e,f),t[c]=void 0,x&&u.insertBefore(n,l.elm,m.elm)):d(y,r,n,m.elm,!1,e,f),y=e[++f]);p>h?_(n,o(e[g+1])?null:e[g+1].elm,e,f,g,r):f>g&&w(t,p,h)}(p,m,g,e,l):a(g)?(a(n.text)&&u.setTextContent(p,""),_(p,null,g,0,g.length-1,e)):a(m)?w(m,0,m.length-1):a(n.text)&&u.setTextContent(p,""):n.text!==t.text&&u.setTextContent(p,t.text),a(h)&&a(f=h.hook)&&a(f=f.postpatch)&&f(n,t)}}}function P(n,t,e){if(s(e)&&a(n.parent))n.parent.data.pendingInsert=t;else for(var r=0;r<t.length;++r)t[r].data.hook.insert(t[r])}var S=b("attrs,class,staticClass,staticStyle,key");function j(n,t,e,r){var i,o=t.tag,c=t.data,l=t.children;if(r=r||c&&c.pre,t.elm=n,s(t.isComment)&&a(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(a(c)&&(a(i=c.hook)&&a(i=i.init)&&i(t,!0),a(i=t.componentInstance)))return f(t,e),!0;if(a(o)){if(a(l))if(n.hasChildNodes())if(a(i=c)&&a(i=i.domProps)&&a(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var u=!0,p=n.firstChild,d=0;d<l.length;d++){if(!p||!j(p,l[d],e,r)){u=!1;break}p=p.nextSibling}if(!u||p)return!1}else m(t,l,e);if(a(c)){var h=!1;for(var v in c)if(!S(v)){h=!0,g(t,e);break}!h&&c.class&&Ht(c.class)}}else n.data!==t.text&&(n.data=t.text);return!0}return function(n,t,e,i){if(!o(t)){var c,l=!1,p=[];if(o(n))l=!0,d(t,p);else{var f=a(n.nodeType);if(!f&&Pr(n,t))A(n,t,p,null,null,i);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),e=!0),s(e)&&j(n,t,p))return P(t,p,!0),n;c=n,n=new hn(u.tagName(c).toLowerCase(),{},[],void 0,c)}var h=n.elm,m=u.parentNode(h);if(d(t,p,h._leaveCb?null:m,u.nextSibling(h)),a(t.parent))for(var g=t.parent,y=v(t);g;){for(var b=0;b<r.destroy.length;++b)r.destroy[b](g);if(g.elm=t.elm,y){for(var _=0;_<r.create.length;++_)r.create[_](kr,g);var C=g.data.hook.insert;if(C.merged)for(var k=C.fns.slice(1),S=0;S<k.length;S++)k[S]()}else wr(g);g=g.parent}a(m)?w([n],0,0):a(n.tag)&&x(n)}}return P(t,p,l),t.elm}a(n)&&x(n)}}({nodeOps:_r,modules:[Mr,zr,Kr,Jr,ci,X?{create:Ni,activate:Ni,remove:function(n,t){!0!==n.data.show?Oi(n,t):t()}}:{}].concat(Br)});Q&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&zi(n,"input")}));var Bi={inserted:function(n,t,e,r){"select"===e.tag?(r.elm&&!r.elm._vOptions?Kn(e,"postpatch",(function(){Bi.componentUpdated(n,t,e)})):$i(n,t,e.context),n._vOptions=[].map.call(n.options,Mi)):("textarea"===e.tag||br(n.type))&&(n._vModifiers=t.modifiers,t.modifiers.lazy||(n.addEventListener("compositionstart",Di),n.addEventListener("compositionend",Ui),n.addEventListener("change",Ui),Q&&(n.vmodel=!0)))},componentUpdated:function(n,t,e){if("select"===e.tag){$i(n,t,e.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,Mi);if(i.some((function(n,t){return!R(n,r[t])})))(n.multiple?t.value.some((function(n){return Ri(n,i)})):t.value!==t.oldValue&&Ri(t.value,i))&&zi(n,"change")}}};function $i(n,t,e){Ii(n,t,e),(J||Z)&&setTimeout((function(){Ii(n,t,e)}),0)}function Ii(n,t,e){var r=t.value,i=n.multiple;if(!i||Array.isArray(r)){for(var o,a,s=0,c=n.options.length;s<c;s++)if(a=n.options[s],i)o=M(r,Mi(a))>-1,a.selected!==o&&(a.selected=o);else if(R(Mi(a),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));i||(n.selectedIndex=-1)}}function Ri(n,t){return t.every((function(t){return!R(t,n)}))}function Mi(n){return"_value"in n?n._value:n.value}function Di(n){n.target.composing=!0}function Ui(n){n.target.composing&&(n.target.composing=!1,zi(n.target,"input"))}function zi(n,t){var e=document.createEvent("HTMLEvents");e.initEvent(t,!0,!0),n.dispatchEvent(e)}function Fi(n){return!n.componentInstance||n.data&&n.data.transition?n:Fi(n.componentInstance._vnode)}var Hi={model:Bi,show:{bind:function(n,t,e){var r=t.value,i=(e=Fi(e)).data&&e.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(e.data.show=!0,ji(e,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,t,e){var r=t.value;!r!=!t.oldValue&&((e=Fi(e)).data&&e.data.transition?(e.data.show=!0,r?ji(e,(function(){n.style.display=n.__vOriginalDisplay})):Oi(e,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,t,e,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},qi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Wi(n){var t=n&&n.componentOptions;return t&&t.Ctor.options.abstract?Wi(At(t.children)):n}function Vi(n){var t={},e=n.$options;for(var r in e.propsData)t[r]=n[r];var i=e._parentListeners;for(var r in i)t[P(r)]=i[r];return t}function Gi(n,t){if(/\d-keep-alive$/.test(t.tag))return n("keep-alive",{props:t.componentOptions.propsData})}var Ki=function(n){return n.tag||mt(n)},Xi=function(n){return"show"===n.name},Yi={name:"transition",props:qi,abstract:!0,render:function(n){var t=this,e=this.$slots.default;if(e&&(e=e.filter(Ki)).length){0;var r=this.mode;0;var i=e[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var o=Wi(i);if(!o)return i;if(this._leaving)return Gi(n,i);var a="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?a+"comment":a+o.tag:c(o.key)?0===String(o.key).indexOf(a)?o.key:a+o.key:o.key;var s=(o.data||(o.data={})).transition=Vi(this),l=this._vnode,u=Wi(l);if(o.data.directives&&o.data.directives.some(Xi)&&(o.data.show=!0),u&&u.data&&!function(n,t){return t.key===n.key&&t.tag===n.tag}(o,u)&&!mt(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var p=u.data.transition=N({},s);if("out-in"===r)return this._leaving=!0,Kn(p,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),Gi(n,i);if("in-out"===r){if(mt(o))return l;var d,f=function(){d()};Kn(s,"afterEnter",f),Kn(s,"enterCancelled",f),Kn(p,"delayLeave",(function(n){d=n}))}}return i}}},Ji=N({tag:String,moveClass:String},qi);function Qi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Zi(n){n.data.newPos=n.elm.getBoundingClientRect()}function no(n){var t=n.data.pos,e=n.data.newPos,r=t.left-e.left,i=t.top-e.top;if(r||i){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(r,"px,").concat(i,"px)"),o.transitionDuration="0s"}}delete Ji.mode;var to={Transition:Yi,TransitionGroup:{props:Ji,beforeMount:function(){var n=this,t=this._update;this._update=function(e,r){var i=Qt(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),t.call(n,e,r)}},render:function(n){for(var t=this.tag||this.$vnode.data.tag||"span",e=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],a=Vi(this),s=0;s<i.length;s++){if((u=i[s]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))o.push(u),e[u.key]=u,(u.data||(u.data={})).transition=a;else;}if(r){var c=[],l=[];for(s=0;s<r.length;s++){var u;(u=r[s]).data.transition=a,u.data.pos=u.elm.getBoundingClientRect(),e[u.key]?c.push(u):l.push(u)}this.kept=n(t,null,c),this.removed=l}return n(t,null,o)},updated:function(){var n=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,t)&&(n.forEach(Qi),n.forEach(Zi),n.forEach(no),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var e=n.elm,r=e.style;xi(e,t),r.transform=r.WebkitTransform=r.transitionDuration="",e.addEventListener(vi,e._moveCb=function n(r){r&&r.target!==e||r&&!/transform$/.test(r.propertyName)||(e.removeEventListener(vi,n),e._moveCb=null,wi(e,t))})}})))},methods:{hasMove:function(n,t){if(!hi)return!1;if(this._hasMove)return this._hasMove;var e=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){pi(e,n)})),ui(e,t),e.style.display="none",this.$el.appendChild(e);var r=Ai(e);return this.$el.removeChild(e),this._hasMove=r.hasTransform}}}};function eo(n,t){for(var e in t)n[e]=t[e];return n}Ge.config.mustUseProp=function(n,t,e){return"value"===e&&er(n)&&"button"!==t||"selected"===e&&"option"===n||"checked"===e&&"input"===n||"muted"===e&&"video"===n},Ge.config.isReservedTag=gr,Ge.config.isReservedAttr=tr,Ge.config.getTagNamespace=function(n){return vr(n)?"svg":"math"===n?"math":void 0},Ge.config.isUnknownElement=function(n){if(!X)return!0;if(gr(n))return!1;if(n=n.toLowerCase(),null!=yr[n])return yr[n];var t=document.createElement(n);return n.indexOf("-")>-1?yr[n]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:yr[n]=/HTMLUnknownElement/.test(t.toString())},N(Ge.options.directives,Hi),N(Ge.options.components,to),Ge.prototype.__patch__=X?Ti:B,Ge.prototype.$mount=function(n,t){return function(n,t,e){var r;n.$el=t,n.$options.render||(n.$options.render=mn),te(n,"beforeMount"),r=function(){n._update(n._render(),e)},new Vt(n,r,B,{before:function(){n._isMounted&&!n._isDestroyed&&te(n,"beforeUpdate")}},!0),e=!1;var i=n._preWatchers;if(i)for(var o=0;o<i.length;o++)i[o].run();return null==n.$vnode&&(n._isMounted=!0,te(n,"mounted")),n}(this,n=n&&X?function(n){if("string"==typeof n){var t=document.querySelector(n);return t||document.createElement("div")}return n}(n):void 0,t)},X&&setTimeout((function(){H.devtools&&cn&&cn.emit("init",Ge)}),0);var ro=/[!'()*]/g,io=function(n){return"%"+n.charCodeAt(0).toString(16)},oo=/%2C/g,ao=function(n){return encodeURIComponent(n).replace(ro,io).replace(oo,",")};function so(n){try{return decodeURIComponent(n)}catch(n){0}return n}var co=function(n){return null==n||"object"==typeof n?n:String(n)};function lo(n){var t={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var e=n.replace(/\+/g," ").split("="),r=so(e.shift()),i=e.length>0?so(e.join("=")):null;void 0===t[r]?t[r]=i:Array.isArray(t[r])?t[r].push(i):t[r]=[t[r],i]})),t):t}function uo(n){var t=n?Object.keys(n).map((function(t){var e=n[t];if(void 0===e)return"";if(null===e)return ao(t);if(Array.isArray(e)){var r=[];return e.forEach((function(n){void 0!==n&&(null===n?r.push(ao(t)):r.push(ao(t)+"="+ao(n)))})),r.join("&")}return ao(t)+"="+ao(e)})).filter((function(n){return n.length>0})).join("&"):null;return t?"?"+t:""}var po=/\/?$/;function fo(n,t,e,r){var i=r&&r.options.stringifyQuery,o=t.query||{};try{o=ho(o)}catch(n){}var a={name:t.name||n&&n.name,meta:n&&n.meta||{},path:t.path||"/",hash:t.hash||"",query:o,params:t.params||{},fullPath:go(t,i),matched:n?vo(n):[]};return e&&(a.redirectedFrom=go(e,i)),Object.freeze(a)}function ho(n){if(Array.isArray(n))return n.map(ho);if(n&&"object"==typeof n){var t={};for(var e in n)t[e]=ho(n[e]);return t}return n}var mo=fo(null,{path:"/"});function vo(n){for(var t=[];n;)t.unshift(n),n=n.parent;return t}function go(n,t){var e=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(e||"/")+(t||uo)(r)+i}function yo(n,t,e){return t===mo?n===t:!!t&&(n.path&&t.path?n.path.replace(po,"")===t.path.replace(po,"")&&(e||n.hash===t.hash&&bo(n.query,t.query)):!(!n.name||!t.name)&&(n.name===t.name&&(e||n.hash===t.hash&&bo(n.query,t.query)&&bo(n.params,t.params))))}function bo(n,t){if(void 0===n&&(n={}),void 0===t&&(t={}),!n||!t)return n===t;var e=Object.keys(n).sort(),r=Object.keys(t).sort();return e.length===r.length&&e.every((function(e,i){var o=n[e];if(r[i]!==e)return!1;var a=t[e];return null==o||null==a?o===a:"object"==typeof o&&"object"==typeof a?bo(o,a):String(o)===String(a)}))}function _o(n){for(var t=0;t<n.matched.length;t++){var e=n.matched[t];for(var r in e.instances){var i=e.instances[r],o=e.enteredCbs[r];if(i&&o){delete e.enteredCbs[r];for(var a=0;a<o.length;a++)i._isBeingDestroyed||o[a](i)}}}}var xo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,t){var e=t.props,r=t.children,i=t.parent,o=t.data;o.routerView=!0;for(var a=i.$createElement,s=e.name,c=i.$route,l=i._routerViewCache||(i._routerViewCache={}),u=0,p=!1;i&&i._routerRoot!==i;){var d=i.$vnode?i.$vnode.data:{};d.routerView&&u++,d.keepAlive&&i._directInactive&&i._inactive&&(p=!0),i=i.$parent}if(o.routerViewDepth=u,p){var f=l[s],h=f&&f.component;return h?(f.configProps&&wo(h,o,f.route,f.configProps),a(h,o,r)):a()}var m=c.matched[u],v=m&&m.components[s];if(!m||!v)return l[s]=null,a();l[s]={component:v},o.registerRouteInstance=function(n,t){var e=m.instances[s];(t&&e!==n||!t&&e===n)&&(m.instances[s]=t)},(o.hook||(o.hook={})).prepatch=function(n,t){m.instances[s]=t.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==m.instances[s]&&(m.instances[s]=n.componentInstance),_o(c)};var g=m.props&&m.props[s];return g&&(eo(l[s],{route:c,configProps:g}),wo(v,o,c,g)),a(v,o,r)}};function wo(n,t,e,r){var i=t.props=function(n,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(n);case"boolean":return t?n.params:void 0;default:0}}(e,r);if(i){i=t.props=eo({},i);var o=t.attrs=t.attrs||{};for(var a in i)n.props&&a in n.props||(o[a]=i[a],delete i[a])}}function Co(n,t,e){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return t+n;var i=t.split("/");e&&i[i.length-1]||i.pop();for(var o=n.replace(/^\//,"").split("/"),a=0;a<o.length;a++){var s=o[a];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function ko(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Ao=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Po=Uo,So=No,jo=function(n,t){return Bo(No(n,t),t)},Oo=Bo,Lo=Do,Eo=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function No(n,t){for(var e,r=[],i=0,o=0,a="",s=t&&t.delimiter||"/";null!=(e=Eo.exec(n));){var c=e[0],l=e[1],u=e.index;if(a+=n.slice(o,u),o=u+c.length,l)a+=l[1];else{var p=n[o],d=e[2],f=e[3],h=e[4],m=e[5],v=e[6],g=e[7];a&&(r.push(a),a="");var y=null!=d&&null!=p&&p!==d,b="+"===v||"*"===v,_="?"===v||"*"===v,x=e[2]||s,w=h||m;r.push({name:f||i++,prefix:d||"",delimiter:x,optional:_,repeat:b,partial:y,asterisk:!!g,pattern:w?Io(w):g?".*":"[^"+$o(x)+"]+?"})}}return o<n.length&&(a+=n.substr(o)),a&&r.push(a),r}function To(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Bo(n,t){for(var e=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(e[r]=new RegExp("^(?:"+n[r].pattern+")$",Mo(t)));return function(t,r){for(var i="",o=t||{},a=(r||{}).pretty?To:encodeURIComponent,s=0;s<n.length;s++){var c=n[s];if("string"!=typeof c){var l,u=o[c.name];if(null==u){if(c.optional){c.partial&&(i+=c.prefix);continue}throw new TypeError('Expected "'+c.name+'" to be defined')}if(Ao(u)){if(!c.repeat)throw new TypeError('Expected "'+c.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(c.optional)continue;throw new TypeError('Expected "'+c.name+'" to not be empty')}for(var p=0;p<u.length;p++){if(l=a(u[p]),!e[s].test(l))throw new TypeError('Expected all "'+c.name+'" to match "'+c.pattern+'", but received `'+JSON.stringify(l)+"`");i+=(0===p?c.prefix:c.delimiter)+l}}else{if(l=c.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):a(u),!e[s].test(l))throw new TypeError('Expected "'+c.name+'" to match "'+c.pattern+'", but received "'+l+'"');i+=c.prefix+l}}else i+=c}return i}}function $o(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Io(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Ro(n,t){return n.keys=t,n}function Mo(n){return n&&n.sensitive?"":"i"}function Do(n,t,e){Ao(t)||(e=t||e,t=[]);for(var r=(e=e||{}).strict,i=!1!==e.end,o="",a=0;a<n.length;a++){var s=n[a];if("string"==typeof s)o+=$o(s);else{var c=$o(s.prefix),l="(?:"+s.pattern+")";t.push(s),s.repeat&&(l+="(?:"+c+l+")*"),o+=l=s.optional?s.partial?c+"("+l+")?":"(?:"+c+"("+l+"))?":c+"("+l+")"}}var u=$o(e.delimiter||"/"),p=o.slice(-u.length)===u;return r||(o=(p?o.slice(0,-u.length):o)+"(?:"+u+"(?=$))?"),o+=i?"$":r&&p?"":"(?="+u+"|$)",Ro(new RegExp("^"+o,Mo(e)),t)}function Uo(n,t,e){return Ao(t)||(e=t||e,t=[]),e=e||{},n instanceof RegExp?function(n,t){var e=n.source.match(/\((?!\?)/g);if(e)for(var r=0;r<e.length;r++)t.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Ro(n,t)}(n,t):Ao(n)?function(n,t,e){for(var r=[],i=0;i<n.length;i++)r.push(Uo(n[i],t,e).source);return Ro(new RegExp("(?:"+r.join("|")+")",Mo(e)),t)}(n,t,e):function(n,t,e){return Do(No(n,e),t,e)}(n,t,e)}Po.parse=So,Po.compile=jo,Po.tokensToFunction=Oo,Po.tokensToRegExp=Lo;var zo=Object.create(null);function Fo(n,t,e){t=t||{};try{var r=zo[n]||(zo[n]=Po.compile(n));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),r(t,{pretty:!0})}catch(n){return""}finally{delete t[0]}}function Ho(n,t,e,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var o=(i=eo({},n)).params;return o&&"object"==typeof o&&(i.params=eo({},o)),i}if(!i.path&&i.params&&t){(i=eo({},i))._normalized=!0;var a=eo(eo({},t.params),i.params);if(t.name)i.name=t.name,i.params=a;else if(t.matched.length){var s=t.matched[t.matched.length-1].path;i.path=Fo(s,a,t.path)}else 0;return i}var c=function(n){var t="",e="",r=n.indexOf("#");r>=0&&(t=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(e=n.slice(i+1),n=n.slice(0,i)),{path:n,query:e,hash:t}}(i.path||""),l=t&&t.path||"/",u=c.path?Co(c.path,l,e||i.append):l,p=function(n,t,e){void 0===t&&(t={});var r,i=e||lo;try{r=i(n||"")}catch(n){r={}}for(var o in t){var a=t[o];r[o]=Array.isArray(a)?a.map(co):co(a)}return r}(c.query,i.query,r&&r.options.parseQuery),d=i.hash||c.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:u,query:p,hash:d}}var qo,Wo=function(){},Vo={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var t=this,e=this.$router,r=this.$route,i=e.resolve(this.to,r,this.append),o=i.location,a=i.route,s=i.href,c={},l=e.options.linkActiveClass,u=e.options.linkExactActiveClass,p=null==l?"router-link-active":l,d=null==u?"router-link-exact-active":u,f=null==this.activeClass?p:this.activeClass,h=null==this.exactActiveClass?d:this.exactActiveClass,m=a.redirectedFrom?fo(null,Ho(a.redirectedFrom),null,e):a;c[h]=yo(r,m,this.exactPath),c[f]=this.exact||this.exactPath?c[h]:function(n,t){return 0===n.path.replace(po,"/").indexOf(t.path.replace(po,"/"))&&(!t.hash||n.hash===t.hash)&&function(n,t){for(var e in t)if(!(e in n))return!1;return!0}(n.query,t.query)}(r,m);var v=c[h]?this.ariaCurrentValue:null,g=function(n){Go(n)&&(t.replace?e.replace(o,Wo):e.push(o,Wo))},y={click:Go};Array.isArray(this.event)?this.event.forEach((function(n){y[n]=g})):y[this.event]=g;var b={class:c},_=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:a,navigate:g,isActive:c[f],isExactActive:c[h]});if(_){if(1===_.length)return _[0];if(_.length>1||!_.length)return 0===_.length?n():n("span",{},_)}if("a"===this.tag)b.on=y,b.attrs={href:s,"aria-current":v};else{var x=function n(t){var e;if(t)for(var r=0;r<t.length;r++){if("a"===(e=t[r]).tag)return e;if(e.children&&(e=n(e.children)))return e}}(this.$slots.default);if(x){x.isStatic=!1;var w=x.data=eo({},x.data);for(var C in w.on=w.on||{},w.on){var k=w.on[C];C in y&&(w.on[C]=Array.isArray(k)?k:[k])}for(var A in y)A in w.on?w.on[A].push(y[A]):w.on[A]=g;var P=x.data.attrs=eo({},x.data.attrs);P.href=s,P["aria-current"]=v}else b.on=y}return n(this.tag,b,this.$slots.default)}};function Go(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var t=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return n.preventDefault&&n.preventDefault(),!0}}var Ko="undefined"!=typeof window;function Xo(n,t,e,r,i){var o=t||[],a=e||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(t,e,r,i,o,a){var s=i.path,c=i.name;0;var l=i.pathToRegexpOptions||{},u=function(n,t,e){e||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==t)return n;return ko(t.path+"/"+n)}(s,o,l.strict);"boolean"==typeof i.caseSensitive&&(l.sensitive=i.caseSensitive);var p={path:u,regex:Yo(u,l),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:c,parent:o,matchAs:a,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var o=a?ko(a+"/"+i.path):void 0;n(t,e,r,i,p,o)}));e[p.path]||(t.push(p.path),e[p.path]=p);if(void 0!==i.alias)for(var d=Array.isArray(i.alias)?i.alias:[i.alias],f=0;f<d.length;++f){0;var h={path:d[f],children:i.children};n(t,e,r,h,o,p.path||"/")}c&&(r[c]||(r[c]=p))}(o,a,s,n,i)}));for(var c=0,l=o.length;c<l;c++)"*"===o[c]&&(o.push(o.splice(c,1)[0]),l--,c--);return{pathList:o,pathMap:a,nameMap:s}}function Yo(n,t){return Po(n,[],t)}function Jo(n,t){var e=Xo(n),r=e.pathList,i=e.pathMap,o=e.nameMap;function a(n,e,a){var s=Ho(n,e,!1,t),l=s.name;if(l){var u=o[l];if(!u)return c(null,s);var p=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),e&&"object"==typeof e.params)for(var d in e.params)!(d in s.params)&&p.indexOf(d)>-1&&(s.params[d]=e.params[d]);return s.path=Fo(u.path,s.params),c(u,s,a)}if(s.path){s.params={};for(var f=0;f<r.length;f++){var h=r[f],m=i[h];if(Qo(m.regex,s.path,s.params))return c(m,s,a)}}return c(null,s)}function s(n,e){var r=n.redirect,i="function"==typeof r?r(fo(n,e,null,t)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return c(null,e);var s=i,l=s.name,u=s.path,p=e.query,d=e.hash,f=e.params;if(p=s.hasOwnProperty("query")?s.query:p,d=s.hasOwnProperty("hash")?s.hash:d,f=s.hasOwnProperty("params")?s.params:f,l){o[l];return a({_normalized:!0,name:l,query:p,hash:d,params:f},void 0,e)}if(u){var h=function(n,t){return Co(n,t.parent?t.parent.path:"/",!0)}(u,n);return a({_normalized:!0,path:Fo(h,f),query:p,hash:d},void 0,e)}return c(null,e)}function c(n,e,r){return n&&n.redirect?s(n,r||e):n&&n.matchAs?function(n,t,e){var r=a({_normalized:!0,path:Fo(e,t.params)});if(r){var i=r.matched,o=i[i.length-1];return t.params=r.params,c(o,t)}return c(null,t)}(0,e,n.matchAs):fo(n,e,r,t)}return{match:a,addRoute:function(n,t){var e="object"!=typeof n?o[n]:void 0;Xo([t||n],r,i,o,e),e&&e.alias.length&&Xo(e.alias.map((function(n){return{path:n,children:[t]}})),r,i,o,e)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Xo(n,r,i,o)}}}function Qo(n,t,e){var r=t.match(n);if(!r)return!1;if(!e)return!0;for(var i=1,o=r.length;i<o;++i){var a=n.keys[i-1];a&&(e[a.name||"pathMatch"]="string"==typeof r[i]?so(r[i]):r[i])}return!0}var Zo=Ko&&window.performance&&window.performance.now?window.performance:Date;function na(){return Zo.now().toFixed(3)}var ta=na();function ea(){return ta}function ra(n){return ta=n}var ia=Object.create(null);function oa(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(n,""),e=eo({},window.history.state);return e.key=ea(),window.history.replaceState(e,"",t),window.addEventListener("popstate",ca),function(){window.removeEventListener("popstate",ca)}}function aa(n,t,e,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var o=function(){var n=ea();if(n)return ia[n]}(),a=i.call(n,t,e,r?o:null);a&&("function"==typeof a.then?a.then((function(n){fa(n,o)})).catch((function(n){0})):fa(a,o))}))}}function sa(){var n=ea();n&&(ia[n]={x:window.pageXOffset,y:window.pageYOffset})}function ca(n){sa(),n.state&&n.state.key&&ra(n.state.key)}function la(n){return pa(n.x)||pa(n.y)}function ua(n){return{x:pa(n.x)?n.x:window.pageXOffset,y:pa(n.y)?n.y:window.pageYOffset}}function pa(n){return"number"==typeof n}var da=/^#\d/;function fa(n,t){var e,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=da.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var o=n.offset&&"object"==typeof n.offset?n.offset:{};t=function(n,t){var e=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-e.left-t.x,y:r.top-e.top-t.y}}(i,o={x:pa((e=o).x)?e.x:0,y:pa(e.y)?e.y:0})}else la(n)&&(t=ua(n))}else r&&la(n)&&(t=ua(n));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:n.behavior}):window.scrollTo(t.x,t.y))}var ha,ma=Ko&&((-1===(ha=window.navigator.userAgent).indexOf("Android 2.")&&-1===ha.indexOf("Android 4.0")||-1===ha.indexOf("Mobile Safari")||-1!==ha.indexOf("Chrome")||-1!==ha.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function va(n,t){sa();var e=window.history;try{if(t){var r=eo({},e.state);r.key=ea(),e.replaceState(r,"",n)}else e.pushState({key:ra(na())},"",n)}catch(e){window.location[t?"replace":"assign"](n)}}function ga(n){va(n,!0)}var ya={redirected:2,aborted:4,cancelled:8,duplicated:16};function ba(n,t){return xa(n,t,ya.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var t={};return wa.forEach((function(e){e in n&&(t[e]=n[e])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}function _a(n,t){return xa(n,t,ya.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function xa(n,t,e,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=t,i.type=e,i}var wa=["params","query","hash"];function Ca(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ka(n,t){return Ca(n)&&n._isRouter&&(null==t||n.type===t)}function Aa(n,t,e){var r=function(i){i>=n.length?e():n[i]?t(n[i],(function(){r(i+1)})):r(i+1)};r(0)}function Pa(n){return function(t,e,r){var i=!1,o=0,a=null;Sa(n,(function(n,t,e,s){if("function"==typeof n&&void 0===n.cid){i=!0,o++;var c,l=La((function(t){var i;((i=t).__esModule||Oa&&"Module"===i[Symbol.toStringTag])&&(t=t.default),n.resolved="function"==typeof t?t:qo.extend(t),e.components[s]=t,--o<=0&&r()})),u=La((function(n){var t="Failed to resolve async component "+s+": "+n;a||(a=Ca(n)?n:new Error(t),r(a))}));try{c=n(l,u)}catch(n){u(n)}if(c)if("function"==typeof c.then)c.then(l,u);else{var p=c.component;p&&"function"==typeof p.then&&p.then(l,u)}}})),i||r()}}function Sa(n,t){return ja(n.map((function(n){return Object.keys(n.components).map((function(e){return t(n.components[e],n.instances[e],n,e)}))})))}function ja(n){return Array.prototype.concat.apply([],n)}var Oa="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function La(n){var t=!1;return function(){for(var e=[],r=arguments.length;r--;)e[r]=arguments[r];if(!t)return t=!0,n.apply(this,e)}}var Ea=function(n,t){this.router=n,this.base=function(n){if(!n)if(Ko){var t=document.querySelector("base");n=(n=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(t),this.current=mo,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Na(n,t,e,r){var i=Sa(n,(function(n,r,i,o){var a=function(n,t){"function"!=typeof n&&(n=qo.extend(n));return n.options[t]}(n,t);if(a)return Array.isArray(a)?a.map((function(n){return e(n,r,i,o)})):e(a,r,i,o)}));return ja(r?i.reverse():i)}function Ta(n,t){if(t)return function(){return n.apply(t,arguments)}}Ea.prototype.listen=function(n){this.cb=n},Ea.prototype.onReady=function(n,t){this.ready?n():(this.readyCbs.push(n),t&&this.readyErrorCbs.push(t))},Ea.prototype.onError=function(n){this.errorCbs.push(n)},Ea.prototype.transitionTo=function(n,t,e){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(t){t(n)})),n}var o=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),t&&t(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,o)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){e&&e(n),n&&!i.ready&&(ka(n,ya.redirected)&&o===mo||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(n)}))))}))},Ea.prototype.confirmTransition=function(n,t,e){var r=this,i=this.current;this.pending=n;var o,a,s=function(n){!ka(n)&&Ca(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(t){t(n)})):console.error(n)),e&&e(n)},c=n.matched.length-1,l=i.matched.length-1;if(yo(n,i)&&c===l&&n.matched[c]===i.matched[l])return this.ensureURL(),n.hash&&aa(this.router,i,n,!1),s(((a=xa(o=i,n,ya.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",a));var u=function(n,t){var e,r=Math.max(n.length,t.length);for(e=0;e<r&&n[e]===t[e];e++);return{updated:t.slice(0,e),activated:t.slice(e),deactivated:n.slice(e)}}(this.current.matched,n.matched),p=u.updated,d=u.deactivated,f=u.activated,h=[].concat(function(n){return Na(n,"beforeRouteLeave",Ta,!0)}(d),this.router.beforeHooks,function(n){return Na(n,"beforeRouteUpdate",Ta)}(p),f.map((function(n){return n.beforeEnter})),Pa(f)),m=function(t,e){if(r.pending!==n)return s(_a(i,n));try{t(n,i,(function(t){!1===t?(r.ensureURL(!0),s(function(n,t){return xa(n,t,ya.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,n))):Ca(t)?(r.ensureURL(!0),s(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(s(ba(i,n)),"object"==typeof t&&t.replace?r.replace(t):r.push(t)):e(t)}))}catch(n){s(n)}};Aa(h,m,(function(){Aa(function(n){return Na(n,"beforeRouteEnter",(function(n,t,e,r){return function(n,t,e){return function(r,i,o){return n(r,i,(function(n){"function"==typeof n&&(t.enteredCbs[e]||(t.enteredCbs[e]=[]),t.enteredCbs[e].push(n)),o(n)}))}}(n,e,r)}))}(f).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return s(_a(i,n));r.pending=null,t(n),r.router.app&&r.router.app.$nextTick((function(){_o(n)}))}))}))},Ea.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ea.prototype.setupListeners=function(){},Ea.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=mo,this.pending=null};var Ba=function(n){function t(t,e){n.call(this,t,e),this._startLocation=$a(this.base)}return n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var t=this.router,e=t.options.scrollBehavior,r=ma&&e;r&&this.listeners.push(oa());var i=function(){var e=n.current,i=$a(n.base);n.current===mo&&i===n._startLocation||n.transitionTo(i,(function(n){r&&aa(t,n,e,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(n){window.history.go(n)},t.prototype.push=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){va(ko(r.base+n.fullPath)),aa(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.replace=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){ga(ko(r.base+n.fullPath)),aa(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.ensureURL=function(n){if($a(this.base)!==this.current.fullPath){var t=ko(this.base+this.current.fullPath);n?va(t):ga(t)}},t.prototype.getCurrentLocation=function(){return $a(this.base)},t}(Ea);function $a(n){var t=window.location.pathname,e=t.toLowerCase(),r=n.toLowerCase();return!n||e!==r&&0!==e.indexOf(ko(r+"/"))||(t=t.slice(n.length)),(t||"/")+window.location.search+window.location.hash}var Ia=function(n){function t(t,e,r){n.call(this,t,e),r&&function(n){var t=$a(n);if(!/^\/#/.test(t))return window.location.replace(ko(n+"/#"+t)),!0}(this.base)||Ra()}return n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,e=ma&&t;e&&this.listeners.push(oa());var r=function(){var t=n.current;Ra()&&n.transitionTo(Ma(),(function(r){e&&aa(n.router,r,t,!0),ma||za(r.fullPath)}))},i=ma?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},t.prototype.push=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){Ua(n.fullPath),aa(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.replace=function(n,t,e){var r=this,i=this.current;this.transitionTo(n,(function(n){za(n.fullPath),aa(r.router,n,i,!1),t&&t(n)}),e)},t.prototype.go=function(n){window.history.go(n)},t.prototype.ensureURL=function(n){var t=this.current.fullPath;Ma()!==t&&(n?Ua(t):za(t))},t.prototype.getCurrentLocation=function(){return Ma()},t}(Ea);function Ra(){var n=Ma();return"/"===n.charAt(0)||(za("/"+n),!1)}function Ma(){var n=window.location.href,t=n.indexOf("#");return t<0?"":n=n.slice(t+1)}function Da(n){var t=window.location.href,e=t.indexOf("#");return(e>=0?t.slice(0,e):t)+"#"+n}function Ua(n){ma?va(Da(n)):window.location.hash=n}function za(n){ma?ga(Da(n)):window.location.replace(Da(n))}var Fa=function(n){function t(t,e){n.call(this,t,e),this.stack=[],this.index=-1}return n&&(t.__proto__=n),t.prototype=Object.create(n&&n.prototype),t.prototype.constructor=t,t.prototype.push=function(n,t,e){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,t&&t(n)}),e)},t.prototype.replace=function(n,t,e){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),t&&t(n)}),e)},t.prototype.go=function(n){var t=this,e=this.index+n;if(!(e<0||e>=this.stack.length)){var r=this.stack[e];this.confirmTransition(r,(function(){var n=t.current;t.index=e,t.updateRoute(r),t.router.afterHooks.forEach((function(t){t&&t(r,n)}))}),(function(n){ka(n,ya.duplicated)&&(t.index=e)}))}},t.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},t.prototype.ensureURL=function(){},t}(Ea),Ha=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Jo(n.routes||[],this);var t=n.mode||"hash";switch(this.fallback="history"===t&&!ma&&!1!==n.fallback,this.fallback&&(t="hash"),Ko||(t="abstract"),this.mode=t,t){case"history":this.history=new Ba(this,n.base);break;case"hash":this.history=new Ia(this,n.base,this.fallback);break;case"abstract":this.history=new Fa(this,n.base);break;default:0}},qa={currentRoute:{configurable:!0}};Ha.prototype.match=function(n,t,e){return this.matcher.match(n,t,e)},qa.currentRoute.get=function(){return this.history&&this.history.current},Ha.prototype.init=function(n){var t=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var e=t.apps.indexOf(n);e>-1&&t.apps.splice(e,1),t.app===n&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=n;var e=this.history;if(e instanceof Ba||e instanceof Ia){var r=function(n){e.setupListeners(),function(n){var r=e.current,i=t.options.scrollBehavior;ma&&i&&"fullPath"in n&&aa(t,n,r,!1)}(n)};e.transitionTo(e.getCurrentLocation(),r,r)}e.listen((function(n){t.apps.forEach((function(t){t._route=n}))}))}},Ha.prototype.beforeEach=function(n){return Va(this.beforeHooks,n)},Ha.prototype.beforeResolve=function(n){return Va(this.resolveHooks,n)},Ha.prototype.afterEach=function(n){return Va(this.afterHooks,n)},Ha.prototype.onReady=function(n,t){this.history.onReady(n,t)},Ha.prototype.onError=function(n){this.history.onError(n)},Ha.prototype.push=function(n,t,e){var r=this;if(!t&&!e&&"undefined"!=typeof Promise)return new Promise((function(t,e){r.history.push(n,t,e)}));this.history.push(n,t,e)},Ha.prototype.replace=function(n,t,e){var r=this;if(!t&&!e&&"undefined"!=typeof Promise)return new Promise((function(t,e){r.history.replace(n,t,e)}));this.history.replace(n,t,e)},Ha.prototype.go=function(n){this.history.go(n)},Ha.prototype.back=function(){this.go(-1)},Ha.prototype.forward=function(){this.go(1)},Ha.prototype.getMatchedComponents=function(n){var t=n?n.matched?n:this.resolve(n).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(n){return Object.keys(n.components).map((function(t){return n.components[t]}))}))):[]},Ha.prototype.resolve=function(n,t,e){var r=Ho(n,t=t||this.history.current,e,this),i=this.match(r,t),o=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,t,e){var r="hash"===e?"#"+t:t;return n?ko(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:i}},Ha.prototype.getRoutes=function(){return this.matcher.getRoutes()},Ha.prototype.addRoute=function(n,t){this.matcher.addRoute(n,t),this.history.current!==mo&&this.history.transitionTo(this.history.getCurrentLocation())},Ha.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==mo&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Ha.prototype,qa);var Wa=Ha;function Va(n,t){return n.push(t),function(){var e=n.indexOf(t);e>-1&&n.splice(e,1)}}Ha.install=function n(t){if(!n.installed||qo!==t){n.installed=!0,qo=t;var e=function(n){return void 0!==n},r=function(n,t){var r=n.$options._parentVnode;e(r)&&e(r=r.data)&&e(r=r.registerRouteInstance)&&r(n,t)};t.mixin({beforeCreate:function(){e(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",xo),t.component("RouterLink",Vo);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Ha.version="3.6.5",Ha.isNavigationFailure=ka,Ha.NavigationFailureType=ya,Ha.START_LOCATION=mo,Ko&&window.Vue&&window.Vue.use(Ha);e(96);e(123),e(90);var Ga={"components/AlgoliaSearchBox":()=>Promise.all([e.e(0),e.e(13)]).then(e.bind(null,303)),"components/DropdownLink":()=>Promise.all([e.e(0),e.e(14)]).then(e.bind(null,256)),"components/DropdownTransition":()=>Promise.all([e.e(0),e.e(19)]).then(e.bind(null,244)),"components/Home":()=>Promise.all([e.e(0),e.e(16)]).then(e.bind(null,282)),"components/Navbar":()=>Promise.all([e.e(0),e.e(1)]).then(e.bind(null,300)),"components/NavLink":()=>e.e(21).then(e.bind(null,243)),"components/NavLinks":()=>Promise.all([e.e(0),e.e(12)]).then(e.bind(null,267)),"components/Page":()=>Promise.all([e.e(0),e.e(11)]).then(e.bind(null,283)),"components/PageEdit":()=>Promise.all([e.e(0),e.e(17)]).then(e.bind(null,269)),"components/PageNav":()=>Promise.all([e.e(0),e.e(15)]).then(e.bind(null,270)),"components/Sidebar":()=>Promise.all([e.e(0),e.e(10)]).then(e.bind(null,284)),"components/SidebarButton":()=>Promise.all([e.e(0),e.e(20)]).then(e.bind(null,285)),"components/SidebarGroup":()=>Promise.all([e.e(0),e.e(3)]).then(e.bind(null,268)),"components/SidebarLink":()=>Promise.all([e.e(0),e.e(18)]).then(e.bind(null,257)),"components/SidebarLinks":()=>Promise.all([e.e(0),e.e(3)]).then(e.bind(null,255)),"global-components/Badge":()=>Promise.all([e.e(0),e.e(4)]).then(e.bind(null,308)),"global-components/CodeBlock":()=>Promise.all([e.e(0),e.e(5)]).then(e.bind(null,304)),"global-components/CodeGroup":()=>Promise.all([e.e(0),e.e(6)]).then(e.bind(null,305)),"layouts/404":()=>e.e(7).then(e.bind(null,306)),"layouts/Layout":()=>Promise.all([e.e(0),e.e(1),e.e(2)]).then(e.bind(null,307)),NotFound:()=>e.e(7).then(e.bind(null,306)),Layout:()=>Promise.all([e.e(0),e.e(1),e.e(2)]).then(e.bind(null,307))},Ka={"v-469ddbfc":()=>e.e(23).then(e.bind(null,309)),"v-1e45f7b8":()=>e.e(24).then(e.bind(null,310)),"v-30d622f4":()=>e.e(25).then(e.bind(null,311)),"v-e1212422":()=>e.e(27).then(e.bind(null,312)),"v-5ec813a6":()=>e.e(29).then(e.bind(null,313)),"v-9b0d847c":()=>e.e(30).then(e.bind(null,314)),"v-ddd4c684":()=>e.e(22).then(e.bind(null,315)),"v-5ab67464":()=>e.e(28).then(e.bind(null,316)),"v-608b7a94":()=>e.e(26).then(e.bind(null,317)),"v-3899f2b6":()=>e.e(32).then(e.bind(null,318)),"v-bcb174f2":()=>e.e(31).then(e.bind(null,319)),"v-464a6c05":()=>e.e(33).then(e.bind(null,320)),"v-27e95ee0":()=>e.e(34).then(e.bind(null,321)),"v-2dd5a64b":()=>e.e(36).then(e.bind(null,322)),"v-1f019c97":()=>e.e(35).then(e.bind(null,323))};function Xa(n){const t=Object.create(null);return function(e){return t[e]||(t[e]=n(e))}}const Ya=/-(\w)/g,Ja=Xa(n=>n.replace(Ya,(n,t)=>t?t.toUpperCase():"")),Qa=/\B([A-Z])/g,Za=Xa(n=>n.replace(Qa,"-$1").toLowerCase()),ns=Xa(n=>n.charAt(0).toUpperCase()+n.slice(1));function ts(n,t){if(!t)return;if(n(t))return n(t);return t.includes("-")?n(ns(Ja(t))):n(ns(t))||n(Za(t))}const es=Object.assign({},Ga,Ka),rs=n=>es[n],is=n=>Ka[n],os=n=>Ga[n],as=n=>Ge.component(n);function ss(n){return ts(is,n)}function cs(n){return ts(os,n)}function ls(n){return ts(rs,n)}function us(n){return ts(as,n)}function ps(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!us(n)&&ls(n)){const t=await ls(n)();Ge.component(n,t.default)}}))}function ds(n,t){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=t)}var fs=e(86),hs=e.n(fs),ms=e(87),vs=e.n(ms),gs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,t])=>t),this.$ssrContext){const t=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=t)?n.map(n=>{let t="<meta";return Object.keys(n).forEach(e=>{t+=` ${e}="${vs()(n[e])}"`}),t+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=_s(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return hs()([{name:"description",content:this.$description}],n,this.siteMeta,xs)},updateCanonicalLink(){ys(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){_s(null,this.currentMetaTags),ys()}};function ys(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function _s(n,t){if(t&&[...t].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const t=document.createElement("meta");return Object.keys(n).forEach(e=>{t.setAttribute(e,n[e])}),document.head.appendChild(t),t})}function xs(n){for(const t of["name","property","itemprop"])if(n.hasOwnProperty(t))return n[t]+t;return JSON.stringify(n)}var ws=e(88),Cs={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:e.n(ws)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter(t=>n.some(n=>n.hash===t.hash)),e=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+e;for(let n=0;n<t.length;n++){const o=t[n],a=t[n+1],s=0===n&&0===e||e>=o.parentElement.offsetTop+10&&(!a||e<a.parentElement.offsetTop-10),c=decodeURIComponent(this.$route.hash);if(s&&c!==decodeURIComponent(o.hash)){const e=o;if(i===r)for(let e=n+1;e<t.length;e++)if(c===decodeURIComponent(t[e].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(e.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},ks=e(22),As=e.n(ks),Ps={mounted(){As.a.configure({showSpinner:!1}),this.$router.beforeEach((n,t,e)=>{n.path===t.path||Ge.component(n.name)||As.a.start(),e()}),this.$router.afterEach(()=>{As.a.done(),this.isSidebarOpen=!1})}},Ss=e(89),js=e.n(Ss),Os=[gs,Cs,Ps,{mounted(){js.a.polyfill()}}],Ls={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ds("layout",n),Ge.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Es=e(14),Ns=Object(Es.a)(Ls,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,t,e){switch(t){case"components":n[t]||(n[t]={}),Object.assign(n[t],e);break;case"mixins":n[t]||(n[t]=[]),n[t].push(...e);break;default:throw new Error("Unknown option name.")}}(Ns,"mixins",Os);const Ts=[{name:"v-469ddbfc",path:"/",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-469ddbfc").then(e)}},{path:"/index.html",redirect:"/"},{name:"v-1e45f7b8",path:"/algorithm/1_Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE.html",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-1e45f7b8").then(e)}},{path:"/algorithm/1_Acwing算法基础课.html",redirect:"/algorithm/1_Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE.html"},{path:"/algorithm/1_Acwing算法基础课.html",redirect:"/algorithm/1_Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE.html"},{name:"v-30d622f4",path:"/algorithm/2_LeetCode.html",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-30d622f4").then(e)}},{name:"v-e1212422",path:"/algorithm/",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-e1212422").then(e)}},{path:"/algorithm/index.html",redirect:"/algorithm/"},{name:"v-5ec813a6",path:"/cs-basis/2_EffectiveC++.html",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-5ec813a6").then(e)}},{name:"v-9b0d847c",path:"/cs-basis/3_STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.html",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-9b0d847c").then(e)}},{path:"/cs-basis/3_STL源码剖析.html",redirect:"/cs-basis/3_STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.html"},{path:"/cs-basis/3_STL源码剖析.html",redirect:"/cs-basis/3_STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.html"},{name:"v-ddd4c684",path:"/cs-basis/4_ComputerNetwork.html",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-ddd4c684").then(e)}},{name:"v-5ab67464",path:"/cs-basis/1_C++.html",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-5ab67464").then(e)}},{name:"v-608b7a94",path:"/algorithm/3_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-608b7a94").then(e)}},{path:"/algorithm/3_数据结构.html",redirect:"/algorithm/3_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"},{path:"/algorithm/3_数据结构.html",redirect:"/algorithm/3_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"},{name:"v-3899f2b6",path:"/cs-basis/6_%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-3899f2b6").then(e)}},{path:"/cs-basis/6_计算机体系结构.html",redirect:"/cs-basis/6_%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html"},{path:"/cs-basis/6_计算机体系结构.html",redirect:"/cs-basis/6_%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html"},{name:"v-bcb174f2",path:"/cs-basis/5_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-bcb174f2").then(e)}},{path:"/cs-basis/5_操作系统.html",redirect:"/cs-basis/5_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"},{path:"/cs-basis/5_操作系统.html",redirect:"/cs-basis/5_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"},{name:"v-464a6c05",path:"/cs-basis/",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-464a6c05").then(e)}},{path:"/cs-basis/index.html",redirect:"/cs-basis/"},{name:"v-27e95ee0",path:"/notes/1_Windows%E6%9F%A5%E7%9C%8BWiFi%E5%AF%86%E7%A0%81.html",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-27e95ee0").then(e)}},{path:"/notes/1_Windows查看WiFi密码.html",redirect:"/notes/1_Windows%E6%9F%A5%E7%9C%8BWiFi%E5%AF%86%E7%A0%81.html"},{path:"/notes/1_Windows查看WiFi密码.html",redirect:"/notes/1_Windows%E6%9F%A5%E7%9C%8BWiFi%E5%AF%86%E7%A0%81.html"},{name:"v-2dd5a64b",path:"/notes/",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-2dd5a64b").then(e)}},{path:"/notes/index.html",redirect:"/notes/"},{name:"v-1f019c97",path:"/notes/2_snprintf%E5%AF%BC%E8%87%B4%E7%9A%84-Wformat-truncation%E8%AD%A6%E6%8A%A5.html",component:Ns,beforeEnter:(n,t,e)=>{ps("Layout","v-1f019c97").then(e)}},{path:"/notes/2_snprintf导致的-Wformat-truncation警报.html",redirect:"/notes/2_snprintf%E5%AF%BC%E8%87%B4%E7%9A%84-Wformat-truncation%E8%AD%A6%E6%8A%A5.html"},{path:"/notes/2_snprintf导致的-Wformat-truncation警报.html",redirect:"/notes/2_snprintf%E5%AF%BC%E8%87%B4%E7%9A%84-Wformat-truncation%E8%AD%A6%E6%8A%A5.html"},{path:"*",component:Ns}],Bs={title:"FeoBay的个人博客",description:"Just for fun",base:"/",headTags:[["link",{rel:"icon",href:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/terminal.svg"}]],pages:[{title:"Home",frontmatter:{home:!0,heroImage:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/head1.jpg",heroText:"FeoBay的个人博客",tagline:"All those moments will be lost in time, like tears in rain.",actionText:"开始浏览 →",actionLink:"/cs-basis/",features:[{title:"好大一棵树",details:"种树的最好时机在十年前，其次就是现在。"},{title:"Einstein",details:"Zweisteine"},{title:"群星尽头",details:"太阳还有十亿年就会开始膨胀，地球也将被吞噬，宇宙最终也会陷入热寂，所有事物都会走向虚无。所以悲观没有意义，你只需要好好享受这段旅途。"}]},regularPath:"/",relativePath:"README.md",key:"v-469ddbfc",path:"/",content:" Welcome to my blog! \n MIT Licensed | Copyright © 2022-present  Feobay \n "},{title:"算法基础课笔记",frontmatter:{},regularPath:"/algorithm/1_Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE.html",relativePath:"algorithm/1_Acwing算法基础课.md",key:"v-1e45f7b8",path:"/algorithm/1_Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE.html",headers:[{level:2,title:"Chapter 1 基础算法",slug:"chapter-1-基础算法"},{level:3,title:"1.快速排序",slug:"_1-快速排序"},{level:3,title:"2.归并排序",slug:"_2-归并排序"},{level:3,title:"3.二分",slug:"_3-二分"},{level:3,title:"4.高精度",slug:"_4-高精度"},{level:2,title:"Chapter 2 数据结构",slug:"chapter-2-数据结构"},{level:3,title:"1.静态链表",slug:"_1-静态链表"},{level:3,title:"2.栈",slug:"_2-栈"},{level:3,title:"3.滑动窗口",slug:"_3-滑动窗口"},{level:3,title:"4.KMP字符串",slug:"_4-kmp字符串"},{level:3,title:"5.Trie字符串统计",slug:"_5-trie字符串统计"},{level:3,title:"6.堆",slug:"_6-堆"},{level:3,title:"7.哈希表",slug:"_7-哈希表"},{level:3,title:"8.常见STL",slug:"_8-常见stl"},{level:2,title:"Chapter 3 搜索与图论",slug:"chapter-3-搜索与图论"},{level:3,title:"1.DFS(Deep First Search)",slug:"_1-dfs-deep-first-search"},{level:3,title:"2.BFS(Breadth First Search)",slug:"_2-bfs-breadth-first-search"},{level:3,title:"3.树和图的存储",slug:"_3-树和图的存储"},{level:3,title:"4.树和图的遍历",slug:"_4-树和图的遍历"},{level:3,title:"5.朴素Dijkstra",slug:"_5-朴素dijkstra"},{level:3,title:"6.堆优化版Dijkstra",slug:"_6-堆优化版dijkstra"},{level:3,title:"7.Bellman-Ford算法",slug:"_7-bellman-ford算法"},{level:2,title:"Chapter 5 动态规划",slug:"chapter-5-动态规划"},{level:3,title:"1.背包问题",slug:"_1-背包问题"},{level:3,title:"2.线性DP",slug:"_2-线性dp"},{level:3,title:"3.区间DP",slug:"_3-区间dp"},{level:3,title:"4.计数类DP",slug:"_4-计数类dp"},{level:3,title:"5.数位统计DP",slug:"_5-数位统计dp"},{level:3,title:"6.状态压缩DP",slug:"_6-状态压缩dp"},{level:3,title:"7.树形DP",slug:"_7-树形dp"},{level:3,title:"8.记忆化搜索",slug:"_8-记忆化搜索"},{level:2,title:"Chapter 6 贪心",slug:"chapter-6-贪心"},{level:3,title:"1.区间问题",slug:"_1-区间问题"},{level:3,title:"2.Huffman树",slug:"_2-huffman树"},{level:3,title:"3.排序不等式",slug:"_3-排序不等式"},{level:3,title:"4.绝对值不等式",slug:"_4-绝对值不等式"},{level:3,title:"5.推公式",slug:"_5-推公式"}],content:' 算法基础课笔记 \n 主要包括六个部分：基础算法，数据结构，搜索和图论，数学知识，动态规划，贪心 \n Chapter 1 基础算法 \n 1.快速排序 \n ACW785.快速排序模板 \ninclude   <iostream> \n using   namespace  std ; \n\n const   int  N  =   1e5   +   10 ; \n int  arr [ N ] ,  n ; \n\n void   quickSort ( int   * arr ,   int  l ,   int  r )   { \n     if   ( l  >=  r )   return ; \n     int  x  =  arr [ ( l  +  r )   >>   1 ] ; \n     int  i  =  l  -   1 ,  j  =  r  +   1 ; \n     while   ( i  <  j )   { \n         do  i ++ ;   while   ( arr [ i ]   <  x ) ; \n         do  j -- ;   while   ( arr [ j ]   >  x ) ; \n         if   ( i  <  j )   swap ( arr [ i ] ,  arr [ j ] ) ; \n     } \n     quickSort ( arr ,  l ,  j ) ,   quickSort ( arr ,  j  +   1 ,  r ) ; \n } \n\n int   main ( )   { \n    cin  >>  n ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )  cin  >>  arr [ i ] ; \n     quickSort ( arr ,   0 ,  n  -   1 ) ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )  cout  <<  arr [ i ]   <<   \' \' ; \n     return   0 ; \n } \n 2.归并排序 \n 先将区数组分成每个区间长度为1的区间 \n 再在回溯的时候由下至上两两合并 \n void   mergeSort ( int   * arr ,   int  l ,   int  r )   { \n     if   ( l  >=  r )   return ; \n     int  mid  =  l  +  r  >>   1 ; \n     mergeSort ( arr ,  l ,  mid ) ,   mergeSort ( arr ,  mid  +   1 ,  r ) ; \n     int  i  =  l ,  j  =  mid  +   1 ,  k  =   0 ; \n     while   ( i  <=  mid  &&  j  <=  r )   { \n         if   ( arr [ i ]   <=  arr [ j ] )  tmp [ k ++ ]   =  arr [ i ++ ] ; \n         else  tmp [ k ++ ]   =  arr [ j ++ ] ; \n     } \n     while   ( i  <=  mid )  tmp [ k ++ ]   =  arr [ i ++ ] ; \n     while   ( j  <=  r )  tmp [ k ++ ]   =  arr [ j ++ ] ; \n     for   ( i  =  l ,  k  =   0 ;  i  <=  r ;   ++ k ,   ++ i )  arr [ i ]   =  tmp [ k ] ; \n } \n \n ACW788.逆序对 \n #include <iostream>\nusing namespace std;\n\nconst int N = 1e5 + 10;\nint n, a[N], tmp[N];\nlong long res; // 可能爆int\n\nvoid getRe(int *arr, int l, int r) {\n    if (l == r) return ;\n    int mid = (l + r) >> 1;\n    getRe(arr, l, mid), getRe(arr, mid + 1, r);\n    int i = l, j = mid + 1, k = 0;\n    while (i <= mid && j <= r) {\n        if (arr[i] <= arr[j]) {\n            tmp[k++] = arr[i++];\n        }\n        else {\n            res += mid - i + 1;\n            tmp[k++] = arr[j++];\n        }\n    }\n    while (i <= mid) tmp[k++] = arr[i++];\n    while (j <= r) tmp[k++] = arr[j++];\n    for (i = l, k = 0; i <= r; ++i, ++k) arr[i] = tmp[k];\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) cin >> a[i];\n    getRe(a, 0, n - 1);\n    cout << res << endl;\n    return 0;\n}\n 3.二分 \n ACW789.数的范围 \ninclude   <iostream> \n using   namespace  std ; \n\n const   int  N  =   1e5   +   10 ; \n int  a [ N ] ; \n int  n ,  q ,  k ; \n\n int   main ( )   { \n    cin  >>  n  >>  q ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )  cin  >>  a [ i ] ; \n     while   ( q -- )   { \n        cin  >>  k ; \n         int  mid ,  l  =   0 ,  r  =  n  -   1 ; \n         while   ( l  <  r )   { \n            mid  =   ( l  +  r )   >>   1 ; \n             if   ( a [ mid ]   <  k )  l  =  mid  +   1 ;   // 求左边界，l = mid + 1遇到左边界l就不再变化 \n             else  r  =  mid ; \n         } \n         if   ( a [ l ]   ==  k )   { \n            cout  <<  l  <<   \' \' ; \n            l  =   0 ,  r  =  n  -   1 ; \n             while   ( l  <  r )   { \n                mid  =   ( l  +  r  +   1 )   >>   1 ;   // 上取整，防止l不改变 \n                 if   ( a [ mid ]   >  k )  r  =  mid  -   1 ;   // 求右边界，r = mid - 1遇到右边界r就不再变化 \n                 else  l  =  mid ; \n             } \n            cout  <<  r  <<  endl ; \n         }   else   { \n            cout  <<   "-1 -1"   <<  endl ; \n         } \n     } \n     return   0 ; \n } \n \n ACW790.数的三次方 \ninclude   <iostream> \ninclude   <iomanip> \n using   namespace  std ; \n\n int   main ( )   { \n     float  n ; \n    cin  >>  n ; \n     double  l  =   - 10000 ,  r  =   10000 ; \n     while   ( r  -  l  >=   1e-7 )   { \n         double  mid  =   ( l  +  r )   /   2 ; \n         if   ( mid  *  mid  *  mid  >=  n )  r  =  mid ; \n         else  l  =  mid ; \n     } \n    cout  <<  fixed  <<   setprecision ( 6 )   <<  l  <<  endl ; \n     return   0 ; \n } \n 4.高精度 \n ACW.791高精度加法 \ninclude   <iostream> \ninclude   <string> \ninclude   <algorithm> \n using   namespace  std ; \n\nstring  addInteger ( string a ,  string b )   { \n     if   ( a . size ( )   <  b . size ( ) )   swap ( a ,  b ) ;   // 长整数在前 \n     reverse ( a . begin ( ) ,  a . end ( ) ) ; \n     reverse ( b . begin ( ) ,  b . end ( ) ) ; \n    string ans ; \n     int  c  =   0 ,  tmp ;   // c 为进位，tmp为当前位的和 \n     int  i ; \n     for   ( i  =   0 ;  i  <  a . size ( )   &&  i  <  b . size ( ) ;   ++ i )   { \n        tmp  =  a [ i ]   -   \'0\'   +  b [ i ]   -   \'0\'   +  c ; \n        ans  +=  tmp  %   10   +   \'0\' ; \n        c  =  tmp  /   10 ; \n     } \n     // 继续补完a剩余的长度 \n     for   ( ;  i  <  a . size ( ) ;   ++ i )   { \n        tmp  =  a [ i ]   -   \'0\'   +  c ; \n        ans  +=  tmp  %   10   +   \'0\' ; \n        c  =  tmp  /   10 ; \n     } \n     if   ( c )  ans  +=  c  +   \'0\' ; \n     reverse ( ans . begin ( ) ,  ans . end ( ) ) ; \n     return  ans ; \n } \n\n int   main ( )   { \n    string a ,  b ; \n    cin  >>  a  >>  b ; \n    cout  <<   addInteger ( a ,  b )   <<  endl ; \n     return   0 ; \n } \n \n ACW792.高精度减法 \ninclude <iostream> \ninclude <vector> \n using   namespace  std ; \n\n const   int  N  =   1e6 + 10 ; \n bool   cmp ( vector < int >  A , vector < int >  B ) \n { \n     if ( A . size ( ) != B . size ( ) )   return  A . size ( ) > B . size ( ) ; \n     for ( int  i = A . size ( ) - 1 ; i >= 0 ; i -- ) \n     { \n         if ( A [ i ] != B [ i ] ) \n             return  A [ i ] > B [ i ] ; \n     } \n     return   true ; \n } \nvector < int >   sub ( vector < int >   & A , vector < int >   & B ) \n { \n    vector < int >  C ; \n\n     int  t  =   0 ; \n     for ( int  i = 0 ;  i  <  A . size ( ) ;  i ++ ) \n     { \n        t  =  A [ i ]   -  t ; \n         if ( i  <  B . size ( ) )  t  -=  B [ i ] ; \n        C . push_back ( ( t  +   10 )   %   10 ) ; \n         if ( t  <   0 )  t  =   1 ; \n         else  t  = 0   ; \n     } \n     while ( C . size ( )   >   1   &&  C . back ( )   ==   0 )  C . pop_back ( ) ; \n     return  C ; \n } \n\n int   main ( ) \n { \n    string a , b ; \n    vector < int >  A , B ; \n    cin >> a >> b ; \n     for ( int  i = a . size ( ) - 1 ; i >= 0 ; i -- ) \n        A . push_back ( a [ i ]   -   \'0\' ) ; \n     for ( int  i = b . size ( ) - 1 ;  i  >=   0 ; i -- ) \n        B . push_back ( b [ i ] - \'0\' ) ; \n     if ( cmp ( A , B ) ) \n     { \n        vector < int >  C  =   sub ( A ,  B ) ; \n         for ( int  i = C . size ( ) - 1 ; i >= 0 ; i -- ) \n            cout << C [ i ] ; \n\n     } \n     else \n     { \n        vector < int >  C  =   sub ( B ,  A ) ; \n        cout << \'-\' ; \n         for ( int  i = C . size ( ) - 1 ; i >= 0 ; i -- ) \n            cout << C [ i ] ; \n     } \n     return   0 ; \n } \n Chapter 2 数据结构 \n 1.静态链表 \n 2.栈 \n 3.滑动窗口 \n 4.KMP字符串 \n 5.Trie字符串统计 \n const   int  N  =   100010 ; \n int  son [ N ] [ 26 ] ,  cnt [ N ] ,  idx ; \n //son[N][26] saves the son—node,  \n void   insert ( char  str [ ] )   { \n     int  p  =   0 ; \n     for   ( int  i  =   0 ;  str [ i ] ;  i ++ )   { \n         int  u  =  str [ i ]   -   \'a\' ; \n         if   ( ! son [ p ] [ u ] )   { \n            son [ p ] [ u ]   =   ++  idx ; \n         } \n        p  =  son [ p ] [ u ] ; \n        cnt [ p ]   ++ ; \n     } \n } \n 6.堆 \n 7.哈希表 \n 8.常见STL \n Chapter 3 搜索与图论 \n 1.DFS(Deep First Search) \n 例题，输出一组数的全排列。 \ninclude   <iostream> \ndefine   IOS   { ios :: sync_with_stdio ( false ) ,  cin . tie ( 0 ) ,  cout . tie ( 0 ) ; } \n using   namespace  std ; \n\n const   int  N  =   10 ; \n\n int  n ; \n int  path [ N ] ; \n bool  st [ N ] ;   //state \n\n void   dfs ( int  u )   {   //u表示当前遍历层数 \n     if   ( u  ==  n )   {   //当层数u为最深层数n时，输出路径，并返回 \n         for   ( int  i   =   0 ;  i  <  n ;  i ++ )   { \n            cout  <<  path [ i ]   <<   \' \' ; \n         } \n         puts ( "" ) ; \n         return ; \n     } \n\n     for   ( int  i  =   1 ;  i  <=  n ;  i ++ )   { \n         if   ( ! st [ i ] )   { \n            path [ u ]   =  i ; \n            st [ i ]   =   true ; \n             dfs ( u  +   1 ) ; \n            st [ i ]   =   false ;   //每置一次false就相当于向上返回一层 \n            path [ u ]   =   0 ;   //与上一句一起用于恢复上一层的现场 \n         } \n     } \n } \n\n int   main ( )   { \n    IOS\n    cin  >>  n ; \n     dfs ( 0 ) ; \n     return   0 ; \n } \n \n 例题，八皇后 \ninclude   <iostream> \n using   namespace  std ; \n\n const   int  N  =   20 ; \n int  n ; \n char  g [ N ] [ N ] ; \n bool  col [ N ] ,  dg [ N ] ,  udg [ N ] ; \n\n void   dfs ( int  u )   { \n     if   ( u  ==  n )   { \n         for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n            cout  <<  g [ i ]   <<  endl ; \n         } \n        cout  <<  endl ; \n     } \n\n     for   ( int  i  =   0 ;  i  <  n ;  i ++ )   { \n         if   ( ! col [ i ]   &&   ! dg [ u  +  i ]   &&   ! udg [ i  -  u  +  n ] )   { \n            g [ u ] [ i ]   =   \'Q\' ; \n            col [ i ]   =  dg [ u  +  i ]   =  udg [ i  -  u  +  n ]   =   true ; \n             dfs ( u  +   1 ) ; \n            col [ i ]   =  dg [ u  +  i ]   =  udg [ i  -  u  +  n ]   =   false ; \n            g [ u ] [ i ]   =   \'.\' ; \n         } \n     } \n } \n\n int   main ( )   { \n    cin  >>  n ; \n     for   ( int  i  =   0 ;  i  <  n ;  i ++ )   { \n         for   ( int  j  =   0 ;  j  <  n ;  j ++ )   { \n            g [ i ] [ j ]   =   \'.\' ; \n         } \n     } \n     dfs ( 0 ) ; \n     return   0 ; \n } \n 2.BFS(Breadth First Search) \n 例题，走迷宫，宽搜： \n 当所有边的权重相同时，才可以用宽搜来做最短路。 \ninclude   <iostream> \ninclude   <queue> \n using   namespace  std ; \n\n struct   node   { \n     int  x ,  y ,  d ;   \n } ; \n\n int  n ,  m ; \n const   int  N  =   105 ; \n int  a [ N ] [ N ] ; \n bool  st [ N ] [ N ] ; \n\n int  movex [ ]   =   { 0 ,   0 ,   - 1 ,   1 } ,  movey [ ]   =   { 1 ,   - 1 ,   0 ,   0 } ; \n\n int   bfs ( )   { \n    queue < node >  q ; \n    q . push ( { 1 ,   1 ,   0 } ) ; \n    st [ 1 ] [ 1 ]   =   true ; \n     while   ( q . size ( ) )   { \n        node t  =  q . front ( ) ; \n        q . pop ( ) ; \n         for   ( int  i  =   0 ;  i  <   4 ;   ++ i )   { \n             int  nx  =  t . x  +  movex [ i ] ,  ny  =  t . y  +  movey [ i ] ; \n             if   ( nx  <   1   ||  nx  >  n  ||  ny  <   1   ||  ny  >  m  ||  st [ nx ] [ ny ]   ||  a [ nx ] [ ny ] )   continue ; \n             if   ( nx  ==  n  &&  ny  ==  m )   return  t . d  +   1 ; \n            st [ nx ] [ ny ]   =   true ; \n            q . push ( { nx ,  ny ,  t . d  +   1 } ) ; \n         } \n     } \n } \n\n int   main ( )   { \n     scanf ( "%d%d" ,   & n ,   & m ) ; \n     for   ( int  i  =   1 ;  i  <=  n ;   ++ i )   { \n         for   ( int  j  =   1 ;  j  <=  m ;   ++ j )   { \n             scanf ( "%d" ,   & a [ i ] [ j ] ) ; \n         } \n     } \n     printf ( "%d\\n" ,   bfs ( ) ) ; \n     return   0 ; \n } \n 3.树和图的存储 \n 树是一种无环图，所以按照图来存储即可 \n 图分为有向图和无向图。无向图可去可会，意味着相当于有向图在两个点之间建立一去一回两条边，所以只用考虑有向图如何存储即可。 \n 有向图存储的两种方式：邻接矩阵和邻接表 \n **邻接矩阵：**开个二维数组即可，表示从  x->y  是否连通。 \n **邻接表：**每个点开一个单链表，表示能到哪个点。 \n  \n 图的存储 \ninclude   <iostream> \n using   namespace  std ; \n\n const   int  N  =   100010 ,   M  =  N  *   2 ; \n\n int  h [ N ] ,  e [ M ] ,  ne [ M ] ,  idx ;   // idx就是地址 \n\n void   add ( int  a ,   int  b )   {   // 头插 \n    e [ idx ]   =  b ,  ne [ idx ]   =  h [ a ] ,  h [ a ]   =  idx ++ ; \n } \n\n int   main ( )   { \n\n     return   0 ; \n } \n 4.树和图的遍历 \n DFS \n  \n BFS \ninclude   <iostream> \ninclude   <cstring> \n using   namespace  std ; \n\n const   int  N  =   100010 ,   M  =  N  *   2 ; \n\n int  h [ N ] ,  e [ M ] ,  ne [ M ] ,  idx ;   // idx就是地址 \n int  n ,  m ; \n bool  st [ N ] ; \n\n void   add ( int  a ,   int  b )   {   // 头插 \n    e [ idx ]   =  b ,  ne [ idx ]   =  h [ a ] ,  h [ a ]   =  idx ++ ; \n } \n\n void   dfs ( int  u )   { \n    st [ u ]   =   true ;   //标记已经被搜过了 \n     for   ( int  i  =  h [ u ] ;  i  !=   - 1 ;  i  =  ne [ i ] )   { \n         int  j  =  e [ i ] ;   //存储当前节点对应图中编号 \n         if   ( ! st [ j ] )   dfs ( j ) ; \n     } \n } \n\n int   main ( )   { \n\t memset ( h ,   - 1 ,   sizeof  h ) ; \n     return   0 ; \n } \n \n 例题， ACW846树的重心 \ninclude   <iostream> \ninclude   <cstring> \ninclude   <algorithm> \n using   namespace  std ; \n\n const   int  N  =   1e5   +   10 ,  M  =  N  *   2 ;   // N \n int  n ,  m ; \n int  h [ N ] ,  e [ M ] ,  ne [ M ] ,  idx ;   // h为头，e为节点的值，ne为节点的下一个节点的索引，idx为节点的索引 \n bool  st [ N ] ; \n\n int  ans  =  N ; \n\n void   add ( int  a ,   int  b )   {   // 在连通块a中插入节点b \n    e [ idx ]   =  b ,  ne [ idx ]   =  h [ a ] ,  h [ a ]   =  idx ++ ; \n } \n\n int   dfs ( int  u )   { \n    st [ u ]   =   true ;   //标记以下，已经被搜过了 \n\n     int  sum  =   1 ,  res  =   0 ; \n     for   ( int  i  =  h [ u ] ;  i  !=   - 1 ;  i  =  ne [ i ] )   { \n         int  j  =  e [ i ] ; \n         if   ( ! st [ j ] )   { \n             int  s  =   dfs ( j ) ; \n            res  =   max ( res ,  s ) ; \n            sum  +=  s ; \n         } \n     } \n\n    res  =   max ( res ,  n  -  sum ) ; \n    ans  =   min ( ans ,  res ) ; \n     return  sum ; \n } \n\n int   main ( )   { \n     memset ( h ,   - 1 ,   sizeof ( h ) ) ; \n    cin  >>  n ; \n     for   ( int  i  =   0 ;  i  <  n  -   1 ;   ++ i )   { \n         int  a ,  b ; \n        cin  >>  a  >>  b ; \n         add ( a ,  b ) ,   add ( b ,  a ) ; \n     } \n\n     dfs ( 1 ) ; \n    cout  <<  ans  <<  endl ; \n     return   0 ; \n } \n \n 最短路算法 \n 学习最短路算法的重点在于将问题抽象为最短路，最短路算法的证明可以自己搜索了解。 \n 点数n，边数m \n \n 稠密图： $m$ ~ $n^2$ \n 稀疏图：  m ~ n \n 5.朴素Dijkstra \n 步骤： \n 1.初始化各边（ g[x][y] ）大小，存在则更新为该大小，不存在则更新为正无穷 0x3f3f3f3f ; 初始化各点到起点的路径距离，除了起点为0（ dist[1] = 0 ), 其余均为正无穷 0x3f3f3f3f (memset(g, 0x3f, sizeof g)) \n 2.进行n次迭代，每次迭代都换一点作为更新的点 \n ​\t2.1找到当前距离起点最小的点 t \n ​\t2.2使用t来更新其它点到起点的距离 dist[j] \n e.g  ACWING.Dijkstra求最短路 I \ninclude   <iostream> \ninclude   <algorithm> \ninclude   <string> \ninclude   <cstring> \n using   namespace  std ; \n\n const   int  N  =   510 ; \n\n int  n ,  m ; \n int  g [ N ] [ N ] ;   //存储每个边的距离（邻接表） \n int  dist [ N ] ;   //存储每个点到起点1的距离 \n bool  st [ N ] ;   //已遍历点集合 \n\n // o(n^2) \n int   dijkstra ( )   { \n     // 1.初始化 \n     memset ( dist ,   0x3f ,   sizeof  dist ) ; \n    dist [ 1 ]   =   0 ; \n\n     // 2.迭代找出最小点 \n     for ( int  j  =   1 ;  j  <=  n ;  j ++ )   {   //n个点，m条边 \n         int  t  =   - 1 ;   //t用来存储当前未更新完的点中到起点距离最小的点 \n\n         //2.1 遍历所有点找出当前未被遍历的最小点，记录进t \n         for   ( int  j  =   1 ;  j  <=  n ;  j ++ )   { \n             if   ( ! st [ j ]   &&   ( t  ==   - 1   ||  dist [ t ]   >  dist [ j ] ) )  t  =  j ; \n         } \n        st [ t ]   =   true ;   //找到最小的点并以它作为起点更新其出度指向点 \n         //作为下一次的起点则将该点放入已遍历集合 \n\n         //2.2 用当前点作为起点更新所有点到1的距离（实际上就是遍历所有点） \n         for   ( int  j  =   1 ;  j  <=  n ;  j ++ )   { \n            dist [ j ]   =   min ( dist [ j ] ,  dist [ t ]   +  g [ t ] [ j ] ) ;   //不用判断，不存在的边是正无穷 \n         } \n     } \n     if   ( dist [ n ]   ==   0x3f3f3f3f )   return   - 1 ;   //说明1与n不连通 \n     return  dist [ n ] ;   //否则返回最短距离  \n } \n\n int   main ( )   { \n     scanf ( "%d%d" ,   & n ,   & m ) ; \n     memset ( g ,   0x3f ,   sizeof  g ) ; \n\n     while   ( m  --   )   { \n         int  a ,  b ,  c ; \n         scanf ( "%d%d%d" ,   & a ,   & b ,   & c ) ; \n        g [ a ] [ b ]   =   min ( g [ a ] [ b ] ,  c ) ;   //有可能在输入阶段重复输入同一条边，但长度不同 \n     } \n     int  t  =   dijkstra ( ) ; \n     printf ( "%d\\n" ,  t ) ; \n     return   0 ; \n } \n 6.堆优化版Dijkstra \n 改用邻接表存储，每次将已经确定长度的点放入堆中 \n Dijkstra II \ninclude   <iostream> \ninclude   <cstring> \ninclude   <queue> \n using   namespace  std ; \n\n using  PII  =  pair < int ,   int > ; \n\n const   int  N  =   150010 ; \n\n //稀疏图使用邻接表存储 \n int  idx ,  e [ N ] ,  ne [ N ] ,  h [ N ] ;   //idx相当于指针，e存的值为idx指向边的入度点（终点），ne为idx的next指针，h[x]为以x为起点的边的指针 \n int  w [ N ] ;   //存权重,即为每个出边的大小,每条边都有个独特的地址idx来存 \n int  dist [ N ] ; //存每个点到起点的距离 \n bool  st [ N ] ; //存每个点是否被访问 \n\n int  n ,  m ; \n\n void   add ( int  x ,   int  y ,   int  c )   { \n    w [ idx ]   =  c ;   //重边不要紧，会更新两次放入堆中，最终的结果仍然是按照最小的来计算 \n    e [ idx ]   =  y ; \n    ne [ idx ]   =  h [ x ] ; \n    h [ x ]   =  idx ++ ; \n } \n\n int   dijkstra ( )   { \n     memset ( dist ,   0x3f ,   sizeof  dist ) ; \n    dist [ 1 ]   =   0 ; \n    priority_queue < PII ,  vector < PII > ,  greater < PII >>  heap ;   //小根堆 \n    heap . push ( { 0 ,   1 } ) ;   //堆根据pair的第一个值排序，所以第一个值为距离，第二个值为对应的点索引  \n     while ( heap . size ( ) )   { \n        PII k  =  heap . top ( ) ; \n        heap . pop ( ) ; \n         int  ind  =  k . second ,  dis  =  k . first ; \n        \n         if   ( st [ ind ] )   continue ; \n        st [ ind ]   =   true ; \n\n         for   ( int  i  =  h [ ind ] ;  i  !=   - 1 ;  i  =  ne [ i ] )   { \n             int  j  =  e [ i ] ; \n             if   ( dist [ j ]   >  dis  +  w [ i ] )   { \n                dist [ j ]   =  dis  +  w [ i ] ; \n                heap . push ( { dist [ j ] ,  j } ) ; \n             } \n         } \n     } \n     if   ( dist [ n ]   ==   0x3f3f3f3f )   return   - 1 ; \n     return  dist [ n ] ; \n } \n\n int   main ( )   { \n     memset ( h ,   - 1 ,   sizeof  h ) ; \n    cin  >>  n  >>  m ; \n     while   ( m -- )   { \n         int  x ,  y ,  z ; \n        cin  >>  x  >>  y  >>  z ; \n         add ( x ,  y ,  z ) ; \n     } \n\n    cout  <<   dijkstra ( )   <<  endl ; \n     return   0 ; \n } \n 7.Bellman-Ford算法 \n 贝尔曼算法 \n  \n 若有负权回路，且负权在某一条到终点的路径上，那么就会使dist变为负无穷，那么就不存在最短路。 \n 或者说限制路径最多边数，负权回路也可以求出最短路（此时就需要使用Bellman算法） \n Bellman-Ford算法注意点： \n **串联：**同一个路径上在一次遍历中就前进了两条边（就无法通过外层循环限制边数了） \n 所以需要进行备份。 \n 正无穷可能被更新 \n Chapter 5 动态规划 \n 1.背包问题 \n 2.线性DP \n 3.区间DP \n 4.计数类DP \n 5.数位统计DP \n AcWing 338.计数问题 \n 思路： \ninclude   <iostream> \ninclude   <vector> \ninclude   <algorithm> \n using   namespace  std ; \n\n // l为低位，r为高位 \n int   get ( vector < int >   & num ,   int  l ,   int  r )   { \n     int  res  =   0 ; \n     for   ( int  i  =  r ;  i  >=  l ;   -- i )   { \n        res  =  res  *   10   +  num [ i ] ; \n     } \n     return  res ; \n } \n\n int   power10 ( int  x )   { \n     int  res  =   1 ; \n     while   (  x --   )  res  *=   10 ; \n     return  res ; \n } \n\n // 1 ~ n 的数字中，x出现的次数 \n int   countBit ( int  n ,   int  x )   { \n     if   ( ! n )   return   0 ; \n     // 将n的每一位从低位开始依次放入vector中 \n    vector < int >  num ; \n     while   ( n )   { \n        num . push_back ( n  %   10 ) ; \n        n  /=   10 ; \n     } \n    n  =  num . size ( ) ; \n\n     int  res  =   0 ; \n     // 从高位开始算起，x为0则不从上线高位开始算 \n     for   ( int  i  =  n  -   1   -   ! x ;  i  >=   0 ;   -- i )   { \n         if   ( i  <  n  -   1 )   {   // x 在 num[i]这个位置出现的次数，num[i] 前面部分的数在[1, get(num, i + 1, n - 1) - 1]之间的情况 \n            res  +=   get ( num ,  i  +   1 ,  n  -   1 )   *   power10 ( i ) ; \n             if ( ! x )  res  -=   power10 ( i ) ;   // 减去为0的情况 \n         } \n         // 前面的数等于上限的情况 \n         if   ( num [ i ]   ==  x )  res  +=   get ( num ,   0 ,  i  -   1 )   +   1 ;   // 加上末尾为0的情况 \n         else   if   ( num [ i ]   >  x )  res  +=   power10 ( i ) ; \n     } \n     return  res ; \n } \n\n int   main ( )   { \n     int  a ,  b ; \n     while   ( cin  >>  a  >>  b ,  a  ||  b )   { \n         if   ( a  >  b )   swap ( a ,  b ) ; \n\n         for   ( int  i  =   0 ;  i  <   10 ;   ++ i )   { \n            cout  <<   countBit ( b ,  i )   -   countBit ( a  -   1 ,  i )   <<   \' \' ; \n         } \n        cout  <<  endl ; \n     } \n     return   0 ; \n } \n 6.状态压缩DP \n 7.树形DP \n 8.记忆化搜索 \n Chapter 6 贪心 \n 1.区间问题 \n ACW905.区间选点 \n 给定 $N$ 个闭区间 $[a_i,b_i]$，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。 \n 输出选择的点的最小数量。 \n 位于区间端点上的点也算作区间内。 \n 输入格式 \n 第一行包含整数 $N$，表示区间数。 \n 接下来 $N$ 行，每行包含两个整数 $a_i,b_i$表示一个区间的两个端点。 \n 输出格式 \n 输出一个整数，表示所需的点的最小数量。 \n 数据范围 \n $1, ≤ , N ,  ≤ , 10^5$\n$−10^9 , ≤ , a_i , ≤ , b_i , ≤ ,10^9$ \n 输入样例 ： \n 3\n-1 1\n2 4\n3 5\n \n 输出样例 ： \n 2\n \n \n 解法：按照右端点小到大排序 \ninclude   <iostream> \ninclude   <algorithm> \n using   namespace  std ; \n\n // 区间选点 \n // 1.将每个区间按右端点从小到大排序 \n // 2.从前往后依次枚举每个区间，如果当前区间中已经包含点，则直接pass \n //   否则，选择当前区间的右端点 \n\n const   int  N  =   1e5   +   10 ; \n\n struct   Range   { \n     int  l ,  r ; \n     bool   operator < ( const  Range  & w )   const   { \n         return  r  <  w . r ; \n     } \n }  range [ N ] ; \n\n\n int   main ( )   { \n     int  n ; \n     scanf ( "%d" ,   & n ) ; \n     int  l ,  r ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n         scanf ( "%d%d" ,   & l ,   & r ) ; \n        range [ i ]   =   { l ,  r } ; \n     } \n\n     sort ( range ,  range  +  n ) ; \n     int  ans  =   0 ,  ed  =   - 2e9 ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n         if   ( range [ i ] . l  >  ed )   { \n             ++ ans ; \n            ed  =  range [ i ] . r ; \n         } \n     } \n     printf ( "%d" ,  ans ) ; \n     return   0 ; \n } \n \n ACW908.最大不相交区间数量 \ninclude   <iostream> \ninclude   <algorithm> \n using   namespace  std ; \n\n const   int  N  =   1e5   +   10 ; \n struct   Range   { \n     int  l ,  r ; \n     bool   operator < ( const  Range  & w )   { \n         return  r  <  w . r ; \n     } \n }  range [ N ] ; \n\n int   main ( )   { \n     int  n ; \n    cin  >>  n ; \n     int  l ,  r ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n        cin  >>  l  >>  r ; \n        range [ i ]   =   { l ,  r } ; \n     } \n\n     sort ( range ,  range  +  n ) ; \n     int  ed  =   - 2e9 ,  ans  =   0 ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n         if   ( range [ i ] . l  >  ed )   { \n             ++ ans ; \n            ed  =  range [ i ] . r ; \n         } \n     } \n    cout  <<  ans  <<  endl ; \n     return   0 ; \n } \n\n\n\n /*\n证明：\n\n假设最优解为 ans 个不相交区间，以上述贪心思路选出来的区间为 cnt 个。即证明 ans = cnt，等价于 ans >= cnt && ans <= cnt\n首先，以上述贪心思路选择出的 cnt 个区间，是一组可行方案。其覆盖了所有区间，满足题目要求。且 ans 表示的是所有可行方案的最大值，那么 ans >= cnt 成立\n证明 ans <= cnt 时，可以采用反证法。假设 ans > cnt，则说明最多有 ans 个两两不交的区间，则至少需要 ans 个点才能将这些区间全部覆盖，然而实际上只需要 cnt 个点就能覆盖全部区间，且 cnt < ans。则矛盾，故 ans <= cnt 成立\n时间复杂度：O ( n l o g n ) O(nlogn)O(nlogn)\n*/ \n \n ACW906.区间分组 \ninclude   <iostream> \ninclude   <algorithm> \ninclude   <queue> \n using   namespace  std ; \n\n // 做法 \n // 1.将区间按照左端点进行排序 \n // 2.从前往后处理每个组的区间 \n //      判断能否将其放到某个现有的组中 L[i] > Max_r \n //          1.如果不存在这样的组，则开新组，然后再将其放进去； \n //          2.如果存在这样的组，将其放进去，并更新当前组的Max_r \n\n const   int  N  =   1e5   +   10 ; \n struct   Range   { \n     int  l ,  r ; \n     bool   operator < ( const  Range  & w )   const   { \n         return  l  <  w . l ; \n     } \n }  range [ N ] ; \n\n int   main ( )   { \n     int  n ; \n    cin  >>  n ; \n     int  l ,  r ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n        cin  >>  l  >>  r ; \n        range [ i ]   =   { l ,  r } ; \n     } \n     sort ( range ,  range  +  n ) ; \n    priority_queue < int ,  vector < int > ,  greater < int >>  heap ;   // 小根堆，最小的边界在最上方 \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n         auto  tmp  =  range [ i ] ; \n         if   ( heap . empty ( )   ||  heap . top ( )   >=  tmp . l )  heap . push ( tmp . r ) ;   // 有交集或者堆为空，则将该边界放入heap，相当于新建组 \n         else   { \n             // int t = heap.top(); \n            heap . pop ( ) ;   // pop出同组的右边界 \n            heap . push ( tmp . r ) ;   // 更新右边界 \n         } \n     } \n    cout  <<  heap . size ( )   <<  endl ; \n     return   0 ; \n } \n \n ACW907.区间覆盖 \ninclude   <iostream> \ninclude   <algorithm> \n using   namespace  std ; \n\n // 1.将所有区间按左端点从小到大排序 \n // 2.从前往后依次枚举每个区间，在所有能覆盖的start的区间中，选择右端点最大的区间 \n //   然后将start更新成右端点的最大值 \n\n const   int  N  =   1e5   +   10 ; \n\n int  n ; \n struct   Range   { \n     int  l ,  r ; \n     bool   operator < ( const  Range  & w )   const   { \n         return  l  <  w . l ; \n     } \n }  range [ N ] ; \n\n int   main ( )   { \n     int  st ,  ed ; \n    cin  >>  st  >>  ed ; \n    cin  >>  n ; \n     int  l ,  r ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n        cin  >>  l  >>  r ; \n        range [ i ]   =   { l ,  r } ; \n     } \n     sort ( range ,  range  +  n ) ; \n     int  ans  =   0 ; \n     bool  success  =   false ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n         int  j  =  i ,  r  =   - 2e9 ; \n         // 寻找所有 左端点在st左边的区间 的 右端点的最大值 \n         while   ( j  <  n  &&  range [ j ] . l  <=  st )   { \n            r  =   max ( r ,  range [ j ] . r ) ; \n             ++ j ; \n         } \n         if   ( r  <  st )   { \n            ans  =   - 1 ; \n             break ; \n         } \n         ++ ans ; \n         if   ( r  >=  ed )   { \n            success  =   true ; \n             break ; \n         } \n        st  =  r ; \n        i  =  j  -   1 ;   // 最后计算到的区间，因为后面还要++i，所以是j - 1 \n     } \n     if   ( ! success )  cout  <<   - 1   <<  endl ; \n     else  cout  <<  ans  <<  endl ; \n     return   0 ; \n } \n 2.Huffman树 \n ACW148.合并果子 \n \n 每次选择最小的两个数 \ninclude   <iostream> \ninclude   <queue> \n using   namespace  std ; \n\n // 每次选最小的两个合并(哈夫曼树) \n\n int   main ( )   { \n     int  n ; \n    cin  >>  n ; \n    priority_queue < int ,  vector < int > ,  greater < int >>  heap ; \n     int  x ; \n     while   ( n -- )   { \n        cin  >>  x ; \n        heap . push ( x ) ; \n     } \n     int  a ,  b ,  res  =   0 ; \n     while   ( heap . size ( )   >   1 )   { \n        a  =  heap . top ( ) ;  heap . pop ( ) ; \n        b  =  heap . top ( ) ;  heap . pop ( ) ; \n        res  +=  a  +  b ; \n        heap . push ( a  +  b ) ; \n     } \n    cout  <<  res  <<  endl ; \n     return   0 ; \n } \n 3.排序不等式 \n ACW913.排队打水 \ninclude   <iostream> \ninclude   <algorithm> \ninclude   <queue> \n using   namespace  std ; \n\n const   int  N  =   1e6   +   10 ; \n int  a [ N ] ; \n\n int   main ( )   { \n     int  n ; \n     scanf ( "%d" ,   & n ) ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n         scanf ( "%d" ,   & a [ i ] ) ; \n     } \n\n     sort ( a ,  a  +  n ) ; \n    \n     long   long  res  =   0 ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n        res  +=   ( n  -  i  -   1 )   *  a [ i ] ; \n     } \n    cout  <<  res  <<  endl ; \n     return   0 ; \n } \n 4.绝对值不等式 \n ACW104.货仓选址 \ninclude   <iostream> \ninclude   <algorithm> \n using   namespace  std ; \n\n // 在数轴上选择一个点，使得该点到其它所有点的距离之和最小 \n // 解法：绝对值不等式即可 \n // 对于两个数，选点在两数之间即可选出最小值 \n // 对于n个数，第一个和最后一个数为一组，第二个和倒数第二个数一组 \n //      - 奇数选到中位数 \n //      - 偶数选到中间两数之间即可 \n\n const   int  N  =   1e5   +   10 ; \n int  a [ N ] ; \n long   long  res  =   0 ; \n\n int   main ( )   { \n     int  n ; \n     scanf ( "%d" ,   & n ) ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   scanf ( "%d" ,   & a [ i ] ) ; \n     sort ( a ,  a  +  n ) ; \n     int  idx  =  n  /   2 ;   // 可以不用判断奇数偶数，奇数时idx正好为中位数，偶数时为中间两数中右边一个数 \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n        res  +=   abs ( a [ i ]   -  a [ idx ] ) ;  \n     } \n     printf ( "%d\\n" ,  res ) ; \n     return   0 ; \n } \n 5.推公式 \n ACW25.耍杂技的牛 \ninclude   <iostream> \ninclude   <algorithm> \ninclude   <climits> \n using   namespace  std ; \n\n const   int  N  =   5e4   +   10 ; \n\n // 任意两个相邻的牛之间满足（左边在上面，右边牛在下面) Wi + Si < Wi+1 + Si+1能够将最大值降到最低 \n\n struct   Cow   { \n     int  w ,  s ; \n     bool   operator < ( const  Cow  & c )   { \n         return  w  +  s  <  c . w  +  c . s ; \n     } \n }  cow [ N ] ; \n int  n ; \n\n int   main ( )   { \n     scanf ( "%d" ,   & n ) ; \n     for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n         scanf ( "%d%d" ,   & cow [ i ] . w ,   & cow [ i ] . s ) ; \n     } \n\n     sort ( cow ,  cow  +  n ) ; \n\n     int  weight  =  cow [ 0 ] . w ,  maxDanger  =   0   -  cow [ 0 ] . s ; \n     for   ( int  i  =   1 ;  i  <  n ;   ++ i )   { \n        maxDanger  =   max ( maxDanger ,  weight  -  cow [ i ] . s ) ; \n        weight  +=  cow [ i ] . w ; \n     } \n     printf ( "%d\\n" ,  maxDanger ) ; \n     return   0 ; \n } \n \n '},{title:"LeetCode经典面试题",frontmatter:{},regularPath:"/algorithm/2_LeetCode.html",relativePath:"algorithm/2_LeetCode.md",key:"v-30d622f4",path:"/algorithm/2_LeetCode.html",headers:[{level:2,title:"解密消息",slug:"解密消息"},{level:2,title:"LRU缓存",slug:"lru缓存"},{level:2,title:"链表",slug:"链表"},{level:3,title:"LC203.移除链表元素",slug:"lc203-移除链表元素"},{level:3,title:"LC707.设计链表",slug:"lc707-设计链表"},{level:3,title:"LC206.反转链表",slug:"lc206-反转链表"},{level:3,title:"LC24.两两交换链表中的节点",slug:"lc24-两两交换链表中的节点"},{level:3,title:"LC19.删除链表的倒数第 N 个结点",slug:"lc19-删除链表的倒数第-n-个结点"},{level:3,title:"面试题 02.07. 链表相交",slug:"面试题-02-07-链表相交"},{level:3,title:"LC142.环形链表 II",slug:"lc142-环形链表-ii"},{level:3,title:"链表排序",slug:"链表排序"},{level:2,title:"哈希表",slug:"哈希表"},{level:3,title:"LC242.有效的字母异位词",slug:"lc242-有效的字母异位词"},{level:2,title:"最接近三数之和",slug:"最接近三数之和"},{level:2,title:"LC1620.网络最好的坐标",slug:"lc1620-网络最好的坐标"},{level:3,title:"LC1668.最大重复子字符串",slug:"lc1668-最大重复子字符串"},{level:2,title:"直接遍历",slug:"直接遍历"},{level:3,title:"LC1678.设计Goal解析器",slug:"lc1678-设计goal解析器"},{level:2,title:"栈",slug:"栈"},{level:3,title:"LC232.用栈实现队列",slug:"lc232-用栈实现队列"},{level:3,title:"LC225.用队列实现栈",slug:"lc225-用队列实现栈"},{level:3,title:"LC1047.删除字符串中的所有相邻重复字符",slug:"lc1047-删除字符串中的所有相邻重复字符"},{level:3,title:"LC1106.解析布尔表达式(HARD)",slug:"lc1106-解析布尔表达式-hard"},{level:2,title:"递归和分治",slug:"递归和分治"},{level:3,title:"汉诺塔问题",slug:"汉诺塔问题"},{level:2,title:"数学",slug:"数学"},{level:3,title:"LC754.到达终点数字",slug:"lc754-到达终点数字"},{level:2,title:"动态规划（DP）",slug:"动态规划-dp"},{level:3,title:"LC509.斐波那契数",slug:"lc509-斐波那契数"},{level:3,title:"LC70.爬楼梯",slug:"lc70-爬楼梯"},{level:3,title:"LC746.使用最小花费爬楼梯",slug:"lc746-使用最小花费爬楼梯"},{level:3,title:"LC343.整数拆分",slug:"lc343-整数拆分"},{level:4,title:"动态规划解法",slug:"动态规划解法"},{level:4,title:"数学方法",slug:"数学方法"},{level:3,title:"LC96.不同二叉搜索树",slug:"lc96-不同二叉搜索树"},{level:3,title:"背包专题",slug:"背包专题"},{level:3,title:"0-1背包",slug:"_0-1背包"},{level:3,title:"LC764.最大加号",slug:"lc764-最大加号"}],content:" LeetCode经典面试题 \n 解密消息 \n 用unordered_map即可 \n class   Solution   { \n public : \n    string  decodeMessage ( string key ,  string message )   { \n        unordered_map < char ,   char >  replace ; \n         for   ( auto  c  :  key )   { \n             if   ( replace . size ( )   ==   26 )   break ; \n             if   ( c  ==   ' '   ||   ( replace . count ( c )   ==   1 ) )   continue ; \n            replace [ c ]   =   'a'   +  replace . size ( ) ; \n         } \n        string tmp  =   \"\" ; \n         for   ( auto  c  :  message )   { \n             if   ( c  ==   ' ' )   { \n                tmp . push_back ( ' ' ) ; \n             }   else   { \n                tmp . push_back ( replace [ c ] ) ; \n             } \n         } \n         return  tmp ; \n     } \n } ; \n LRU缓存 \n 实现最近最久未使用法 \n 做法 \n \n \n 使用一个双向链表存储每个节点，每个节点存储两个值： \n \n 用于 索引 的每个页面的 关键字（key） \n 每个页面的 内容（值） ： val \n \n \n \n 使用 哈希表（ unordered_map ）存储每个页面对应节点的地址，映射为 <key, &DListNode> \n \n \n 向双向链表插入一个页面： \n \n 先通过哈希值判断页面在哈希表中是否已经存在 \n 存在则将页面对应节点移动到链表首部 \n 不存在则检查链表是否已满 \n 满则删除队尾元素再向队头添加页面，未满则直接添加，然后size++ \n \n \n \n 获取一个页面： \n \n 获取一个页面就说明这个页面使用过了，所以就要将该页面（节点）移动到链表头 \n 移动操作就是先删除再头插 \n 若不存在则返回-1 \n \n \n \n struct   DNode   { \n     int  key ,  value ; \n    DNode  * prev ,   * next ; \n     DNode ( )   :   key ( 0 ) ,   value ( 0 ) ,   prev ( nullptr ) ,   next ( nullptr )   { } \n     DNode ( int  _key ,   int  _value )   :   key ( _key ) ,   value ( _value ) ,   prev ( nullptr ) ,   next ( nullptr )   { } \n } ; \n\n class   LRUCache   { \n public : \n     int  m_capacity ; \n    DNode  * head ,   * tail ; \n    unordered_map < int ,  DNode  * >  hashMap ; \n     LRUCache ( int  capacity )   :   m_capacity ( capacity ) ,   head ( new   DNode ( ) ) ,   tail ( new   DNode ( ) )   { \n        head -> next  =  tail ; \n        tail -> prev  =  head ; \n     } \n    \n     int   get ( int  key )   { \n         if   ( hashMap . count ( key ) )   { \n            DNode  * use  =  hashMap\n                 [ key\n                                 ] ; \n\n             // 将其转移至队头 \n            use -> next -> prev  =  use -> prev ; \n            use -> prev -> next  =  use -> next ; \n            head -> next -> prev  =  use ; \n            use -> next  =  head -> next ; \n            head -> next  =  use ; \n            use -> prev  =  head ; \n             return  use -> value ; \n         } \n         return   - 1 ; \n     } \n    \n     void   put ( int  key ,   int  value )   { \n         if   ( hashMap . count ( key ) )   { \n             // 从队中删除节点转移到队头 \n            DNode  * tmp  =  hashMap [ key ] ; \n            tmp -> next -> prev  =  tmp -> prev ; \n            tmp -> prev -> next  =  tmp -> next ; \n             // 转移到队头 \n            head -> next -> prev  =  tmp ; \n            tmp -> next  =  head -> next ; \n            head -> next  =  tmp ; \n            tmp -> prev  =  head ; \n            tmp -> value  =  value ;   // 修改value \n             return   ; \n         } \n         // 如果不存在则要向队列插入 \n         if   ( hashMap . size ( )   ==  m_capacity )   {   // 队满的情况，要先删除一个节点 \n             // 队列满，将队尾的节点移除 \n            DNode  * pop  =  tail -> prev ; \n            pop -> prev -> next  =  tail ; \n            tail -> prev  =  pop -> prev ; \n            hashMap . erase ( pop -> key ) ; \n             delete  pop ; \n         } \n         // 向头部插入新节点 \n        DNode  * push  =   new   DNode ( key ,  value ) ; \n        head -> next -> prev  =  push ; \n        push -> next  =  head -> next ; \n        head -> next  =  push ; \n        push -> prev  =  head ; \n         // 向哈希表插入新节点 \n        hashMap [ key ]   =  push ; \n     } \n } ; \n\n /**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */ \n 链表 \n LC203.移除链表元素 \n 复建第一题 == \n \n 此时我想到一种绝妙的教学初学者链表的方法 \n \n /**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */ \n class   Solution   { \n public : \n    ListNode *   removeElements ( ListNode *  head ,   int  val )   { \n         // 处理头节点 \n         while   ( head  &&   ( head -> val  ==  val ) )  head  =  head -> next ; \n\n         // 处理头节点之后的节点 \n        ListNode *  pCur  =  head ; \n         while   ( pCur )   { \n             // 这里使用循环处理有数据连续相同的情况 \n             while   ( pCur -> next  &&  pCur -> next -> val  ==  val )   { \n                ListNode *  tmp  =  pCur -> next ; \n                pCur -> next  =  pCur -> next -> next ; \n                 delete  tmp ; \n             } \n            pCur  =  pCur -> next ; \n         } \n         return  head ; \n     } \n } ; \n LC707.设计链表 \n 不要把  ==  写成  = !!! \n 好久不敲代码，没想到因为这个DEBUG了一晚上，我是xx \n // #define _DEBUG \n\n struct   LinkNode   { \n     int  val  =   - 1 ; \n    LinkNode  * prev  =   nullptr ,   * next  =   nullptr ; \n     LinkNode ( )   =   default ; \n     LinkNode ( int  _val ,  LinkNode  * _prev  =   nullptr ,  LinkNode  * _next  =   nullptr )   :   val ( _val ) ,   prev ( _prev ) ,   next ( _next )   { } \n } ; \n\n class   MyLinkedList   { \n public : \n     MyLinkedList ( )   { \n        dummyHead  =   new   LinkNode ( ) ; \n        dummyTail  =   new   LinkNode ( ) ; \n        dummyHead -> next  =  dummyTail ; \n        dummyTail -> prev  =  dummyHead ; \n     } \n    \n     int   get ( int  index )   { \n         if   ( index  <   0   ||  index  >=  size )   return   - 1 ; \n        LinkNode  * pCur  =  dummyHead -> next ; \n         while   ( index -- )   { \n            pCur  =  pCur -> next ; \n         } \n         return  pCur -> val ; \nifdef   _DEBUG \n         print ( ) ; \nendif \n     } \n    \n     void   addAtHead ( int  val )   { \n        LinkNode  * p  =   new   LinkNode ( val ) ; \n         // 先在链外以p为节点接一根线 \n        p -> prev  =  dummyHead ; \n        p -> next  =  dummyHead -> next ; \n         // 再把链内原来的线重新接到p上 \n        dummyHead -> next -> prev  =  p ; \n        dummyHead -> next  =  p ; \n         ++ size ; \nifdef   _DEBUG \n         print ( ) ; \nendif \n     } \n    \n     void   addAtTail ( int  val )   { \n        LinkNode  * p  =   new   LinkNode ( val ) ; \n        p -> next  =  dummyTail ; \n        p -> prev  =  dummyTail -> prev ; \n        dummyTail -> prev -> next  =  p ; \n        dummyTail -> prev  =  p ; \n         ++ size ; \nifdef   _DEBUG \n         print ( ) ; \nendif \n     } \n    \n     void   addAtIndex ( int  index ,   int  val )   { \n         if   ( index  >  size )   return   ; \n         else   if   ( index  <   0 )   addAtHead ( val ) ; \n         else   if   ( index  ==  size )   addAtTail ( val ) ; \n         else   { \n            LinkNode  * pCur  =  dummyHead -> next ; \n             while   ( index -- )   {   // 0的时候不进入循环，因为pCur初始值为第0个节点 \n                pCur  =  pCur -> next ; \n             } \n             // 前插 \n            LinkNode  * p  =   new   LinkNode ( val ) ; \n            p -> prev  =  pCur -> prev ; \n            p -> next  =  pCur ; \n            pCur -> prev -> next  =  p ; \n            pCur -> prev  =  p ; \n             ++ size ; \n         } \nifdef   _DEBUG \n         print ( ) ; \nendif \n     } \n    \n     void   deleteAtIndex ( int  index )   { \n         if   ( index  >=   0   &&  index  <  size )   { \n            LinkNode  * pCur  =  dummyHead -> next ; \n             while   ( index -- )   {   // 0的时候不进入循环，因为pCur初始值为第0个节点 \n                pCur  =  pCur -> next ; \n             } \n            pCur -> prev -> next  =  pCur -> next ; \n            pCur -> next -> prev  =  pCur -> prev ; \n             delete  pCur ; \n             -- size ; \n         } \nifdef   _DEBUG \n         print ( ) ; \nendif \n\n     } \n\n     void   print ( )   { \n         if   ( size  ==   0 )   return   ; \n        LinkNode  * p  =  dummyHead -> next ; \n         while   ( p  !=  dummyTail )   { \n            cout  <<  p -> val  <<   ' ' ; \n            p  =  p -> next ; \n         } \n        cout  <<   \"size = \"   <<  size ; \n        cout  <<  endl ; \n     } \n\n private : \n    LinkNode  * dummyHead ,   * dummyTail ; \n     int  size  =   0 ; \n } ; \n\n /**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList* obj = new MyLinkedList();\n * int param_1 = obj->get(index);\n * obj->addAtHead(val);\n * obj->addAtTail(val);\n * obj->addAtIndex(index,val);\n * obj->deleteAtIndex(index);\n */ \n LC206.反转链表 \n /**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */ \n\n // 双指针版本 \n class   Solution   { \n public : \n    ListNode *   reverseList ( ListNode *  head )   { \n        ListNode *  dummyHead  =   new   ListNode ( - 1 ) ; \n        ListNode *  p1  =  head ,   *  tmp ; \n         while   ( p1 )   { \n             // 记录下p1的下一个节点 \n            tmp  =  p1 -> next ; \n\n             // 头插 \n            \n            p1 -> next  =  dummyHead -> next ; \n            dummyHead -> next  =  p1 ; \n\n             // 下标加一 \n            p1  =  tmp ; \n         } \n         return  dummyHead -> next ; \n     } \n } ; \n\n // 递归版本 \n class   Solution   { \n public : \n    \n    ListNode *   reverseNode ( ListNode *  pre ,  ListNode *  rear )   { \n         if   ( rear  ==   nullptr )   return  pre ; \n\n        ListNode  * tmp  =  rear -> next ;   // 先记录下rear的下一个节点 \n        rear -> next  =  pre ;   // 确定链接关系 \n\n         return   reverseNode ( rear ,  tmp ) ; \n     } \n\n    ListNode *   reverseList ( ListNode *  head )   { \n         return   reverseNode ( nullptr ,  head ) ;   // 避免了判断pre为空，也可以理解为尾部的nullptr也是一个节点 \n     } \n } ; \n LC24.两两交换链表中的节点 \n /**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */ \n // 递归1 \n class   Solution   { \n public : \n    ListNode *   swapNodes ( ListNode *  pre ,  ListNode *  rear )   { \n         if   ( ! pre  ||   ! rear )   return  pre ;   // pre为空或者rear为空均返回pre \n        ListNode *  tmp  =  rear -> next ; \n        rear -> next  =  pre ; \n        pre -> next  =   swapNodes ( tmp ,  tmp  ?  tmp -> next  :   nullptr ) ; \n         return  rear ; \n     } \n\n    ListNode *   swapPairs ( ListNode *  head )   { \n         return   swapNodes ( head ,  head  ?  head -> next  :   nullptr ) ; \n     } \n } ; \n\n // 递归2 \n class   Solution   { \n public : \n    ListNode *   swapPairs ( ListNode *  head )   { \n         if   ( ! head  ||   ! head -> next )   return  head ; \n        ListNode *  rear  =  head -> next -> next ,   * tmp  =  head -> next ; \n        head -> next -> next  =  head ; \n        head -> next  =   swapPairs ( rear ) ; \n         return  tmp ; \n     } \n } ; \n\n // 迭代版本需要用三个指针+虚拟头节点 \n class   Solution   { \n public : \n    ListNode *   swapPairs ( ListNode *  head )   { \n        ListNode *  dummyHead  =   new   ListNode ( 0 ) ;   // 设置一个虚拟头结点 \n        dummyHead -> next  =  head ;   // 将虚拟头结点指向head，这样方面后面做删除操作 \n        ListNode *  cur  =  dummyHead ; \n         while ( cur -> next  !=   nullptr   &&  cur -> next -> next  !=   nullptr )   { \n            ListNode *  tmp  =  cur -> next ;   // 记录临时节点 \n            ListNode *  tmp1  =  cur -> next -> next -> next ;   // 记录临时节点 \n\n            cur -> next  =  cur -> next -> next ;      // 步骤一 \n            cur -> next -> next  =  tmp ;            // 步骤二 \n            cur -> next -> next -> next  =  tmp1 ;     // 步骤三 \n\n            cur  =  cur -> next -> next ;   // cur移动两位，准备下一轮交换 \n         } \n         return  dummyHead -> next ; \n     } \n } ; \n LC19.删除链表的倒数第 N 个结点 \n /**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */ \n\n // 普通遍历方式，需要遍历一次得到长度 \n class   Solution   { \n public : \n    ListNode *   removeNthFromEnd ( ListNode *  head ,   int  n )   { \n         int  size  =   0 ; \n        ListNode *  p  =  head ; \n         while   ( p )   { \n             ++ size ; \n            p  =  p -> next ; \n         } \n        n  =  size  -   ( n  -   1 ) ; \n         if   ( n  ==   1 )  head  =  head -> next ; \n         else   { \n            p  =  head ; \n            n -- ;   // 已删除第n个节点时，p应该指向它的前一个节点，也可以用虚拟头节点来解决 \n             while   ( -- n )   { \n                p  =  p -> next ; \n             } \n            ListNode *  tmp  =  p -> next ; \n            p -> next  =  p -> next -> next ; \n             delete  tmp ; \n         } \n         return  head ; \n     } \n } ; \n\n // 双指针可以一个指针先走n步，然后第二个指针同步走 \n // 一循环双指针版本 \n // 先让fast移动n步，再让slow和fast同时移动n步 \n class   Solution   { \n public : \n    ListNode *   removeNthFromEnd ( ListNode *  head ,   int  n )   { \n         // 先定义虚拟节点 \n        ListNode *  dummyHead  =   new   ListNode ( - 1 ,  head ) ; \n        ListNode *  fast  =  dummyHead ,   *  slow  =  dummyHead ; \n         // 要删除的是倒数第n个节点，slow节点需要在倒数第n - 1个节点删除，所以先让fast走n步，再让slow与fast同步走 \n         while   ( n -- )   {  \n            fast  =  fast -> next ; \n         } \n         while   ( fast -> next )   { \n            fast  =  fast -> next ; \n            slow  =  slow -> next ; \n         } \n        ListNode *  tmp  =  slow -> next ; \n        slow -> next  =  slow -> next -> next ; \n         delete  tmp ; \n         return  dummyHead -> next ; \n     } \n } ; \n 面试题 02.07. 链表相交 \n /**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */ \n\n  // 最自然的想法是哈希表 \n class   Solution   { \n public : \n    ListNode  * getIntersectionNode ( ListNode  * headA ,  ListNode  * headB )   { \n        unordered_set < ListNode  * >  nodesSet ; \n         while   ( headA )   { \n            nodesSet . insert ( headA ) ; \n            headA  =  headA -> next ; \n         } \n         while   ( headB )   { \n             if   ( nodesSet . count ( headB ) )   break ; \n            headB  =  headB -> next ; \n         } \n         return  headB ; \n     } \n } ; \n\n // 双指针 \n class   Solution   { \n public : \n    ListNode  * getIntersectionNode ( ListNode  * headA ,  ListNode  * headB )   { \n        ListNode  * p1  =  headA ,   * p2  =  headB ; \n\n         // 让p1先遍历A链表，再遍历B链表 \n         // p2先遍历B链表，再遍历A链表 \n         // 如果相交它们一定会在第一个交点处汇合 \n         // 如果不相交它们一定会同时分别遍历完AB两个链表并在nullptr相遇 \n         while   ( p1  !=  p2 )   { \n            p1  =  p1  !=   nullptr   ?  p1 -> next  :  headB ; \n            p2  =  p2  !=   nullptr   ?  p2 -> next  :  headA ; \n         } \n\n         return  p1 ; \n     } \n } ; \n LC142.环形链表 II \n   // 依然可以哈希表 \n class   Solution   { \n public : \n    ListNode  * detectCycle ( ListNode  * head )   { \n        unordered_set < ListNode  * >  nodesSet ; \n         while   ( head )   { \n             if   ( nodesSet . count ( head ) )   break ; \n            nodesSet . insert ( head ) ; \n            head  =  head -> next ; \n         } \n         return  head ; \n     } \n } ; \n\n // FLoyd判圈法也可以 \n  // 比哈希表更快的方法是快慢指针 \n // 先用快慢指针判圈完成fast与slow的第一次相遇 \n // 然后将fast置为起点与slow同步每次移动一个，然后它们就可以在圈的入口相遇了 \n class   Solution   { \n public : \n    ListNode  * detectCycle ( ListNode  * head )   { \n         if   ( head  ==   nullptr )   return   nullptr ; \n        ListNode  * fast  =  head ,   * slow  =  head ; \n         // 判断是否有环 \n         while   ( true )   { \n             if   ( fast -> next  ==   nullptr   ||  fast -> next -> next  ==   nullptr )   { \n                 return   nullptr ; \n             } \n            fast  =  fast -> next -> next ; \n            slow  =  slow -> next ; \n             if   ( fast  ==  slow )   break ; \n         } \n\n         // 重新构造第二次相遇 \n         // 第一次相遇时：(a为直路节点数，b为圈上节点数) \n         // f = 2s, f = s + nb \n         // 得出 f = 2nb, s = nb \n         // 又对于slow指针一次走一步，每次走到圆圈入口时走过路程：k = a + nb \n         // 因为 s = nb(slow已经走了nb步)，只需要s再走a步即可使其到达入口 \n         // fast此时回到起点和slow同时走每次只走一步，再次碰到s时必然正好走了a步且正好在圈的入口 \n        fast  =  head ; \n         while   ( fast  !=  slow )   { \n            fast  =  fast -> next ; \n            slow  =  slow -> next ; \n         } \n         return  fast ; \n     } \n } ; \n 链表排序 \n 具体做法 \n 1.先寻找链表的中点，寻找中点可使用快慢指针（复杂度为O(n)) \n 2.将链表按照中点向下分成两个链表，最后递归将每个链表长度分为1 \n 3.回溯时，将两个有序链表两两合并 \n 代码 \n /**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */ \n\n  // 做法： \n  // 1.先寻找链表的中点，寻找中点可使用快慢指针（复杂度为O(n)) \n  // 2.将链表按照中点向下分成两个链表，最后递归将每个链表长度分为1 \n  // 3.回溯时，将两个有序链表两两合并 \n\n class   Solution   { \n public : \n    ListNode *   sortList ( ListNode *  head )   { \n         return   mergeSort ( head ,   nullptr ) ; \n     } \n\n    ListNode *   mergeSort ( ListNode *  head ,  ListNode *  tail )   { \n         if   ( head  ==   nullptr )   return  head ; \n         if   ( head -> next  ==  tail )   { \n            head -> next  =   nullptr ;   // 区间内仅有两个节点，则将当前head的尾节点置为nullptr以显示该连表为一个新链表 \n             return  head ; \n         } \n        ListNode *  slow  =  head ,   *  fast  =  head ; \n         while   ( fast  !=  tail )   { \n            slow  =  slow -> next ; \n            fast  =  fast -> next ; \n             if   ( fast  !=  tail )   { \n                fast  =  fast -> next ; \n             } \n         } \n        ListNode *  mid  =  slow ; \n         // 由于tail节点为不算在区间内，所以此处左区间为[head, mid), 右区间元素为[mid, tail) \n         return   merge ( mergeSort ( head ,  mid ) ,   mergeSort ( mid ,  tail ) ) ; \n     } \n     // 合并两个有序链表 \n    ListNode *   merge ( ListNode *  head1 ,  ListNode *  head2 )   { \n        ListNode *  dummyHead  =   new   ListNode ( ) ; \n        ListNode *  cur  =  dummyHead ; \n         while   ( head1  &&  head2 )   { \n             if   ( head1 -> val  <=  head2 -> val )   { \n                cur -> next  =  head1 ,  cur  =  cur -> next ,  head1  =  head1 -> next ; \n             }   else   { \n                cur -> next  =  head2 ,  cur  =  cur -> next ,  head2  =  head2 -> next ; \n             } \n         } \n         while   ( head1 )   { \n            cur -> next  =  head1 ,  head1  =  head1 -> next ,  cur  =  cur -> next ; \n         } \n         while   ( head2 )   { \n            cur -> next  =  head2 ,  head2  =  head2 -> next ,  cur  =  cur -> next ; \n         } \n         return  dummyHead -> next ; \n     } \n    \n } ; \n 哈希表 \n 见代码随想录： 哈希表 \n 关键点： \n \n 哈希函数，例如单纯地取模 \n 哈希碰撞，如果是取模的话会遇到不同值映射到同一个哈希值 \n 解决哈希碰撞\n \n 开放寻址法（线性探测法），使哈希表空间大于数据数量 \n 拉链法，较为常用 \n \n \n 常见的三种哈希结构\n \n 数组 \n set(集合)： std::set, std::multiset, std::unordered_set \n map(映射)： std::map, std::multimap, std::unordered_map \n LC242.有效的字母异位词 \n class   Solution   { \n public : \n     bool   isAnagram ( string s ,  string t )   { \n         if   ( s . size ( )   !=  t . size ( ) )   return   false ; \n         int  check1 [ 'z'   +   1 ]   =   { 0 } ; \n         int  check2 [ 'z'   +   2 ]   =   { 0 } ; \n         for   ( auto  c  :  s )   ++ check1 [ c ] ; \n         for   ( auto  c  :  t )   ++ check2 [ c ] ; \n         for   ( auto  c  :  t )   if   ( check1 [ c ]   !=  check2 [ c ] )   return   false ; \n         return   true ; \n     } \n } ; \n 最接近三数之和 \n 原题：LC16 \n 本题为贪心思想，根据绝对值来选取最佳值 \n 排序 + 双指针， 复杂度为O(n^2) \n class   Solution   { \n public : \n     int   threeSumClosest ( vector < int > &  nums ,   int  target )   { \n         sort ( nums . begin ( ) ,  nums . end ( ) ) ; \n         int  n  =  nums . size ( ) ; \n         int  best  =   1e7 ; \n\n         // 根据差值的绝对值来更新best值 \n         // 匿名函数（lambda表达式） \n         auto  update  =   [ & ] ( int  cur )   { \n             if   ( abs ( cur  -  target )   <   abs ( best  -  target ) )   { \n                best  =  cur ; \n             } \n         } ; \n         // a <= b <= c \n         // 枚举a \n         for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n             // 保证和上一次枚举的元素不相等 \n             if   ( i  >   0   &&  nums [ i ]   ==  nums [ i  -   1 ] )   continue ; \n\n             // 双指针枚举 b 和 c \n             int  j  =  i  +   1 ,  k  =  n  -   1 ; \n             while   ( j  <  k )   { \n                 int  sum  =  nums [ i ]   +  nums [ j ]   +  nums [ k ] ; \n                 // 如果等于target，直接返回答案 \n                 if   ( sum  ==  target )   return  target ; \n                 update ( sum ) ;   // 更新best值 \n                 if   ( sum  >  target )   { \n                     // sum 过大，则将c左移（减小），将c对应的指针移动到下一个不相等元素 \n                     int  k0  =  k  -   1 ; \n                     while   ( j  <  k0  &&  nums [ k0 ]   ==  nums [ k ] )  k0 -- ; \n                    k  =  k0 ; \n                 }   else   { \n                     // sum 过小，则将b右移（增大） \n                     int  j0  =  j  +   1 ; \n                     while   ( j0  <  k  &&  nums [ j0 ]   ==  nums [ j ] )  j0 ++ ; \n                    j  =  j0 ; \n                 } \n             } \n         } \n         return  best ; \n     } \n } ; \n LC1620.网络最好的坐标 \n \n [ ] 待办：2022.11.3补题 \n \n class   Solution   { \n public : \n    vector < int >   bestCoordinate ( vector < vector < int >> &  towers ,   int  radius )   { \n         int  xMax  =  INT_MIN ,  yMax  =  INT_MIN ; \n         for   ( auto   && tower  :  towers )   { \n             int  x  =  tower [ 0 ] ,  y  =  tower [ 1 ] ; \n            xMax  =   max ( xMax ,  x ) ; \n            yMax  =   max ( yMax ,  y ) ; \n         } \n         int  cx  =   0 ,  cy  =   0 ; \n         int  maxQuality  =   0 ; \n         for   ( int  x  =   0 ;  x  <=  xMax ;  x ++ )   { \n             for   ( int  y  =   0 ;  y  <=  yMax ;  y ++ )   { \n                vector < int >  coordinate  =   { x ,  y } ; \n                 int  quality  =   0 ; \n                 for   ( auto   && tower  :  towers )   { \n                     int  squaredDistance  =   getSquaredDistance ( coordinate ,  tower ) ; \n                     if   ( squaredDistance  <=  radius  *  radius )   { \n                         double  distance  =   sqrt ( ( double ) squaredDistance ) ; \n                        quality  +=   floor ( ( double ) tower [ 2 ]   /   ( 1   +  distance ) ) ; \n                     } \n                 } \n                 if   ( quality  >  maxQuality )   { \n                    cx  =  x ; \n                    cy  =  y ; \n                    maxQuality  =  quality ; \n                 } \n             } \n         } \n         return   { cx ,  cy } ; \n     } \n\n     int   getSquaredDistance ( const  vector < int >   & coordinate ,   const  vector < int >   & tower )   { \n         return   ( tower [ 0 ]   -  coordinate [ 0 ] )   *   ( tower [ 0 ]   -  coordinate [ 0 ] )   +   ( tower [ 1 ]   -  coordinate [ 1 ] )   *   ( tower [ 1 ]   -  coordinate [ 1 ] ) ; \n     } \n } ; \n LC1668.最大重复子字符串 \n \n [ ] 待办：2022.11.4 补题 \n \n class   Solution   { \n public : \n     int   maxRepeating ( string sequence ,  string word )   { \n         int  n  =  sequence . size ( ) ,  m  =  word . size ( ) ; \n         if   ( n  <  m )   { \n             return   0 ; \n         } \n        vector < int >   f ( n ) ; \n         for   ( int  i  =  m  -   1 ;  i  <  n ;   ++ i )   { \n             bool  valid  =   true ; \n             for   ( int  j  =   0 ;  j  <  m ;   ++ j )   { \n                 if   ( sequence [ i  -  m  +  j  +   1 ]   !=  word [ j ] )   { \n                    valid  =   false ; \n                     break ; \n                 } \n             } \n             if   ( valid )   { \n                f [ i ]   =   ( i  ==  m  -   1   ?   0   :  f [ i  -  m ] )   +   1 ; \n             } \n         } \n         return   * max_element ( f . begin ( ) ,  f . end ( ) ) ; \n     } \n } ; \n 直接遍历 \n LC1678.设计Goal解析器 \n 题目： \n 请你设计一个可以解释字符串  command  的  Goal 解析器  。 command  由  \"G\" 、 \"()\"  和/或  \"(al)\"  按某种顺序组成。Goal 解析器会将  \"G\"  解释为字符串  \"G\" 、 \"()\"  解释为字符串  \"o\"  ， \"(al)\"  解释为字符串  \"al\"  。然后，按原顺序将经解释得到的字符串连接成一个字符串。 \n 给你字符串  command  ，返回  Goal 解析器  对  command  的解释结果。 \n \n 代码 \n class   Solution   { \n public : \n    string  interpret ( string command )   { \n        string res  =   \"\" ; \n         int  len  =  command . size ( ) ; \n         for   ( int  i  =   0 ;  i  <  len ;   ++ i )   { \n             if   ( command [ i ]   ==   'G' )   { \n                res  +=   \"G\" ; \n                 continue ; \n             }   else   if   ( command [ i ]   ==   '(' )   { \n                 if   ( command [ ++ i ]   ==   ')' )   { \n                    res  +=   \"o\" ; \n                 }   else   { \n                    i  +=   2 ;   // 减少循环次数 \n                    res  +=   \"al\" ; \n                 } \n             } \n         } \n         return  res ; \n     } \n } ; \n 栈 \n LC232.用栈实现队列 \n 此题注意，由于  pop()  和  peek()  操作都只需要队列头元素，所以当outStk不为空时，其top()元素就是最后结果，只需要在  outStk  为空时进行  InToOut  的转化即可，不需要复原来保证队列元素的顺序， InStk  在  push  时只需要  push  即可。 \n class   MyQueue   { \n    stack < int >  stIn ,  stOut ; \n public : \n     MyQueue ( )   :   stIn ( stack < int > ( ) ) ,   stOut ( stack < int > ( ) )   { \n\n     } \n    \n     inline   void   InToOut ( )   { \n         while   ( stIn . size ( )   !=   0 )   { \n            stOut . push ( stIn . top ( ) ) ; \n            stIn . pop ( ) ; \n         } \n     } \n\n     inline   void   OutToIn ( )   { \n         while ( stOut . size ( )   !=   0 )   { \n            stIn . push ( stOut . top ( ) ) ; \n            stOut . pop ( ) ; \n         } \n     } \n\n     void   push ( int  x )   { \n        stIn . push ( x ) ; \n     } \n    \n     int   pop ( )   { \n         if   ( stOut . empty ( ) )   InToOut ( ) ;   // 元素转移至出栈 \n         int  tmp  =  stOut . top ( ) ; \n        stOut . pop ( ) ; \n         // OutToIn(); // 复原，由于每次push的元素必定在后面，所以不必复原 \n         return  tmp ; \n     } \n    \n     int   peek ( )   { \n         if   ( stOut . empty ( ) )   InToOut ( ) ; \n         int  tmp  =  stOut . top ( ) ; \n         // OutToIn(); \n         return  tmp ; \n     } \n    \n     bool   empty ( )   { \n         return  stIn . empty ( )   &&  stOut . empty ( ) ; \n     } \n } ; \n\n /**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */ \n LC225.用队列实现栈 \n 使用队列实现栈的下列操作： \n \n push(x) -- 元素 x 入栈 \n pop() -- 移除栈顶元素 \n top() -- 获取栈顶元素 \n empty() -- 返回栈是否为空 \n \n 注意: \n \n 你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。 \n 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 \n 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作） \n \n 思路 \n 用两个队列来实现 \n 保证 que1中只有入队的最后一个元素（也就是栈顶元素），每次pop只需要从que1中取出该元素 \n que2就用来存储入栈元素中除了栈顶元素的最后一个元素 \n 代码 \n class   MyStack   { \n    queue < int >  que1 ;   // 在que1中只保留最后一个元素 \n    queue < int >  que2 ; \n public : \n     MyStack ( )   { \n\n     } \n\n     void   update ( )   {   // 保证que1中只有最后一个入队的元素 \n         if   ( que1 . empty ( ) )   { \n             if   ( que2 . empty ( ) )   return   ; \n             while   ( ! que2 . empty ( ) )   { \n                que1 . push ( que2 . front ( ) ) ; \n                que2 . pop ( ) ; \n             } \n             while   ( que1 . size ( )   !=   1 )   { \n                que2 . push ( que1 . front ( ) ) ; \n                que1 . pop ( ) ; \n             } \n         } \n     } \n    \n     void   push ( int  x )   { \n        que1 . push ( x ) ; \n         if   ( que1 . size ( )   !=   1 )   { \n            que2 . push ( que1 . front ( ) ) ; \n            que1 . pop ( ) ; \n         } \n     } \n    \n     int   pop ( )   { \n         update ( ) ; \n         int  tmp  =  que1 . front ( ) ; \n        que1 . pop ( ) ; \n         return  tmp ; \n     } \n    \n     int   top ( )   { \n         update ( ) ; \n         return  que1 . front ( ) ; \n     } \n    \n     bool   empty ( )   { \n         return  que1 . empty ( )   &&  que2 . empty ( ) ; \n     } \n } ; \n\n /**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * bool param_4 = obj->empty();\n */ \n LC1047.删除字符串中的所有相邻重复字符 \n 思路 \n 使用栈即可，std::string 亦可以使用  push_back()  、 pop_back() 、 back() \n class   Solution   { \n public : \n    string  removeDuplicates ( string s )   { \n        string res ;   // string 类型也可以使用 back() 、empty() 、pop_back()、push_back() \n         for   ( char  c  :  s )   { \n             if   ( res . empty ( )   ||  res . back ( )   !=  c )   { \n                res . push_back ( c ) ; \n             }   else   { \n                res . pop_back ( ) ; \n             } \n         } \n         return  res ; \n     } \n } ; \n LC1106.解析布尔表达式(HARD) \n 题目 \n 给你一个以字符串形式表述的  布尔表达式 （boolean）  expression ，返回该式的运算结果。 \n 有效的表达式需遵循以下约定： \n \n \"t\" ，运算结果为  True \n \"f\" ，运算结果为  False \n \"!(expr)\" ，运算过程为对内部表达式  expr  进行逻辑  非的运算 （NOT） \n \"&(expr1,expr2,...)\" ，运算过程为对 2 个或以上内部表达式  expr1, expr2, ...  进行逻辑  与的运算 （AND） \n \"|(expr1,expr2,...)\" ，运算过程为对 2 个或以上内部表达式  expr1, expr2, ...  进行逻辑  或的运算 （OR） \n \n 解法 \n 栈 \n \n class   Solution   { \n public : \n     // 栈 + 状态机 \n     bool   parseBoolExpr ( string expression )   { \n        stack < char >  stk ;  \n         for   ( auto  cur  :  expression )   { \n             if   ( cur  ==   ',' )   continue ; \n             if   ( cur  !=   ')' )   {   // 当其不为 ',' 或者 ')' 时，将其push入栈 \n                stk . push ( cur ) ; \n                 continue ; \n             }   else   { \n                 // 当其为右括号时，开始解析表达式 \n                 int  t  =   0 ,  f  =   0 ;   // 计算到左括号为止有多少t 和 f \n                 while   ( stk . top ( )   !=   '(' )   { \n                     char  tmp  =  stk . top ( ) ; \n                    stk . pop ( ) ; \n                     if   ( tmp  ==   't' )  t ++ ; \n                     else  f ++ ; \n                 } \n                stk . pop ( ) ; \n                 char  op  =  stk . top ( ) ; \n                 switch   ( op )   { \n                     case   '&' :   { \n                        stk . pop ( ) ; \n                        stk . push ( f  >   0   ?   'f'   :   't' ) ; \n                     }   break ; \n                     case   '|' :   { \n                        stk . pop ( ) ; \n                        stk . push ( t  >   0   ?   't'   :   'f' ) ; \n                     }   break ; \n                     case   '!' :   { \n                        stk . pop ( ) ; \n                        stk . push ( t  ==   0   ?   't'   :   'f' ) ; \n                     }   break ; \n                     default :   break ; \n                 } \n             } \n         } \n         return  stk . top ( )   ==   't'   ?   true   :   false ; \n     } \n } ; \n 递归和分治 \n 汉诺塔问题 \n 题目 \n 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:\n(1) 每次只能移动一个盘子;\n(2) 盘子只能从柱子顶端滑出移到下一根柱子;\n(3) 盘子只能叠在比它大的盘子上。 \n 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。 \n 你需要原地修改栈。 \n 思路 \n 柱子上盘子数n为1时，相当于直接将 A柱子上的盘放到C上即可 \n 当n > 1时，就需要借助B，先将A上面 n - 1个盘子放到B上，再将A上最后一个盘子放到C上，最后再将B上n - 1个盘子放到C上 \n class   Solution   { \n public : \n    \n     void   move ( int  n ,  vector < int >   & A ,  vector < int >   & B ,  vector < int >   & C )   { \n         if   ( n  ==   1 )   {   // 将A上的一个盘子从A移动到C上 \n            C . push_back ( A . back ( ) ) ; \n            A . pop_back ( ) ; \n             return   ; \n         } \n         move ( n  -   1 ,  A ,  C ,  B ) ;   // step1: 这是子问题，将A上前n-1个盘子移动到B上 \n        C . push_back ( A . back ( ) ) ;   // step2: 将A上剩下的一个盘子移动到C上 \n        A . pop_back ( ) ; \n         move ( n  -   1 ,  B ,  A ,  C ) ;   // step3: 自问题，将B上剩余的n-1个盘子移动到C上 \n     } \n    \n     void   hanota ( vector < int >   & A ,  vector < int >   & B ,  vector < int >   & C )   { \n         int  n  =  A . size ( ) ;   // n > 0 \n         move ( n ,  A ,  B ,  C ) ;   // move表示将 A 上 n个元素移动到C上 \n     } \n } ; \n 数学 \n LC754.到达终点数字 \n 题目 \n 在一根无限长的数轴上，你站在 0 的位置。终点在 target 的位置。 \n 你可以做一些数量的移动  numMoves  : \n \n 每次你可以选择向左或向右移动。 \n 第  i  次移动（从   i == 1  开始，到  i == numMoves  ），在选择的方向上走  i  步。 \n \n 给定整数  target  ，返回  到达目标所需的  最小  移动次数(即最小  numMoves  )  。 \n 思路 \n 首先，假设最少需要k步来到达这个终点，最后的结果就是 $s = \\sum_{i=1}^{k} i$ ，其中部分数加上负号即可，所以如果 target < 0, 那么就把这 k 个数符号全部取反就行，所以 根据对称性只需要考虑target > 0 的情况 。（s为前k个数的和） \n \n 当 s = target时，k 即为答案 \n 当 s > target时，记 delta = s - target，因为k为最少的让s大于等于target的值，所以，必定有，delta <= k\n \n 当 delta为偶数时，必定能找到 若干个数和为 delta / 2，且因为delta <= k，所以在1...k 中肯定有一个数等于 delta / 2，所以最后即为k步 \n 当 delta 为奇数时，如果 k + 1 为奇数，那么最后的 sum 中算上 k + 1之后的 delta为偶数，所以一定能找到若干个数之和为 delta / 2，此时答案为 k + 1 步；若 k + 1 为偶数数，那么 k + 2 肯定为奇数，所以就算上 k + 1 和 k + 2之后 delta为偶数，也有答案，所以此时答案为 k + 2步 \n   所以这一步的目的就是将delta变为偶数，那么就肯定有答案 \n \n \n \n \n 为何时 delta / 2？因为对于sum来说，一个数不是加就是减，将其（设为下）变成负数就相当于是sum - 2x (2x = delta, x = delta / 2). \n \n class   Solution   { \n public : \n     int   reachNumber ( int  target )   { \n         // 由于对称性，只考虑target > 0 \n         // 最终的目的是使最后的delta为偶数 \n        target  =   abs ( target ) ; \n         int  numMoves  =   0 ; \n         while   ( target  >   0 )   { \n            numMoves ++ ; \n            target  -=  numMoves ; \n         } \n         return  target  %   2   ==   0   ?  numMoves  :  numMoves  +   1   +  numMoves  %   2 ;   // delta为奇数时，若 numsMoves 为偶数，说明 numMoves + 1为奇数，否则需要选择 numMoves + 2 \n     } \n } ; \n 动态规划（DP） \n LC509.斐波那契数 \n class   Solution   { \n public : \n     int   fib ( int  n )   { \n         if   ( n  ==   0 )   return   0 ; \n         int  dp [ 2 ] ; \n        dp [ 0 ]   =   0 ,  dp [ 1 ]   =   1 ; \n         int  sum ; \n         for   ( int  i  =   2 ;  i  <=  n ;   ++ i )   { \n            sum  =  dp [ 0 ]   +  dp [ 1 ] ; \n            dp [ 0 ]   =  dp [ 1 ] ; \n            dp [ 1 ]   =  sum ; \n         } \n         return  dp [ 1 ] ; \n     } \n } ; \n LC70.爬楼梯 \n class   Solution   { \n public : \n     int   climbStairs ( int  n )   { \n         if   ( n  <   3 )   return  n ; \n         int  dp [ 2 ] ,  sum ; \n        dp [ 0 ]   =   1 ,  dp [ 1 ]   =   2 ; \n         for   ( int  i  =   3 ;  i  <=  n ;   ++ i )   { \n            sum  =  dp [ 0 ]   +  dp [ 1 ] ; \n            dp [ 0 ]   =  dp [ 1 ] ; \n            dp [ 1 ]   =  sum ; \n         } \n         return  dp [ 1 ] ; \n     } \n } ; \n LC746.使用最小花费爬楼梯 \n class   Solution   { \n public : \n     int   minCostClimbingStairs ( vector < int > &  cost )   { \n         int  sz  =  cost . size ( ) ; \n         int  dp [ 1000 ] ;   // dp[i] 表示 由下标为i的台阶往上爬的最少花费 \n        dp [ 0 ]   =  cost [ 0 ] ,  dp [ 1 ]   =  cost [ 1 ] ; \n         for   ( int  i  =   2 ;  i  <  sz ;   ++ i )  dp [ i ]   =   min ( dp [ i  -   1 ] ,  dp [ i  -   2 ] )   +  cost [ i ] ; \n         return   min ( dp [ sz  -   1 ] ,  dp [ sz  -   2 ] ) ; \n     } \n } ; \n LC343.整数拆分 \n 动态规划解法 \n 可以使用动态规划算法来解决该问题。我们定义一个数组 dp，其中 dp[i] 表示将数字 i 拆分成 k 个正整数的和，并且这些正整数的乘积最大值。 \n 首先，我们需要将数字 i 拆分成 j 和 i-j 两部分，其中 j 是从 1 到 i-1 中的任意一个整数。如果将数字 i 拆分成 j 和 i-j 两部分，则 dp[i] 的值应该是将数字 j 拆分成 k-1 个正整数的和，并使这些整数的乘积最大化，再乘上数字 i-j。因此，我们可以得到如下的状态转移方程： \n dp[i] = max(j * dp[i-j], j * (i-j)) \n 其中 j 取值从 1 到 i-1。 \n 最后，dp[n] 即为所求的结果。时间复杂度为 O(n^2)。 \n \n 此处递推方程分为拆成 2 个数 和 拆成 >=3 个数 \n \n class   Solution   { \n public : \n     // 动态规划的写法 \n     int   integerBreak ( int  n )   { \n         int  dp [ 59 ] ;   // dp[i] 表示整数i被分为k个数的最大乘积 \n         // 同时，i又可以分为 (i - j, j) , j belong to [1, i - 1] \n         // 所以 \n         // 拆成 2 个数 的情况：dp[i] = j * (i - j), 此处不拆i - j \n         // 拆成 >= 3 个数 的情况：dp[i] = j * dp[i - j] 此处拆i - j \n         // 所以递推公式为 dp[i] = max(j * (i - j), j * dp[i - j]) \n        dp [ 2 ]   =   1 ; \n         int  tmp_max  =   0 ; \n         for   ( int  i  =   3 ;  i  <=  n ;   ++ i )   { \n            tmp_max  =   0 ; \n             for   ( int  j  =   1 ;  j  <=  i  /   2 ;   ++ j )   { \n                tmp_max  =   max ( tmp_max ,   max ( j  *   ( i  -  j ) ,  j  *  dp [ i  -  j ] ) ) ; \n             } \n            dp [ i ]   =  tmp_max ; \n         } \n         return  dp [ n ] ; \n         // O(n^2) \n     } \n } ; \n 数学方法 \n 美版LeetCode用户StefanPochmann的发言（一句话理解数学方法）： \n You're making it pretty complicated.\n\nIf an optimal product contains a factor f >= 4, then you can replace it with factors 2 and f-2 without losing optimality, as 2*(f-2) = 2f-4 >= f. So you never need a factor greater than or equal to 4, meaning you only need factors 1, 2 and 3 (and 1 is of course wasteful and you'd only use it for n=2 and n=3, where it's needed).\n\nFor the rest I agree, 33 is simply better than 22*2, so you'd never use 2 more than twice.\n \n 国区力扣用户 哪有好坏啊 的发言： \n \n 这个解释的是为什么最优的拆分方案不会出现大于4的元素。 \n 因为大于等于4的元素f总可以拆分成2*(f-2) = 2f-4 = f + (f - 4) >= f。 \n 因此出现  大于等于4的拆分元素是不必要的 。 \n 剩下的一句话就是说，能拆3就拆3，因为3 3总是大于2 2*2的。 \n \n $$\n\\because , 2 \\times (f - 2) = 2f - 4 = f + (f - 4) \\\n\\therefore when , f > 4, \\space 2 \\times (f - 2) \\ge f\n$$ \n class   Solution   { \n public : \n     // 由数学知识可以得知，将数分成3x3会更大，如果前面分的是3最后剩1，那么这个3和1就改成2 x 2 \n     int   integerBreak ( int  n )   { \n         if   ( n  ==   2 )   return   1 ; \n         if   ( n  ==   3 )   return   2 ; \n         if   ( n  ==   4 )   return   4 ; \n         int  x  =  n  /   3 ;   // 3^x \n         int  m  =  n  %   3 ;   // 看余数的值 \n         if   ( m  ==   0 )   return   pow ( 3 ,  x ) ; \n         else   if   ( m  ==   1 )   return   pow ( 3 ,  x  -   1 )   *   4 ; \n         else   return   pow ( 3 ,  x )   *   2 ; \n     } \n } ; \n LC96.不同二叉搜索树 \n 注意二叉搜索树的定义。其由中序遍历（左根右）应该是由小到大递增的。 \n dp[0]=1 根据定义，空树也是一种二叉树； \n 其次，根据递推公式计算，dp[0]也需要是1，否则就会乘得0 \n class   Solution   { \n public : \n     // 二叉搜索树从小到大是：左根右 \n     // dp[n] 表示有n个节点的二叉搜索树的种数 \n     // [1..i - 1](left child tree) i [i + 1, ..., n] (right child tree) \n     // 以节点i为根的二叉搜索树种类为 dp[i - 1] * dp[n - i] (n >= 3) \n     // dp[n] = sum(dp[i - 1] * dp[n - i]), i = [1..n] dp[0] 定义为1，实际上对于边界的情况应该单独讨论，但是这里为了简化程序，直接将dp[0]定义为1 \n     //  \n     int   numTrees ( int  n )   { \n         int  dp [ 20 ]   =   { 0 } ; \n        dp [ 0 ]   =   1 ,  dp [ 1 ]   =   1 ,  dp [ 2 ]   =   2 ; \n         for   ( int  j  =   3 ;  j  <=  n ;   ++ j )   {   // j表示节点个数 \n             for   ( int  i  =   1 ;  i  <=  j ;   ++ i )   {   // i 表示根的编号 \n                dp [ j ]   +=  dp [ i  -   1 ]   *  dp [ j  -  i ] ; \n             } \n         } \n         return  dp [ n ] ; \n     } \n } ; \n 背包专题 \n 背包的类别（代码随想录）： \n 0-1背包 \n 问题： \n 有n个物品和一个最多能装w千克的包，第i个物品的质量和价值分别为 weight[i] 和 value[i]。**每个背包只能用一次，**求解将哪些物品放入背包里物品的价值总和最大。 \n **暴力解法：**每个物品有两个状态，取或者不取，所以每种情况都遍历一遍，判断是否 $\\sum_{i = 1}^{n}{weight[i]} <= w$，然后在满足条件的情况中 v 最大的那种即为结果。这种方法的复杂度为 $O(2^n)$ \n 动态规划： \n dp[i][j]  表示前i个物品，总容量是 j 千克的情况下，总价值最大是多少。 \n result = max{dp[n][0~v]} \n 1.不选第 i 个物品的情况： dp[i][j] = dp[i - 1][j] \n 2.选第 i 个物品的情况：  dp[i][j] = dp[i - 1][j - weight[i]] + value[i]   （前i - 1个物品中，value \n dp[i][j] = max{1, 2}  (当j < weight[i]时，不能选) \n 初始状态： dp[0][0] = 0   此时复杂度为： T: O(n*w) S:O(n*w) \n 下面是对AcWing上面01背包的解决思路（此处的质量w更换为了体积v）： \ninclude   <iostream> \ninclude   <vector> \ninclude   <algorithm> \n using   namespace  std ; \n\n const   int  N  =   1010 ; \n int  dp [ N ] [ N ] ; \n int  volume [ N ] ,  wealth [ N ] ; \n\n int   main ( )   { \n     int  n ,  v ; \n    cin  >>  n  >>  v ; \n     for   ( int  i  =   1 ;  i  <=  n ;   ++ i )  cin  >>  volume [ i ]   >>  wealth [ i ] ; \n    \n    dp [ 0 ] [ 0 ]   =   0 ; \n    \n     for   ( int  i  =   1 ;  i  <=  n ;   ++ i )   { \n         for   ( int  j  =   0 ;  j  <=  v ;   ++ j )   { \n            dp [ i ] [ j ]   =  dp [ i  -   1 ] [ j ] ; \n             if   ( j  >=  volume [ i ] )  dp [ i ] [ j ]   =   max ( dp [ i ] [ j ] ,  dp [ i  -   1 ] [ j  -  volume [ i ] ]   +  wealth [ i ] ) ; \n         } \n     } \n     int  res  =   0 ; \n     for   ( int  j  =   0 ;  j  <=  v ;   ++ j )   { \n        res  =   max ( res ,  dp [ n ] [ j ] ) ; \n     } \n    cout  <<  res ; \n     return   0 ; \n } \n \n 0-1背包一维化 \n 由于原dp式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) \n 其每次更新如果是取左边： \n dp[i][j] = dp[i - 1][j]  与 i 无关，所以相当于  dp[j] = dp[j] \n 取右边： \n dp[i - 1][j - weight[i]] + value[i]  相当于  dp[j] = dp[j - wieght[i]] + value[i] \n 最后递推式就是： dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) \n dp[j] 代表容量为j的背包能放物品的最大价值 \n 就相当于：  **每次i++，就相当于覆盖更新了一次数组 dp[0...w] **  \n 但是不能从前往后遍历， 这样做是为了保证第i层的dp[j]是由第i - 1层的dp[j] 更新而来，因为如果是从第i层的dp[j - weight[i]]推出dp[j]，就表明第i个物品被放入了两次背包，不符合题意 。 \n \n 如果按照递推公式，正序遍历就会导致dp[0..w]被更新过程中 当  dp[j] = dp[j - weight[i]] + value[i] 时，这里的  dp[j - weight[i]]  的值已经是第 i 层的dp[j]了 而不是第i - 1层的dp[j]，我们直接看例子： \n \n 物品0的重量weight[0] = 1，价值value[0] = 15 \n 如果正序遍历 \n dp[1] = dp[1 - weight[0]] + value[0] = 15 \n dp[2] = dp[2 - weight[0]] + value[0] = 30 \n 此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。 \n 倒序就是先算dp[2] \n dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0） \n dp[1] = dp[1 - weight[0]] + value[0] = 15 \n \n for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n     for   ( int  j  =  bagWeight ;  j  >=  weight [ i ] ;   -- j )   { \n        dp [ j ]   =   max ( dp [ j ] ,  dp [ j  -  weight [ i ] ]   +  value [ i ] ) ; \n\t } \n } \n LC764.最大加号 \n 首先是 暴力解法  O(n^3) \n 具体思路是，分别以每个点为中心，然后逐步增大臂长来判断以该点为中心的加号的最大臂长，如果遇到0或者越界可以直接终止 \n class   Solution   { \n public : \n // 首先暴力法的思路就是，不停的以每个点为中心，判断每个点为中心的加号的最大臂长，最后取最大值 \n     int   orderOfLargestPlusSign ( int  n ,  vector < vector < int >> &  mines )   { \n         int  k  =   0 ; \n\n         // 将mines转化为grid \n         // 当n不为常数时可以使用动态数组，但是此处同样可以使用vector，其底层也是动态数组，但是它更加方便管理内存与使用 \n         int   * * grid  =   new   int * [ n ] ; \n         for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n            grid [ i ]   =   new   int [ n ] ; \n             memset ( grid [ i ] ,   0 ,  n  *   sizeof ( int ) ) ;   // 注意，这样写需要赋值，否则其不为0，为脏数据，对于不同系统，其中的数据不一定为0（虽然理论上为0 \n         } \n         // vector<vector<int>> grid(n, vector<int>(n, 0)); // 使用vector的写法 \n\n         for   ( int  i  =   0 ;  i  <  mines . size ( ) ;   ++ i )  grid [ mines [ i ] [ 0 ] ] [ mines [ i ] [ 1 ] ]   =   1 ;   // 将地雷设置为1 \n\n         for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n             for   ( int  j  =   0 ;  j  <  n ;   ++ j )   { \n                 if   ( grid [ i ] [ j ] )   continue ; \n                 int  len  =   1 ;   // len为阶数，也就是 臂长 + 1 \n                 // l为当前测试的臂长 \n                 for   ( int  l  =   1 ;  l  <  n ;   ++ l )   {   // 必须得从1开始测，否则可能出现距离远点为2的四个方向的点为 \n                     if   ( ( i  -  l  >=   0 )   &&   ( i  +  l  <  n )   &&   ( j  -  l  >=   0 )   &&   ( j  +  l  <  n ) )   { \n                         if   ( ! grid [ i  -  l ] [ j ]   &&   ! grid [ i  +  l ] [ j ]   &&   ! grid [ i ] [ j  -  l ]   &&   ! grid [ i ] [ j  +  l ] )   { \n                            len  =  l  +   1 ; \n                         }   else   { \n                             break ;   // 当出现1时就break \n                         } \n                     }   else   { \n                         break ;   // 当l过大就break \n                     } \n                 } \n                k  =   max ( k ,  len ) ; \n             } \n         } \n\n         // 由里到外删除二维数组 \n         for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n             delete   [ ] grid [ i ] ;   // 注意不是delete grid[i] 就够了 \n            grid [ i ]   =   NULL ; \n         } \n         delete   [ ] grid ; \n        grid  =   NULL ; \n\n         return  k ; \n     } \n } ; \n \n 动态规划解法  O(n^2) \n 首先，前半部分思想和暴力解法一样，都是选取不同的中心点来更新加号的臂长；而后半部分判断加号臂长此处可以通过dp来实现 \n 使用数组  dp[i][j][k] ，其中 k = 0, 1, 2, 3 （从左开始顺时针，左上右下）： \n \n dp[i][j][k] : 表示以点 (i, j) 为中心的加号在 k 方向上表示的臂长 \n \n 据此，可以很容易得出以(i, j) 为中心的加号的最大臂长为  maxLen = min(dp[i][j][k]), k = 0, 1, 2, 3 \n 代码 \n class   Solution   { \n     bool  grid [ 500 ] [ 500 ]   =   { 0 } ; \n     int  dp [ 500 ] [ 500 ] [ 4 ]   =   { 0 } ; \n public : \n // 首先暴力法的思路就是，不停的以每个点为中心，判断每个点为中心的加号的最大臂长，最后取最大值 \n     int   orderOfLargestPlusSign ( int  n ,  vector < vector < int >> &  mines )   { \n        \n\n         for ( int  i  =   0 ;  i  <  mines . size ( ) ;   ++ i )  grid [ mines [ i ] [ 0 ] ] [ mines [ i ] [ 1 ] ]   =   1 ;   // 为方便1表示障碍 \n\n         // 左方向上的连续长度 \n         // 初始化四个边 \n\n         for ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n            dp [ i ] [ 0 ] [ 0 ]   =   ! grid [ i ] [ 0 ] ;   // 左边 \n            dp [ 0 ] [ i ] [ 1 ]   =   ! grid [ 0 ] [ i ] ;   // 上边 \n            dp [ i ] [ n  -   1 ] [ 2 ]   =   ! grid [ i ] [ n  -   1 ] ;   // 右边 \n            dp [ n  -   1 ] [ i ] [ 3 ]   =   ! grid [ n  -   1 ] [ i ] ;   // 下边 \n         } \n        \n         // 方向为0（左臂长度）： 左->右 \n         for ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n             for   ( int  j  =   1 ;  j  <  n ;   ++ j )   { \n                dp [ i ] [ j ] [ 0 ]   =   ( ! grid [ i ] [ j ]   ?  dp [ i ] [ j  -   1 ] [ 0 ]   +   1   :   0 ) ; \n             } \n         } \n\n         // 方向为1（上臂长度）： 上->下 \n         for ( int  j  =   0 ;  j  <  n ;   ++ j )   { \n             for   ( int  i  =   1 ;  i  <  n ;   ++ i )   { \n                dp [ i ] [ j ] [ 1 ]   =   ( ! grid [ i ] [ j ]   ?  dp [ i  -   1 ] [ j ] [ 1 ]   +   1   :   0 ) ; \n             } \n         } \n\n         // 方向为2（右臂长度）： 右->左 \n         for ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n             for   ( int  j  =  n  -   2 ;  j  >=   0 ;   -- j )   { \n                dp [ i ] [ j ] [ 2 ]   =   ( ! grid [ i ] [ j ]   ?  dp [ i ] [ j  +   1 ] [ 2 ]   +   1   :   0 ) ; \n             } \n         } \n\n         // 方向为3（下臂长度）： 下->上 \n         for ( int  j  =   0 ;  j  <  n ;   ++ j )   { \n             for   ( int  i  =  n  -   2 ;  i  >=   0 ;   -- i )   { \n                dp [ i ] [ j ] [ 3 ]   =   ( ! grid [ i ] [ j ]   ?  dp [ i  +   1 ] [ j ] [ 3 ]   +   1   :   0 ) ; \n             } \n         } \n\n         int  res  =   0 ,  tmp  =   0 ; \n\n         for   ( int  i  =   0 ;  i  <  n ;   ++ i )   { \n             for   ( int  j  =   0 ;  j  <  n ;   ++ j )   { \n                tmp  =   min ( min ( dp [ i ] [ j ] [ 0 ] ,  dp [ i ] [ j ] [ 1 ] ) ,   min ( dp [ i ] [ j ] [ 2 ] ,  dp [ i ] [ j ] [ 3 ] ) ) ; \n                res  =   max ( res ,  tmp ) ; \n             } \n         } \n        \n         return  res ; \n     } \n } ; \n \n "},{title:"算法刷题记录",frontmatter:{},regularPath:"/algorithm/",relativePath:"algorithm/README.md",key:"v-e1212422",path:"/algorithm/",content:" 算法刷题记录 \n 本目录用于算法刷题记录，主要语言为    C++   \n 本目录主要按照 题库 -> 算法类别 -> 具体知识点 的方式分类。 \n 计划包含题库主要有 leetcode中文版、AcWing、洛谷及CCF-CSP认证考试等。 \n"},{title:"EffectiveC++",frontmatter:{},regularPath:"/cs-basis/2_EffectiveC++.html",relativePath:"cs-basis/2_EffectiveC++.md",key:"v-5ec813a6",path:"/cs-basis/2_EffectiveC++.html",headers:[{level:2,title:"条款01：视C++为一个语言联邦",slug:"条款01-视c-为一个语言联邦"},{level:2,title:"条款02：尽量以const，enum，inline替换#define",slug:"条款02-尽量以const-enum-inline替换-define"},{level:2,title:"条款03：尽可能使用const",slug:"条款03-尽可能使用const"},{level:2,title:"条款04：确定对象被使用前已先被初始化",slug:"条款04-确定对象被使用前已先被初始化"},{level:2,title:"条款05：了解C++默默编写并调用哪些函数",slug:"条款05-了解c-默默编写并调用哪些函数"},{level:2,title:"条款06：若不想使用编译器自动生成的函数，就该明确拒绝",slug:"条款06-若不想使用编译器自动生成的函数-就该明确拒绝"},{level:2,title:"条款07：为多态基类声明virtual析构函数",slug:"条款07-为多态基类声明virtual析构函数"}],content:' EffectiveC++ \n 条款01：视C++为一个语言联邦 \n C++包含四大部分 \n C ，  Objected-Oriented C++ ，  Template C++ ，  STL \n 条款02：尽量以const，enum，inline替换#define \n ①编译器看不见define的常量名称，如  #define pi 3.14  在预处理后展开为3.14，编译器无法识别，这样debug时编译器报错无法追溯到具体的变量 \n \n C++11中用  nullptr  (nullptr_t 类型的右值常量，专用于初始化空指针)替代  NULL （宏定义） \n \n \n nullptr可以被隐式转换为任意类型的指针，但不能被隐式转换为整型；这与 NULL 不同 \n int   *  a1  =   nullptr ; \n char   *  a2  =   nullptr ; \n double   *  a3  =   nullptr ; \n            \n void   isnull ( void   * c )   { \n    cout  <<   "void*c"   <<  endl ; \n } \n void   isnull ( int  n )   { \n    cout  <<   "int n"   <<  endl ; \n } \n isnull ( NULL ) ;  \t\t // 结果为int n \n isnull ( nullptr ) ;      // 结果为void*c \n \n 总之在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。 \n \n \n \n ②const，enum可以被封装，且enum与define类似不能被取地址 \n ③宏定义的函数会出一些问题，例如一下： \ninclude   <iostream> \n using   namespace  std ; \ndefine   CALL_WITH_MAX ( a ,  b )   f ( ( a )   >   ( b )   ?   ( a )   :   ( b ) ) \n\n // 宏定义单纯是用匹配的位置直接进行字符串替换 \n // 也就是说 CALL_WITH_(++a, b) 等价于 \n // f((++a) > (b) ? (++a) : (b)) , 结果是true的话a将被累加两次 \n // 由于C/C++程序编译顺序为 预处理 -> 编译 -> 汇编 -> 链接 \n // 所以在++a(或其它表达式被计算之前)，宏定义就已经展开 \n\n int   f ( int  a )   { \n     return  a ; \n } \n\n //为了避免这种错误，使用template inline可以获得同等高的效率 \n template < typename   T > \n inline   void   callWithMax ( const  T &  a ,   const  T &  b )   {   //使用常量引用防止新的内存消耗且禁止在函数内部修改值 \n    cout  <<  a  <<  endl ; \n     f ( a  >  b  ?  a  :  b ) ; \n } \n\n int   main ( )   { \n     int  a  =   5 ,  b  =   0 ; \n    cout  <<   CALL_WITH_MAX ( ++ a ,  b )   <<  endl ;   // a累加2次，第一次累加后a为6 > b(0), 所以返回?后的a,此时再次累加一次得到a=7 \n    cout  <<   CALL_WITH_MAX ( ++ a ,  b  +   10 )   <<  endl ;   // a累加1次，第一次累加后a=8，a < b(10), 所以?后返回b不再为a进行累加， \n    cout  <<  a  <<  endl ;   // 最后a为8 \n     callWithMax ( ++ a ,  b ) ; \n    cout  <<  a  <<  endl ; \n     return   0 ; \n } \n \n 使用 inline替换#define可以很好解决 \n 小结： \n \n 对于单纯常量，最好以const对象或enum 替换#define \n 对于形似函数的宏（macros），最好改用inline函数替换#define \n 条款03：尽可能使用const \n const 在  *  左边表示指向的对象是常量; const在 * 右边表示指针本身是常量，指向地址不变。 \n \n 注意， *  肯定在类型后面才是正确的语法 \n \n const  Widget *  pw ; \nWidget  const   *  pw ;   // 两种都是对象是常量 \n \n int   const   * p ;   //指向的对象是常量 \n const   int   * p2 ; \n int  b  =   0 ; \n const   int   * const  p3  =   & b ;   //指针是常量 \n \n 对于迭代器， const  关键字直接作用于  iterator  本身，会得到一个 指向无法改变 的指针；（iterator作用类似于T*, const iterator 类似于 T * const) \n \n const (type)::iterator it; ++it; // 错误，it指向无法改变 \n \n 想要 内容无法改变的迭代器 ，则可以 直接用  ::const_iterator  (const_iterator 作用类似于 const T *) \n \n (type)::const_itarotor cIt; ++cIt; // 正确，指向可以改变 *cIt = 2; // 错误，cIt指向对象的内容无法被更改 \n \n const  可以用来声明 函数返回值、各参数、函数自身（如果是成员函数，类中的长函数，在函数名后声明const） \n   为什么要将返回值声明为const？   \n 是为了防止表达式的结果被更改，比如进行 operator* 运算符重载时返回常量，让其成为右值。 避免以下错误： \n if   ( a  *  b  =  c )   . . .   // 将 operator* 的返回值定义为const，这种无意识的错误就可以避免 \n \n 对于  operator[]  如果返回值类型为 char 的 引用，那么返回值可以修改，但如果单纯返回的是一个内置类型如char，由于其为字面值（右值）而非变量，所以无法修改。 \n const 成员函数的作用？   \n \n 使得class接口易于被理解，易于分辨哪些函数可以改动对象内容而哪些不可以 \n 用于实现  pass by reference-to-const  ， void func(const T& a) const {} \n \n 成员函数可以通过其常量性不同来重载。 \n const成员函数有两种哲学： \n \n \n bitwise constness ：不改变对象中的任何一个bit \n \n 有个问题，根据该原则，对象的所属成员指针指向不能改变，但指针指向的对象却不属于初始对象，所以其内容可以改变。 \n PS：mutable 关键字有助于释放 non-static 成员变量的 bitwise-constness \n \n \n \n logical constness ：const成员函数可以修改它所处理的对象内的某些bits \n \n 可以根据所需要达成的目的，进行逻辑上的约束 \n \n \n \n 运算符重载可以做很多安全性检测。 \n \n operator[] 不单是返回一个 reference 指向某字符，也执行 边界检验（bounds checking）、志记访问信息（logged access info）、数据完整性检验。 \n \n 将这些检验同时塞进const 和 non-const operator[] 中就会引发很多问题。为了解决这个问题，我们就需要： \n 消除重复代码，在 non-const operator[] 中调用 const operator[]. \n 具体做法如下： \n class   TextBlock   { \n public : \n     const   char &   operator [ ] ( )   ( std :: size_t position )   const   { \n         . . . \n             return  text [ position ] ; \n     } \n     char &   operator [ ] ( std :: size_t position )   { \n         return   const_cast < char & > ( \t\t\t\t\t // 将op[]的返回值的const移除 \n        \t static_cast < const  TextBlock & > ( * this )      // 为*this加上cosnt \n            \t [ position ] \t\t\t\t\t\t\t // 调用const char& op[] \n         ) ; \n     } \n } \n \n \n 可以看到进行了两次转型： \n \n 第一次为 *this 添加 const（这使得接下来调用 operator[] 时得以调用 const 版本） \n 第二次 则是从 const operator[] 的返回值中移除 const \n \n \n 如果在const函数内调用non-const版本，那么可能出现风险：你曾承诺不改动的那个对象被改动了。 \n 小结： \n \n 将某些东西声明为const有助于编译器侦测出错误用法 \n 编译器强制实施 bitwise constness，但我们编写程序时应当使用“概念上的常量性”（conceptual constness) \n 当 const 和 non-const 版本成员函数有着实质等价的实现时， 在 non-const 版本中调用 const 版本可避免代码重复 \n 条款04：确定对象被使用前已先被初始化 \n 做法： \n \n \n 手动初始化 \n int  x  =   0 ; \t\t\t\t\t\t\t\t // 对 int 进行手工初始化 \n const   char *  text  =   "A C-style string" ;    // 对指针进行手工初始化 \n\n double  d ; \nstd :: cin  >>  d ;  \t\t\t\t\t\t\t // 通过 input stream 的方式完成初始化 \n \n \n \n 内置类型以外的通过  构造函数（constructors）初始化 \n \n 规则就是：确保每一个构造函数都将对象的每一个成员初始化 \n 要注意的就是不要混淆  赋值 （在函数体内使用 ‘=’ 叫做赋值） 和  初始化 （通过参数列表初始化） \n C++定义：对象成员变量的初始化发生于进入构造函数体内之前 \n 所以也可以在对象成员生命处直接初始化，然后默认构造函数直接声明外 name() = default;（注意：static成员应该在类内声明类外初始化） \n \n \n \n 基于赋值的版本首先调用  default  构造函数为成员变量赋初值，然后为他们设置新值，这样 第一次赋初值就浪费了。所以通过成员初始值列表来初始化避免该问题。 \n 也就是说：构造函数赋值 = 先 default构造 + 再 调用 copy assignment 操作符 \n 如果只想要使用  default  构造一个成员变量，也可以通过无参的成员初值列表来实现： \n ABEntry :: ABEntry ( ) \n     :   theName ( ) , \n\t   theAddress ( ) , \n\t   thePhones ( ) ,  \t\t\t // 因为编译器会为用户自定义类型自动调用默认构造函数，所以前三个会调用它们的 default 构造函数 \n       numTimesConsulted ( 0 ) \n {   } \n \n 记住要在初值列表中列出所有成员变量。 \n \n 如果遗漏了就会导致有些成员没有初值，进而引发不明确行为。 \n \n 额外注意： \n \n \n 对于有些内置类型也需要使用初值列表 \n 成员变量为 const 或 reference，就一定需要处初值列表，不能只用赋值 \n 所以最好的做法就是所有时候都 只用 初始化列表 \n \n \n 合理使用赋值替换初始化 \n \n 许多 classes 拥有多个构造函数，每个构造函数有自己的成员初值列表。如果 这种 classes 里边存在许多成员变量和/或 base classes，多份成员初值列表会导致许多重复初始化，这时候可以合理用一些赋值来替换初始化某些变量，同时赋值操作就一起封装在某个private成员函数中，提供给构造函数使用。 \n 这种做法在  从文件或数据库中读入数据来给成员变量赋初值时  很有用 \n \n \n \n 初始化最好按照声明顺序初始化 \n \n \n 还需要注意  non-local static  对象 的初始化顺序 \n \n \n static 对象寿命从被构造出来直到程序结束为止 \n \n \n 函数内的 static对象为 local static，它们是函数内的局部变量 \n \n \n 其它static（global对象、namespace作用域内的对象、classes内的、file作用域内被声明的static）都是 non-local static \n \n \n 程序结束时，static对象会被自动销毁，它们的析构函数会在 main() 结束时被自动调用 \n \n \n 问题：某编译单元内的某个non-local static 对象的初始化动作使用了另一个编译单元内的某个 non-local static 对象，它所使用的对象可能并未初始化，因为C++并未定义不同编译单元内static对象的初始化顺序。 \n \n 编译单元（translation unit）是指产出单一目标文件（single object file）的那些源码。基本上它是单一源码文件加上其所含入的头文件。 \n \n 消除该问题需要做的是：将每个 non-local static 对象搬到自己的专属函数内（该对象在此函数内被声明为 static）。这些函数返回一个 reference 指向它所含的对象。 T& getX() { static T x; return x;}  然后用户调用这些函数而不直接指涉这些对象。换句话说，non-static 对象被 local static 对象替换了。这是 ***Singleton***模式（单例模式）的经典实现。 \n 这个手法的基础：C++保证，函数内的local static 对象会在 “该函数被调用期间” ”第一次遇上该对象的定义式“ 时被初始化。所以用 ”函数调用“（返回一个 reference to local static) 替换 ”直接访问non-local static 对象“，可以保证所获得的reference将指向一个被初始化的对象。并且  如果从未调用那个non-static 对象的 getX()   函数，那么就一定不会引发构造和析构成本，这比真正的 non-local static 对象更有优势。 \n // 来自你写的服务端程序： \n class   FileSystem   { . . . } ; \n\n\n // 下面时来自客户端的程序 \n // 省去了 extern tfs \nFileSystem &   tfs ( )   { \t\t\t\t // 用这个函数来替换tfs对象 \n     static  FileSystem fs ; \t\t // 定义并初始化一个local static对象（这里的fs已经在服务端程序初始化） \n     return  fs ; \t\t\t\t\t // 返回一个 reference 指向上述对象 \n } \n class   Directory   { . . . } ; \n Directory :: Directory (  params )   { \n     . . . \n    std :: size_t disks  =   tfs ( ) . numDisks ( ) ;   // 使用tfs() 来替换直接访问 tfs对象 \n     . . . \n } \n\nDirectory &   tempDir ( )   { \n     static  Directory td ;   // 定义并初始化 local static 对象 \n     return  td ; \t\t\t  // 返回一个reference指向上述对象 \n } \n\n // 这种简短的函数及其适合inline \n \n \n \n 同时上述做法会让其在多线程函数中出现隐患 \n 在程序的的单线程启动阶段手工调用所有 reference-returning 函数，可以消除与初始化次序有关的”竞速情况” \n \n \n \n \n 小结： \n \n 为内置型对象进行手工初始化，因为C++不保证初始化它们。 \n 构造函数最好使用成员初值列(member initialization list)，而不要在构造函数本体内使用赋值操作(assignment)。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。 \n 为免除”跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象 。 \n 条款05：了解C++默默编写并调用哪些函数 \n 如果你没有声明，C++类中默认有  默认构造函数、一个拷贝构造函数、一个拷贝赋值操作符（=）重载函数、一个析构函数 ，它们都是  public 且 inline 的。 \n 并且从左到有，如果你自己手动声明了一个默认构造函数的化，那么左边的那些函数系统就不会再生成。 \n 比如：你自己定义了一个拷贝构造，那么系统不再给你提供默认构造。 \n 例子： \n \n 对于一个空类 empty \n class   empty   { } ; \n \n 其等价于 \n class   empty   { \n public : \n\t Empty ( )   {   . . .   } \t\t\t\t\t\t\t\t // default构造函数 \n     Empty ( const  Empty &  rhs )   {   . . .   } \t\t\t\t // copy构造函数 \n     ~ Empty ( )   {   . . .   } \t\t\t\t\t\t\t // 析构函数 \n    \t\t\t\t\t\t\t\t\t\t\t // virtual 函数后面再说 \n    Empty &   operator = ( const  Empty &  rhs )   {   . . .   } \t // copy assignment构造函数 \n } ; \n \n \n 编译器产出的析构函数时non-virtual的，virtual属性需要手动声明，除非它的base class的析构函数是个virtual的 \n 如果你编写了一个有参构造函数，那么编译器不再提供默认构造函数；并且，对于默认拷贝构造函数而言，对应的参数一定需要对应才行 \n 条款06：若不想使用编译器自动生成的函数，就该明确拒绝 \n 一般来说不想要某个函数自己不声明就够了，但是对于默认生成的则需要手动控制。 \n 下面是方法： \n \n \n 将编译器默认生成的拷贝函数声明为private并且不定义 。但这个做法不完全安全，因为成员函数和友元friend函数都可以调用private，但不定义就可以做到防止被人调用（此时会返回链接错误）。 \n class   Uncopyable   { \n public : \n     Uncopyable ( )   { } \n     ~ Uncopyable ( )   { } \n     friend   void   func ( ) ; \n private : \n     Uncopyable ( const  Uncopyable  & c ) ; \n } ; \n\n class   Newuc   :   private   Uncopyable   { \n\n } ; \n\n void   func ( )   { \n    Uncopyable c1 ; \n    Uncopyable  c2 ( c1 ) ; \n     // Newuc nc1; \n     // Newuc nc2(nc1); \n } \n \n 调用  func()  发现报错  collect2.exe: error: ld returned 1 exit status \n 而有了一个这种不可被拷贝的类后，子类只需要私有继承这个不可被拷贝类即可使其自身也不可被拷贝 ，因为父类的拷贝构造被定义为私有的，所以子类不能调用父类的拷贝构造函数，所以子类中的拷贝构造被删除。 \n \n \n \n 使用C++11提供的delete关键词新用法 。 \n class   MyObj   { \n public : \n   MyObj ( )   =   delete ;   // 阻止编译器合成构造函数，会导致类无法实例化 \n  MyObj &   MyObj ( const  MyObj  & )   =   delete ;   // 阻止编译器合成拷贝构造函数，会导致类无法拷贝构造，如std::cin, std::cout \n  MyObj &   operator = ( const  MyObj  & )   =   delete ;   // 阻止合成赋值运算符，会导致类无法拷贝，如cin, cout, cerr \n   . . . \n } \n \n \n \n 小结 ：为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为  private  并且不予实现。使用像Uncopyable这样的base class也是一种做法。 \n 条款07：为多态基类声明virtual析构函数 \n virtual函数一般用于多态，使用父类指针指向子类对象时，通过父类指针调用函数，此时调用的是子类函数，这就是多态。 \n 实现原理：使用virtual后会在子类对象中添加一个函数指针，函数指针指向一个虚函数表，虚函数表中存放了virtual函数的函数地址，如果子类重写了父类中的虚函数，那么就由子类函数的地址覆盖父类函数地址。 \n \n \n 当基类的指针指向子类的对象，而基类的析构函数不是虚析构，那么此时 delete父类指针时就不会执行子类析构，导致内存泄漏 \n \n \n 如果要继承std::string，也不行，因为std::string有个非虚析构函数 \n \n \n 有时候可以考虑声明一个纯析构函数 \n virtual   ~ ClassName ( )   =   0 ;   // 使该类成为抽象类，不能实例化 \n \n \n \n 析构函数的调用规则是，先子类后父类 \n \n \n'},{title:"STL源码剖析（侯捷）",frontmatter:{},regularPath:"/cs-basis/3_STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.html",relativePath:"cs-basis/3_STL源码剖析.md",key:"v-9b0d847c",path:"/cs-basis/3_STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.html",headers:[{level:2,title:"1.认识headers、版本及学习C++重要资源",slug:"_1-认识headers、版本及学习c-重要资源"},{level:3,title:"headers",slug:"headers"},{level:2,title:"2.C++STL体系结构基础",slug:"_2-c-stl体系结构基础"},{level:3,title:"六大部件（Components）：",slug:"六大部件-components"},{level:3,title:"一些容器中相关的关键字",slug:"一些容器中相关的关键字"},{level:2,title:"3. 容器之分类与各种测试",slug:"_3-容器之分类与各种测试"},{level:3,title:"容器在内存中的结构概览",slug:"容器在内存中的结构概览"},{level:3,title:"各个容器的方法及效率总结",slug:"各个容器的方法及效率总结"},{level:4,title:"array",slug:"array"},{level:4,title:"vector",slug:"vector"},{level:4,title:"list",slug:"list"},{level:4,title:"deque",slug:"deque"},{level:4,title:"stack",slug:"stack"},{level:4,title:"queue",slug:"queue"},{level:4,title:"set/multiset",slug:"set-multiset"},{level:4,title:"map/multimap",slug:"map-multimap"},{level:4,title:"unordered_set",slug:"unordered-set"},{level:4,title:"unordered_map",slug:"unordered-map"},{level:3,title:"分配器测试",slug:"分配器测试"},{level:4,title:"allocator",slug:"allocator"},{level:2,title:"4 C++STL体系结构",slug:"_4-c-stl体系结构"},{level:3,title:"4.1 C++源码文件布局",slug:"_4-1-c-源码文件布局"},{level:3,title:"4.2 OOP（面向对象编程）vs. GP（泛型编程）",slug:"_4-2-oop-面向对象编程-vs-gp-泛型编程"},{level:3,title:"4.3 阅读C++STL的技术基础",slug:"_4-3-阅读c-stl的技术基础"},{level:2,title:"5 C++STL源码剖析",slug:"_5-c-stl源码剖析"},{level:3,title:"5.1 分配器allocators",slug:"_5-1-分配器allocators"},{level:3,title:"5.2 容器之间的实现关系与分类",slug:"_5-2-容器之间的实现关系与分类"},{level:3,title:"5.3 容器list",slug:"_5-3-容器list"},{level:3,title:"5.4 迭代器的设计原则和Iterator Traits的作用与设计",slug:"_5-4-迭代器的设计原则和iterator-traits的作用与设计"}],content:' STL源码剖析（侯捷） \n 本文件为个人学习C++STL的笔记（仅限C++11） \n 1.认识headers、版本及学习C++重要资源 \n STL = Standard Template Library (标准模板库) \n C++参考网站推荐 https://zh.cppreference.com/ \n 学习C++STL源码 所需要知识 \n \n C++基本语法（正确使用模板，templates) \n \n 学习目标 \n \n lv0: 了解C++标准库的用法及复杂度 \n lv1：熟悉C++标准库实现结构，做到胸中有丘壑 \n lv2：良好使用C++标准库 \n lv3：扩充C++标准库 \n headers \n \n \n STL以header files的形式被引入，并且不带.h，例如  #include<vector> \n \n \n 新式C header files 也可以不带 .h，例如  #include <cstdio> \n \n \n 旧式C header files 也可以使用，例如  #include <stdio.h> \n \n \n 命名空间 \n \n \n using namespace std;  or  using std::cout; \n \n \n 亦可自命名如下： \n . . . \n // 在主函数外自命名一个命名空间 \n namespace  jj01  { \n     bool   strLonger ( const  string &  s1 ,   const  string &  s2 )   { \n         return  s1 . size ( )   <  s2 . size ( ) ; \n     } \n } \n . . . \n\n int   main ( int  argc ,   char * *  argv )   { \n    . . . \n   cout  <<  jj01 :: strLonger ( "Hello" ,   "Hello2" )   <<  endl ; \n } \n \n \n \n \n \n 旧式C header files 不封装于 namespace std \n 2.C++STL体系结构基础 \n Standard Template Library \n  六大部件（Components）： \n \n 容器（Containers) \n 分配器（Allocators） \n 算法（Algorithms） \n 适配器（Adapters） \n 迭代器（Iterators） \n 仿函数（Functors) \n \n 它们的关系图如下： \n \n 下面是一段使用了六大类型STL的程序： \n \n 各个函数解释如下： \n 1. count_if  : 返回在  [first, last)  范围内满足特定条件的元素的数目。 \n 2. not1 :  std::not1  和  std::not2  是用来把符合某种特殊条件的『函数对象』转换为反义「函数对象」的函数。 \n 具体的： \n not1是构造一个与谓词结果相反的一元函数对象。\nnot2是构造一个与谓词结果相反的二元函数对象。 \n 3. bind2nd :  bind1st 和  bind2nd  是将二元函数转换为一元函数，比如一个比较大小的函数是二元函数，当在某些情况下我们想要固定第一个参数（ bind1st ）或者第二个参数（ bind2nd ）时，就成了一元函数.在此处是将仿函数  less<int>()  的第二个参数绑定为40. \n 4. less<int>() :  less<datatype>(dataType x, dataType y) , 其返回值为 谓词  x < y  的  bool  类型结果。（ greater<int>() 同理），关于less对象源码和bind2nd源码，可参考博客  C++ bind2nd用法 \n 所以  count_if(vi.begin(), vi.end(), not1(bind2nd(less<int>(), 40) ) ) 是指： \n \n 返回vi容器中在区间 [vi.begin(), vi.end()) 中不小于40的元素的个数 \n \n 运行结果： \n \n 4 \n 一些容器中相关的关键字 \n 关于iterator \n 我们可以将迭代器（iterator）理解为泛化指针，指针能做的，它也可以做，比如重载了  *  号 \n since C++11的for range遍历语法(range based for statement) \n for   ( declaration  :  collection )   { \n    statement\n } \n\n for   ( int  i  :   { 2 ,   3 ,   5 ,   7 ,   9 ,   13 ,   17 ,   19 } )   { \n    std :: cout  <<  i  <<  std :: endl ; \n } \n\nstd :: vector < double >  vec ; \n . . . \n for   ( auto  elem  :  vec )   { \n    std :: cout  <<  elem  <<  std :: endl ; \n } \n\n for   ( auto &  elem  :  vec )   { \n    elem  *=   3 ; \n } \n \n 关于auto \n list < string >  c ; \n . . . \nlist < string > :: iterator ite ; \nite  =   :: find ( c . begin ( ) ,  c . end ( ) ,  target ) ; \n \n 现在可以直接使用auto自动类型推断 ↓ \n list < string >  c ; \n . . . \n auto  ite  =   :: find ( c . begin ( ) ,  c . end ( ) ,  target ) ; \n 3. 容器之分类与各种测试 \n 容器在内存中的结构概览 \n \n 红框中为C++11标准出现 \n 顺序容器(Sequence Containers): \n Array  : 是封闭的数组，不可扩展（将数组包装成一个类） \n Vector  : 是半开放的动态数组，可以扩展，空间不够则自动x2，自动扩充由分配器来做. \n Deque  : 双端队列，后续解释如何实现 \n List   : 双向链表（双向环状链表） \n Forward-List  ：单向链表 \n 关联容器(Associated Containers): \n Set/Multiset:  红黑树，高度平衡二叉搜索树；Set中元素不可重复，Multiset可以。 \n Map/Multimap:  也是红黑树，但每个节点分为key-value；同理，Map的key不可重复，Multimap的key可以重复。 \n 无序容器（Unordered Conatiners）： \n Unordered Set/Multiset  : 底层是用拉链法解决碰撞的哈希表实现(HashTable Separate Chaining) \n Unordered Map/Multimap  : 也是用拉链法。 \n 它们的主要功能与普通的Set/Map类似，且查找效率更高为 O(1) ；不同的是它们 不可排序 。 \n 各个容器的方法及效率总结 \n std::find(c.begin(), c.end(), target)  为顺序查找。 \n std::bsearch() 为二分查找（前提是原容器需要有序） \n 需要注意各个容器迭代器失效的情况 \n  array \n template < class T, size_t N > class array;  T为类型，N为大小 \n \n \n \n 方法 \n 作用 \n 复杂度 \n \n \n \n \n size() \n 返回元素个数 \n \n \n \n front() \n 返回第一个元素 \n O(1) \n \n \n back() \n 返回最后一个元素 \n O(1) \n \n \n data() \n 返回指向作为元素存储工作的底层数组的指针 \n O(1) \n \n \n fill(T val) \n 将所有元素的值都设为val \n O(n) \n  vector \n 也可以参考  vector ，需要注意指针失效的情况 \n template < class T, class Alloc = allocator<T> > class vector; // generic template \n 注意，如果内存重新分配，那么原来的指针将失效。 \n \n \n \n 方法 \n 作用 \n 复杂度 \n \n \n \n \n size() \n 返回元素个数 \n O(1) \n \n \n capacity() \n 返回容器容量（已申请的空间） \n O(1) \n \n \n empty() \n 返回容器是否为空（空返回true，非空返回false） \n O(1) \n \n \n shrink_to_fit() \n 使容器空间收缩为元素所占空间大小（需要一个个遍历释放空间） \n O(n) \n \n \n swap(vector& other) \n 将内容与  other  的交换。不在单独的元素上调用任何移动、复制或交换操作。所有迭代器和引用保持合法。尾后迭代器被非法化。 \n O(1) \n \n \n erase() \n 删除指定元素 \n O(n) \n \n \n insert(iterator pos, const T& val) \n 有重载，这里说一般用法 \n O(1) \n \n \n push_back(T& val) \n 将元素添加到容器末尾 \n O(1) \n \n \n emplace_back(T& val) \n 在容器末尾就地构造元素 \n O(1) \n  list \n template < class T, class Alloc = allocator<T> > class list; \n 底层是双向链表。 \n \n \n \n 方法 \n 作用 \n 复杂度 \n \n \n \n \n size() \n 返回存放元素个数 \n O(1) \n \n \n max_size() \n 返回list能容纳的最大元素数量 \n O(1) \n \n \n pop_front()/pop_back() \n 移除首/尾元素 \n O(1) \n \n \n push_front()/push_back() \n 将元素添加到容器起始/尾部 \n O(1) \n \n \n emplace_front()/emplace_back() \n 在容器起始/末尾就地构造元素 \n O(1) \n \n \n merge() \n 合并二个已排序列表 \n O(n) \n \n \n unique() \n 删除连续的重复元素 \n O(n) \n \n \n reverse() \n 将该链表的所有元素的顺序反转。不非法化任何引用或迭代器。 \n O(n) \n \n \n splice() \n 从另一个 list 中移动元素 \n O(n)/O(1) \n  deque \n template < class T, class Alloc = allocator<T> > class deque; \n \n deque在内存空间中实际上是分段的，只是使用时看起来时连续的。 \n 空间利用率高，但查找慢。 \n  stack \n template <class T, class Container = deque<T> > class stack; \n stack  是用  deque  封装实现的，所以它属于 容器适配器 \n  queue \n template < \n   class   T , \n   class   Container   =  std :: deque < T > \n >   class   queue ; \n  set/multiset \n 关联容器的效率是 \n set \n template   <   class   T ,                          // set::key_type/value_type \n            class   Compare   =  less < T > ,          // set::key_compare/value_compare \n            class   Alloc   =  allocator < T >        // set::allocator_type \n            >   class   set ; \n \n multiset \n template   <   class   T ,                          // multiset::key_type/value_type \n            class   Compare   =  less < T > ,          // multiset::key_compare/value_compare \n            class   Alloc   =  allocator < T >   >      // multiset::allocator_type \n            >   class   multiset ; \n  map/multimap \n map \n template   <   class   Key ,                                       // map::key_type \n            class   T ,                                         // map::mapped_type \n            class   Compare   =  less < Key > ,                       // map::key_compare \n            class   Alloc   =  allocator < pair < const  Key , T >   >      // map::allocator_type \n            >   class   map ; \n \n multimap \n template   <   class   Key ,                                       // multimap::key_type \n            class   T ,                                         // multimap::mapped_type \n            class   Compare   =  less < Key > ,                       // multimap::key_compare \n            class   Alloc   =  allocator < pair < const  Key , T >   >      // multimap::allocator_type \n            >   class   multimap ; \n \n \n 底层实现红黑树，查找效率$$O(nlog_2(n))$$ \n  unordered_set \n 底层hash表 \n template   <   class   Key ,                          // unordered_set::key_type/value_type \n            class   Hash   =  hash < Key > ,             // unordered_set::hasher \n            class   Pred   =  equal_to < Key > ,         // unordered_set::key_equal \n            class   Alloc   =  allocator < Key >        // unordered_set::allocator_type \n            >   class   unordered_set ; \n \n 测试 \n  unordered_map \n 底层为hash表 \n template   <   class   Key ,                                      // unordered_map::key_type \n            class   T ,                                        // unordered_map::mapped_type \n            class   Hash   =  hash < Key > ,                         // unordered_map::hasher \n            class   Pred   =  equal_to < Key > ,                     // unordered_map::key_equal \n            class   Alloc   =  allocator <  pair < const  Key , T >   >    // unordered_map::allocator_type \n            >   class   unordered_map ; \n \n 测试 \n \n 若扩容也是扩为两倍。 \n 分配器测试 \n allocator \n 分配器用于分配存储空间，此处allocator是用于分配内存空间 \n e.g.几个默认使用allocator作为分配器的STL库中类的声明 \n vector  源码声明 \n template < typename   _Tp ,   typename   _Alloc   =  std :: allocator < _Tp >> /* _Tp为数据类型，_Alloc为分配器类型，执行时确定类型 */ \n class   vector   :   protected  _Vector_base < _Tp ,  _Alloc > \n \n list  源码声明 \n template < typename   _Tp ,   typename   _Alloc   =  std :: allocator < _Tp >> \n class   list   :   protected  _List_base < _Tp ,  _Alloc > \n \n deque  源码声明 \n template < typename   _Tp ,   typename   _Alloc   =  std :: allocator < _Tp >> \n class   deque   :   protected  _Deque_base < _Tp ,  _Alloc > \n \n set  源码声明 （后面的关联容器底层使用红黑树，所以需要有less仿函数来比较） \n template < typename   _Key ,   typename   _Compare   =  std :: less < _Key > ,   typename   _Alloc   =  std :: allocator < _Key >> \n class   set \n /*_Key类型用于查找，后面的_Tp用于存放具体数据，less仿函数用于比较*/ \n \n map  源码声明 \n template < typename   _Key ,   typename   _Tp ,   typename   _Compare   =  std :: less < _Key > , \n\t\t typename   _Alloc   =  std :: allocator < _Key >> \n class   map \n \n unordered_set  源码声明（后面的无序容器底层使用哈希表实现） \n template < class   _Value , \n\t\t  class   _Hash   =  hash < _Value > , \n\t\t  class   _Pred   =  std :: equal_to < _Value > , \n\t\t  class   _Alloc   =  std :: allocator < _Value >> \n class   unordered_set \n /*_Value用于存放值，_Hash 用于确定哈希函数(根据_Value的值生成哈希值)，_Pred 用于比较值是否相等*/ \n \n unordered_map  源码声明 \n template < class   _Key ,   class   _Tp , \n\t\t  class   _Hash   =  hash < _Key > , \n\t\t  class   _Pred   =  std :: equal_to < _Key > , \n\t\t  class   _Alloc   =  std :: allocator < std :: pair < const  _Key ,  _Tp >   >   > \n class   unordered_map \n \n \n 注意，只有当要申请小块空间时再使用malloc或者free，否则就用已经封装好了的库即可。 \n 同样，除了上述其情况，一般使用分配器 \n 4 C++STL体系结构 \n \n quote: 源码之前，了无秘密。 \n Algorithms + Data Structures = Programs \n 数据的属性 + 维护这个属性的操作 = Data Structure \n 4.1 C++源码文件布局 \n 4.2 OOP（面向对象编程）vs. GP（泛型编程） \n OOP = Object-Oriented programming \n GP = Generic programming \n OOP与GP的最大区别： \n \n \n OOP : 企图将  数据（data）  与  操作（methods）  联系在一起 \n \n \n GP : 却是将  数据  与  操作  分开来 \n \n \n 例子： \n 容器list不能使用::sort() 排序，所以它有自己的sort() \n \n 采用GP的优点： \n \n Containers  和  Algorithms  团队可各自闭门造车，其间以  Iterator  沟通即可 \n Algorithms  通过  Iterators  确定操作范围，并通过  Iterators  取用  Container 元素 \n \n 以下是例子： \n \n template < class   T > \n inline   const  T &   min ( const  T &  a ,   const  T &  b ,  Compare comp )   { \n     return   comp ( b ,  a )   ?  b  :  a ; \n } \n // comp可以作为仿函数，因为Compare重载了操作符括号 () \n \n 所有algorithms，其内最终设计元素本身的操作，无非就是比大小。 \n 4.3 阅读C++STL的技术基础 \n 操作符重载（Operator Overloading) \n 几个限制： \n \n \n 四个不能重载的操作符 \n \n \n ::  (scope resolution) \n \n \n .  (member access) \n \n \n .*  (member access through pointer to member) \n \n \n ?:  (ternary conditional) \n \n \n \n \n 不能创造C++未实现的操作符，如  **, <>, &| 之类 \n \n \n 运算符的优先级、结合方向或操作数的数量不会变化。 \n \n \n 重载的运算符  ->  必须要么返回裸指针，要么（按引用或值）返回同样重载了运算符  ->  的对象。 \n \n \n 运算符 **&&**与  ||  的重载失去短路求值。 \n \n \n C++17以前， && 、 ||  和  , （逗号）在被重载时失去它们特殊的 定序性质 ，并且即使不使用函数调用记法，也表现为与常规的函数调用相似。 \n \n \n \n \n \n 表达式 \n 作为成员函数 \n 作为非成员函数 \n 示例 \n \n \n \n \n @a \n (a).operator@ ( ) \n operator@ (a) \n !std::cin  调用  std::cin.operator!() \n \n \n a@b \n (a).operator@ (b) \n operator@ (a, b) \n std::cout<< 42  调用  std::cout.operator<<(42) \n \n \n a=b \n (a).operator= (b) \n 不能是非成员 \n 给定  std::string s;  ，  s = "abc";  调用  s.operator=("abc") \n \n \n a(b...) \n (a).operator()(b...) \n 不能是非成员 \n 给定  std::random_device r;  ，  auto n = r();  调用  r.operator()() \n \n \n a[b] \n (a).operator \n 不能是非成员 \n 给定  std::map<int, int> m;  ，  m[1] = 2;  调用  m.operator[](1) \n \n \n a-> \n (a).operator-> ( ) \n 不能是非成员 \n 给定  auto p = std::make_unique<S>();   p->bar()  调用  p.operator->() \n \n \n a@ \n (a).operator@ (0) \n operator@ (a, 0) \n 给定  std::vector<int>::iterator i = v.begin();  ，  i++  调用  i.operator++(0) \n \n \n \n \n \n \n \n \n \n 在这张表中， @  是表示所有匹配运算符的占位符： @a  是所有前缀运算符， a@  是除 -> 以外的所有后缀运算符， a@b  是除 = 以外的所有其他运算符。 \n 相关链接  std::random_device ， std::string ， std::map ， std::make_unique ， std::cin ， std::vector \n \n 侯捷老师原话：你记得下来吗？反正我记不下来。当我们需要写的时候再去查找。 \n \n 模板（Templates） \n 见之前的文档。 \n 迭代器（泛化指针）的例子 \n \n 模板可以自动推导类型 \n \n 模板中特别要知道的： \n 泛化与特化 \n 特化可以加快运行速度，突出template为空的情况 \n \n 哈希中的特化 \n \n 当类型为空时 \n \n 偏特化 \n 5 C++STL源码剖析 \n 5.1 分配器allocators \n ==先谈operator new() 和 malloc== \n C++一层层调用，最终会回到malloc这个函数，而malloc最终又会根据系统的不同进行底层的系统调用。 \n malloc 的实现见博客 [【malloc的底层实现及原理】](![img](file:///C:\\Users\\F\\AppData\\Roaming\\Tencent\\QQ\\Temp%W@GJ$ACOF(TYDYECOKVDYB.png)https://www.cnblogs.com/zpcoding/articles/10808969.html) \n operator new \n \n 旧版的allocator由于封装malloc与free过多层，造成开销过大；所以修改为使用SGI STL新实现的分配器。 \n Gnu的分配器为了实现节省内存，他需要减少malloc的次数，所以设计了16条链表，每条链表负责不同大小的区块，第0条链表负责的是8字节大小区块，第一条负责16字节大小的区块，以此类推....所以在容器需要内存的时候，内存中元素的大小会被分配器调整到8的倍数，然后再具体确定选择哪一条链表。 \n \n G4.9版使用的分配器（又换回以前开销大的了） \n \n 但G4.9所附带的标准库，有许多extenion allocators，其中__pool_alloc 就是G2.9的alloc，我们仍然可以使用它。 \n \n 在G4.9中，我们像右上角那样设置分配器即可使用这个更优秀的分配器，e.g. \n vector < string ,  __gun_cxx :: __pool_alloc < string >>  vec ; \n \n 亲测，本人用的g++8.1.0中，使用的默认分配器仍然是较差的那个；不过也仍有__pool_alloc这个分配器，用法相同，其在编译器中的路径如下 \n \n \n 侯捷老师原话：他为什么要换回这个较差的分配器，我没办法给他找理由，他们也没有出来解释说明。 \n \n 但是std::allocator从c++20起就正式废除了。 \n 5.2 容器之间的实现关系与分类 \n 5.3 容器list \n list容器本身的实现 \n 这是核心 \n \n list的迭代器（iterator）实现 \n \n 注意前置++与后置++的区别 \n 前置++ (prefix form) ：前置++返回原来对象的引用 \n self &   operator ++ ( )   { \n    node  =   ( link_type )   ( ( * node ) . next ) ;   return   * this ; \n } \n \n 后置++ (post form) : 后置++返回对象 \n slef  operator ++ ( int )   { \n    self tmp  =   * this ;   ++ * this ;   return  tmp ; \n } \n \n 后置自增会调用重载的前置自增来实现，其调用过程图解如下： \n \n 泛化指针在其内部重载操作符++，用于从节点内部跳转到下一个节点而不是单纯自增地址。 \n list的迭代器中还实现了*和->的重载 \n \n 下面是一个测试，直接返回一个对象，而函数返回值设置为引用，那么可以得到该对象的引用。 \ninclude   <iostream> \n using   namespace  std ; \n\n class   CC   { \n public : \n     int  data ; \n     CC ( )   :   data ( 10 )   { } ; \n     int &   get ( )   { \n         return   this -> data ; \n     } \n } ; \n\n int   main ( )   { \n    CC c ; \n     int &  tmp  =  c . get ( ) ;   // 此处tmp的类型为整型的引用 \n    cout  <<  c . data  <<  endl ; \n    tmp  =   10 ; \n    cout  <<  tmp ; \n     return   0 ; \n } \n输出结果为\n 1 \n 10 \n \n G4.9版本就有了很多改进 \n \n G4.9版本的list容器设计如下： \n \n begin() 指向第一个节点， end() 指向最后一个节点的下一块（前闭后开） \n 5.4 迭代器的设计原则和Iterator Traits的作用与设计 \n iterator本质是个结构体，但是其 \n \n Iterator的设计原则： \n \n iterators必须有回答 algorithms 的能力 \n \n 目前C++的iterator必须提出五种 associated types \n \n iterator_category \n difference_type \n value_type \n reference \n pointer \n \n 如下： \n \n'},{title:"计算机网络",frontmatter:{},regularPath:"/cs-basis/4_ComputerNetwork.html",relativePath:"cs-basis/4_ComputerNetwork.md",key:"v-ddd4c684",path:"/cs-basis/4_ComputerNetwork.html",headers:[{level:2,title:"常见面试题",slug:"常见面试题"},{level:3,title:"HTTP/1.1如何优化",slug:"http-1-1如何优化"},{level:3,title:"HTTPS RSA握手解析",slug:"https-rsa握手解析"},{level:3,title:"RSA的原理",slug:"rsa的原理"},{level:3,title:"IGMP总结",slug:"igmp总结"},{level:3,title:"路由算法与路由协议",slug:"路由算法与路由协议"}],content:" 计算机网络 \n 常见面试题 \n HTTP/1.1如何优化 \n 见  小林coding \n 三个方向进行优化 \n \n 避免发送请求：使用缓存（etag，及modified时间） \n 减少发送请求\n \n 减少重定向：重定向工作交给代理服务器完成，减少发送请求的次数 \n 合并请求：将多个请求小文件的请求合并成一个请求，减少了重复发送的请求头 \n 延迟发送请求 \n \n \n 缩小发送报文长度\n \n 无损压缩 \n 有损压缩 \n \n \n \n 总结： \n 主要从 3 个方面优化 HTTP/1.1 协议。 \n 第一个思路是，通过缓存技术来避免发送 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。 \n 第二个思路是，减少 HTTP 请求的次数，有以下的方法： \n \n 将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数； \n 将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗； \n 按需访问资源，只访问当前用户看得到/用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。 \n \n 第三思路是，通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。 \n 不管怎么优化 HTTP/1.1 协议都是有限的，不然也不会出现 HTTP/2 和 HTTP/3 协议。 \n HTTPS RSA握手解析 \n SSL/TLS 协议基本流程： \n \n 客户端向服务器索要并验证服务器的公钥。 \n 双方协商生产「会话秘钥」。 \n 双方采用「会话秘钥」进行加密通信。 \n \n 前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。 \n RSA的原理 \n IGMP总结 \n IGMP全称Internet Group Management Protocol，中文为网络组管理报文。是用于管理组播成员的协议。它有v1、v2、v3三个版本。 \n \n v1版本： 普遍组查询报文 （发224.0.0.1来查询在网络中有哪些组播组）、 成员报告报文 。没有离开信息，路由器感知不到成员离开，只有在查询报文发出后130s内未收到成员报告报文则会删除该组播组，在这130s内路由器仍会转发发往该组播组的数据造成流量浪费。 \n v2版本：加入了 离开组报文 ，同时查询报文进一步划分为 特定组查询 和普遍组查询。离开组报文是由该组的最后一个成员发送给224.0.0.2(代表网络中所有组播路由器)，内容是该组播地址，IGMP 路由器收到后会发送一个特定组查询报文来询问网络中是否还有该组播地址，如果没有回应就会把这个组从IGMP table中删除 \n v3版本：新加入  Group-and-Source-Specific Query ,该类型为IGMPv3中新增加的，用于查询接口下是否有成员需要接收指定源列表中的源所发出的特定组的多播流。 也就是说，相比于v1/v2，v3的组播成员可以指定多播源来接收其数据，而不用全部接收来自多播组的流量，这一做法在多个多播源公用一个多播组的情况下可以极大节省资源。 \n 路由算法与路由协议 \n 核心：每个路由器中都有一个路由表，其表项如下： \n \n 目的网络IP地址、子网掩码、下一跳IP地址、接口 \n \n \n 路由算法分类 ：静态路由算法（非自适应路由算法）、动态路由算法（自适应路由算法） \n \n"},{title:"C++",frontmatter:{},regularPath:"/cs-basis/1_C++.html",relativePath:"cs-basis/1_C++.md",key:"v-5ab67464",path:"/cs-basis/1_C++.html",headers:[{level:2,title:"C++基础",slug:"c-基础"},{level:3,title:"前置知识",slug:"前置知识"},{level:3,title:"1 内存分区模型",slug:"_1-内存分区模型"},{level:3,title:"2 C++中的引用",slug:"_2-c-中的引用"},{level:3,title:"3 面向对象",slug:"_3-面向对象"},{level:4,title:"3.1 封装",slug:"_3-1-封装"},{level:4,title:"3.2 对象的初始化和清理",slug:"_3-2-对象的初始化和清理"},{level:4,title:"",slug:""},{level:4,title:"3.4 友元",slug:"_3-4-友元"},{level:4,title:"3.5 运算符重载",slug:"_3-5-运算符重载"},{level:4,title:"3.6 继承",slug:"_3-6-继承"},{level:4,title:"3.7 多态",slug:"_3-7-多态"},{level:3,title:"4 函数提高",slug:"_4-函数提高"},{level:4,title:"4.1 函数默认参数",slug:"_4-1-函数默认参数"},{level:4,title:"4.2 函数的占位参数",slug:"_4-2-函数的占位参数"},{level:4,title:"4.3 函数重载",slug:"_4-3-函数重载"},{level:2,title:"C++Primer部分内容",slug:"c-primer部分内容"},{level:3,title:"5 顺序容器",slug:"_5-顺序容器"},{level:4,title:"5.1 额外的string操作",slug:"_5-1-额外的string操作"},{level:3,title:"IO库",slug:"io库"},{level:2,title:"补充",slug:"补充"},{level:3,title:"关于extern关键字",slug:"关于extern关键字"}],content:' C++ \n C++基础 \n 前置知识 \n 编译过程 \n \n 1.预处理命令(Preprocessing) \n ==将.cpp文件转化为.i文件== \n 预处理器cpp命令：cpp  - o test . i test . cpp\ngcc / g ++ 命令： gcc  - E test . c  - o test . i\n \n \n 这一步预处理把所有include的文件（包括递归包含的文件）的内容都展开到输出文件中，并展开了所有的宏定义。 \n \n 对于其中的伪指令（以#开头的指令）和特殊符号进行处理。 \n 伪指令主要包括以下四个方面： \n 1)宏定义指令，如  #define Name TokenString #undef  等 \n 对于一个伪指令，预编译所要做的事情就是将程序中的所有Name用TokenString替换，但是作为字符串常量的Name则不被替换。对于后者，则将取消对某个宏的定义，使得以后该串再次出现时不会被替换。 \n 2)条件编译指令， \n 2. 编译(Compilation) \n ==将.cpp/.h文件转换成.s文件== \n 编译命令cc :  cc test . i  - o test . s\ngcc / g ++ 命令 :  gcc  - S test . i  - o test . s\n \n 编译的过程将预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化集成相应的汇编代码。在这一步中一般会进行优化，比如去除没有用到的类的声明，循环语句的优化等。 \n 3.汇编(Assemble) \n ==将.s文件转化成.o文件== \n 汇编命令 :  as test . s  - o test . o\ngcc / g ++ :  gcc  - c test . s  - o test . o\n \n as汇编器，会把汇编代码转换成机器指令，并以特定二进制格式输出保存在目标文件中。 \n 4.链接(Linking) \n ==将.o文件转化成可执行程序== \n 链接命令ld :  ld test . o  - o test\ngcc / g ++ 命令 :  gcc test . c\n \n ld链接器，把程序的相关目标文件组合链接在一起，生成程序的可执行映像文件，该文件还不能直接执行，还有很多问题需要解决。 \n 第一步要解决的问题是：可能调用到了库函数，或者目标文件中调用到了另外一个源文件中定义的某个符号（如变量或者函数调用等），需要通过链接器建立对应的关系，使得程序能够正常的执行。 \n 链接方式 \n 1. 静态链接： \n 将源代码从静态库中拷贝到最终的可执行程序中。这样可能会导致最终的目标文件很大。 \n 2. 动态链接： \n 需要调用的库函数以动态链接库的形式存在，多个进程之间共享。而链接的时候只需要直到调用的函数的位置即可。在程序执行时，当需要调用某个动态链接库中的函数时，操作系统首先会查找所有正在运行的程序，看内存中是否已经有该函数的拷贝了。如果用，则多个进程共享该拷贝。否则才会将其载入到该进程的虚拟内存中。 \n 1 内存分区模型 \n  \n C++程序执行时，将内存分为 4个区域 \n \n 代码区：存放函数体的二进制代码，由操作系统进行管理。（函数定义类定义等逻辑二进制代码在代码区） \n 常量区：存放常量字符串，程序结束后由系统释放。 \n 全局区：存放全局数据、静态变量 和 常量（上图全局区为静态全局区）bss和data \n 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收 \n 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等 \n \n  \n placement new：分配内存时，先将内存分配出来，再在这个地址的某一个地方对它进行分配 \n 1.1 程序执行前 \n 在程序编译后，生成了exe可执行程序，未执行程序前分为两个区域 \n 代码区： \n ​\t\t存放CPU执行的机器指令 \n ​\t\t代码区是 共享 的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。 \n ​\t\t代码区是 只读 的，使其只读的原因是防止程序意外地修改了它的指令。 \n 全局区： \n ​\t\t全局变量和静态变量存放于此。 \n ​\t\t全局区还包含了常量区，字符串常量和其它常量都存放于此。 \n ​\t\t该区域的数据在程序结束后由操作系统释放。 \ninclude   <iostream> \n using   namespace  std ; \n\n //全局变量 \n int  g_a  =   10 ; \n int  g_b  =   10 ; \n\n //全局常量 \n const   int  c_g_a  =   10 ; \n\n int   main ( )   { \n     //全局区 \n     //全局变量，静态变量，常量 \n\n     //创建局部变量, 只要在函数体内声明的非常量、非静态变量均为局部变量（const修饰的局部常量也是局部变量 \n     int  a  =   10 ; \n     int  b  =   10 ; \n\n    cout  <<   "局部变量a的地址："   <<   & a  <<  endl ; \n    cout  <<   "局部变量b的地址："   <<   & b  <<  endl ; \n    cout  <<   "全局变量g_a的地址："   <<   & g_a  <<  endl ; \n    cout  <<   "全局变量g_b的地址："   <<   & g_b  <<  endl ; \n\n     //创建静态变量 普通变量前加上static均为静态变量 \n     static   int  s_a  =   10 ; \n     static   int  s_b  =   10 ; \n    cout  <<   "静态变量s_a的地址："   <<   & s_a  <<  endl ; \n    cout  <<   "静态变量s_b的地址："   <<   & s_b  <<  endl ; \n\n     //常量  \n     //字符串常量，""括起来的就是字符串常量 \n    cout  <<   "字符串常量\\"hello world\\"的地址："   <<   & "hello world"   <<  endl ; \n     //const修饰变量 \n     //const修饰的全局常量 \n    cout  <<   "const修饰全局常量c_g_a的地址："   <<   & c_g_a  <<  endl ; \n     //const修饰的局部常量 \n     const   int  c_a  =   10 ; \n    cout  <<   "const修饰局部常量c_a的地址："   <<   & c_a  <<  endl ; \n     return   0 ; \n } \n \n 栈区： \n 由编译器自动分配释放，存放函数的参数值，局部变量等 \n 栈区注意事项： \n \n \n 函数中一般不要返回局部变量地址 \ninclude   <iostream> \n using   namespace  std ; \n\n int   * func ( )   { \n     int  a  =   10 ;   //局部变量，存放于栈区，在函数结束后被系统自动回收 \n     return   & a ;   //返回局部变量地址 \n } \n\n int   main ( )   { \n     int   * p  =   func ( ) ; \n    cout  <<   * p  <<  endl ;   // 有些编译器第一次可以输出正常数字，是因为编译器做了保留 \n    cout  <<   * p  <<  endl ;   // 第二次这个数据就不再保留了 \n     return   0 ; \n } \n \n \n \n 堆区： \n ​\t\t全局变量在堆区，且默认初始化为0 \n ​\t\tC++中主要用new来开辟空间： \ninclude   <iostream> \n using   namespace  std ; \n\n int   * func ( )   { \n     //利用new关键字将数据开辟到堆区 \n     //指针p本质上也是局部变量，放在栈上，指针保存的数据存放于堆上 \n     int   * p  =   new   int ( 10 ) ; \n     return  p ; \n } \n\n void   test01 ( )   { \n     int   * p  =   func ( ) ; \n    cout  <<   * p  <<  endl ; \n    cout  <<   * p  <<  endl ; \n     delete  p ; \n     //cout << *p << endl; //内存已被释放，再次访问是非法操作，会报错或乱码 \n } \n\n void   test02 ( )   { \n     int   * arr  =   new   int [ 10 ] ; \n     for   ( int  i  =   0 ;  i  <   10 ;  i ++ )   { \n        arr [ i ]   =  i  +   100 ; \n     } \n     for   ( int  i  =   0 ;  i  <   10 ;  i ++ )   { \n        cout  <<  arr [ i ]   <<  endl ; \n     } \n     delete   [ ]  arr ; \n } \n\n int   main ( )   { \n     //test01(); \n     test02 ( ) ; \n     return   0 ; \n } \n 2 C++中的引用 \n 基本语法： 数据类型 &别名 = 原名 \ninclude   <iostream> \n using   namespace  std ; \n\n int   main ( )   { \n     int  a  =   10 ; \n     int   & b  =  a ; \n    cout  <<   "a = "   <<  a  <<  endl ; \n    cout  <<   "b = "   <<  b  <<  endl ; \n    cout  <<   "&a = "   <<   & a  <<  endl ; \n    cout  <<   "&b = "   <<   & b  <<  endl ; \n\n    b  =   100 ; \n    cout  <<   "a = "   <<  a  <<  endl ; \n    cout  <<   "b = "   <<  b  <<  endl ; \n     return   0 ; \n } \n \n 注意事项： \n \n 引用必须初始化 \n 引用一旦初始化，就不可以修改 \ninclude   <iostream> \n using   namespace  std ; \n\n int   main ( )   { \n     int  a  =   10 ; \n     //1.引用必须初始化 \n     //int &b; \n     int   & b  =  a ; \n    \n     //2.引用初始化后，不可以改变 \n     int  c  =   20 ; \n    b  =  c ;   //赋值操作，而不是更改引用 \n\n    cout  <<   "a = "   <<  a  <<  endl ; \n    cout  <<   "b = "   <<  b  <<  endl ; \n    cout  <<   "c = "   <<  c  <<  endl ; \n     return   0 ; \n } \n \n 引用做函数参数: \ninclude   <iostream> \n using   namespace  std ; \n\n //交换函数 \n\n //1.值传递(不成功) \n void   swap1 ( int  a ,   int  b )   { \n     int  temp  =  a ; \n    a  =  b ; \n    b  =  temp ; \n } \n\n //2.地址传递(成功) \n void   swap2 ( int   * a ,   int   * b )   { \n     int  temp  =   * a ; \n     * a  =   * b ; \n     * b  =  temp ; \n } \n\n //3.引用传递(成功) \n void   swap3 ( int   & a ,   int   & b )   { \n     int  temp  =  a ; \n    a  =  b ; \n    b  =  temp ; \n } \n\n int   main ( )   { \n     int  a  =   10 ,  b  =   20 ; \n     swap1 ( a ,  b ) ; \n    cout  <<   "值传递："   <<  endl ; \n    cout  <<   "a = "   <<  a  <<  endl ; \n    cout  <<   "b = "   <<  b  <<  endl ; \n\n    a  =   10 ,  b  =   20 ; \n     swap2 ( & a ,   & b ) ; \n    cout  <<   "地址传递："   <<  endl ; \n    cout  <<   "a = "   <<  a  <<  endl ; \n    cout  <<   "b = "   <<  b  <<  endl ; \n\n    a  =   10 ,  b  =   20 ; \n     swap3 ( a ,  b ) ; \n    cout  <<   "引用传递："   <<  endl ; \n    cout  <<   "a = "   <<  a  <<  endl ; \n    cout  <<   "b = "   <<  b  <<  endl ; \n     return   0 ; \n } \n \n 引用作为函数的返回值： \n \n 不要返回局部变量的引用 \n 函数的调用可以作为左值 \ninclude   <iostream> \n using   namespace  std ; \n\n //引用作为函数的返回值 \n\n //1.不要返回局部变量的引用 \n // int& test01() { \n //     int a = 10; //局部变量存放于栈区 \n //     return a; \n // } \n\n //2.函数的调用可以作为左值 \n int &   test02 ( )   { \n     static   int  a  =   10 ;   //静态变量，存放于全局区，全局区的数据程序执行结束后系统释放 \n     return  a ; \n } \n\n int   main ( )   { \n     //int &ref = test01(); \n     //cout << "ref = " << ref << endl; //非法操作有的编译器第一次会做保留 \n     //cout << "ref = " << ref << endl; //第一次保留的编译器第二次会释放 \n     int   & ref2  =   test02 ( ) ; \n    cout  <<   "ref2 = "   <<  ref2  <<  endl ; \n    cout  <<   "ref2 = "   <<  ref2  <<  endl  <<  endl ; \n\n     //返回值为引用的函数，函数调用可作为左值 \n     test02 ( )   =   1000 ; \n\n    cout  <<   "ref2 = "   <<  ref2  <<  endl ; \n    cout  <<   "ref2 = "   <<  ref2  <<  endl ; \n     return   0 ; \n } \n \n 引用的本质： \n 本质： 引用的本质在C++内部实现是一个指针常量 \n 指针常量就是指针指向的地址不变 \n 常量指针就是指针指向的地址存的值不变 \n int* const ref = &a; \n \n 常量引用 \n 作用： 用来修饰形参，防止误操作 \ninclude   <iostream> \n using   namespace  std ; \n\n //常量引用 \n //使用场景：用来修饰形参，防止误操作 \n\n void   showValue ( const   int   & val )   { \n     //val = 1000;//不允许修改 \n    cout  <<   "val = "   <<  val  <<  endl ; \n } \n int   main ( )   { \n     //int a = 10; \n     //加上cosnt之后 编译器将代码修改 int temp = 10; const int &ref = temp; \n     //const int &ref = 10; //引用必须引用一块合法的内存空间 \n     //ref = 20;//加入const之后只读不允许修改 \n     int  a  =   100 ; \n     showValue ( a ) ; \n     return   0 ; \n } \n 3 面向对象 \n 3.1 封装 \n 访问权限 \n 公共权限 public\t\t成员 类内可以访问 类外可以访问 \n 保护权限 protected 成员 类内可以访问 类外不可访问 儿子可以访问父亲中的保护内容 \n 私有权限 private\t  成员 类内可以访问 类外不可访问 儿子不可以访问父亲中的私有内容 \ninclude   <iostream> \ninclude   <string> \n using   namespace  std ; \n\n class   Person   { \n public : \n    string m_name ; \n\n protected : \n    string m_Car ; \n\n private : \n     int  m_passwd ; \n\n public : \n     void   func ( )   { \n        m_name  =   "张三" ; \n        m_Car  =   "拖拉机" ; \n        m_passwd  =   123456 ; \n     } \n } ; \n\n int   main ( )   { \n    Person p1 ; \n    p1 . m_name  =   "李四" ; \n     //p1.m_Car = "法拉利"; //类外不可访问 \n     //p1.m_passwd = "654321"; //类外不可访问 \n     return   0 ; \n } \n \n struct与class区别 \n struct默认权限是公共 \n class默认权限是私有 \n 成员属性设置为私有优缺点 \n **优点1：**可以自己控制读写权限 \n **优点2：**对于写权限，可以检测数据的有效性 \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n public : \n     //姓名 可读可写 \n     void   setName ( string name )   { //设置姓名接口 \n        m_Name  =  name ; \n     } \n    string  getName ( )   { //获取姓名 \n         return  m_Name ; \n     } \n\n     //年龄 可读可写 写需限制有效性 \n     void   setAge ( int  age )   { \n         if   ( age  <   0   ||  age  >   150 )   { \n            m_Age  =   0 ; \n            cout  <<   "您设置的年龄不合法，请重新设置！"   <<  endl ; \n             return ; \n         } \n        m_Age  =  age ; \n     } \n     int   getAge ( )   {   //获取年龄 \n         return  m_Age ; \n     } \n\n     //情人只写 \n     void   setLover ( string lover )   {   //设置Lover \n        m_Lover  =  lover ; \n     } \n\n private : \n    string m_Name ;   //姓名 可读可写 \n     int  m_Age  =   0 ;   //年龄 可读可写 写需限制有效性 \n    string m_Lover ;   //只写 \n } ; \n\n int   main ( )   { \n    Person p ; \n    p . setName ( "张三" ) ; \n    cout  <<   "张三的姓名为："   <<  p . getName ( )   <<  endl ; \n    p . setAge ( 100 ) ; \n    cout  <<   "张三的年龄为："   <<  p . getAge ( )   <<  endl ; \n    p . setLover ( "仓井" ) ;   //情人不可被别人获取 \n     system ( "pause" ) ; \n     return   0 ; \n } \n 3.2 对象的初始化和清理 \n 3.2.1构造函数和析构函数 \n \n 构造函数：创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。 \n 析构函数：对象销毁前系统自动调用，执行清理工作。 \n 构造函数与析构函数都是必须有的，如果代码中没有，那么编译器会自动提供一个空的构造和析构。 \n \n 构造函数语法： 类名(){} \n 1.构造函数没有返回值也不写void \n 2.函数名称与类名相同 \n 3.构造函数可以有参数，因此可以发生重载 \n 4.程序在调用对象时会自动构造，无需手动调用，而且只会调用一次。 \n 析构函数语法： ~类名(){} \n 1.构造函数没有返回值也不写void \n 2.函数名称与类名相同，在名称前加上~ \n 3.构造函数不可以有参数，因此不可以发生重载 \n 4.程序在调用对象销毁前会自动析构，无需手动调用，而且只会调用一次。 \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n\n public : \n     Person ( )   { \n        cout  <<   "Person函数调用"   <<  endl ; \n     } \n     ~ Person ( )   { \n        cout  <<   "Person析构函数调用"   <<  endl ; \n     } \n } ; \n\n void   test01 ( )   { \n    Person p ; //栈上的数据，test01()执行完毕后，释放这个对象 \n } \n\n int   main ( )   { \n     test01 ( ) ; \n    Person p ; //在整个程序结束时会自动销毁，所以程序结束才会调用析构函数 \n     system ( "pause" ) ; \n     return   0 ; \n } \n /*\n运行结果：\nPerson函数调用\nPerson析构函数调用\nPerson函数调用\n请按任意键继续. . . \nPerson析构函数调用\n*/ \n \n 3.2.2构造函数的分类及调用 \n 两种分类方式 \n ​\t\t按参数分为：有参数构造和无参构造（无参也叫默认构造函数） \n ​\t\t按类型分为：普通构造和拷贝构造 \n 三种调用方式 \n ​\t\t括号法 \n ​\t\t\t\t注意事项：调用默认构造函数时不要加() \n ​\t\t\t\tPerson p1(); // 不会创建对象，编译器会认为其为一个函数的声明，不会认为是对象 \n ​\t\t显示法 \n Person p1 ; \nPerson p2  =   Person ( 10 ) ; \nPerson p3  =   p2 ( p3 ) ; \n\n Person ( 10 ) ;   //匿名对象，特点：当前执行结束后，系统会立即回收掉匿名对象 \ncout  <<   "aaaa"   <<  endl ; \n\n //注意事项2：不要利用拷贝构造函数初始化匿名对象 编译器会认为 Person (p3) == Perosn p3; \n Person ( p3 ) ;   //报错显示"Person p3"重定义，编译器认为是一个声明语句 \n \n ​\t\t隐式转换法 \n Person p4  =   10 ;   //相当于 写了 Person p4 = Person(10); //有参构造 \nPerson p5  =  p4 ;   //拷贝构造 \n //仅能调用只有一个参数的拷贝构造函数 \n \n ​ \n 3.2.3构造函数的调用时机 \n 三种情况 \n \n 使用一个已经创建完毕的对象来初始化一个新对象 \n 值传递的方式给函数参数传值 \n 以值返回局部对象（注意第三种受编译器影响各不相同） \n \n （值传递的本质上拷贝出一个临时副本） \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n\n private : \n     int  m_Age ; \n public : \n     Person ( )   { \n        cout  <<   "Person的默认构造函数参数"   <<  endl ; \n     } \n     ~ Person ( )   { \n        cout  <<   "Person的析构函数调用"   <<  endl ; \n     } \n     Person ( int  Age )   { \n        cout  <<   "Person的有参构造函数参数"   <<  endl ; \n        m_Age  =  Age ; \n     } \n     Person ( const  Person  & p )   { \n        cout  <<   "Person的拷贝构造函数参数"   <<  endl ; \n        m_Age  =  p . m_Age ; \n     } \n } ; \n //1.使用一个已经创建完毕的对象来初始化一个新对象 \n void   test01 ( )   { \n    Person  p1 ( 20 ) ; \n    Person  p2 ( p1 ) ; \n } \n\n //2.值传递的方式给函数参数传值 \n void   doWork ( Person p )   { \n\n } \n\n void   test02 ( )   { \n    Person p ; \n     doWork ( p ) ; //值传递的本质上拷贝出一个临时副本,所以传值时会调用拷贝构造函数 \n } \n\n //3.以值返回局部对象 \n //第三点根据编译器不同会发生变化 \nPerson  doWork2 ( )   { \n    Person p1 ; \n    cout  <<   ( int * ) & p1  <<  endl ; \n     return  p1 ; //返回是返回的值，而不是p1这个局部对象本体,它会拷贝一个新的对象返回 \n } \n\n void   test03 ( )   { \n    Person p  =   doWork2 ( ) ; \n    cout  <<   ( int * ) & p  <<  endl ; \n } \n\n int   main ( )   { \n     //test01(); \n     //test02(); \n     test03 ( ) ; \n     return   0 ; \n } \n \n 3.2.4构造函数调用规则 \n 默认情况下，C++编译器至少给一个类添加3个函数 \n \n 默认构造函数（无参，函数体为空） \n 默认析构函数（无参，函数体为空） \n 默认拷贝构造函数，对属性进行 值拷贝 \n \n 构造函数调用规则如下： \n \n 如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造(值拷贝) \n 如果用户定义拷贝构造函数，C++不会再提供其他默认构造函数 \n \n \n 示例： \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n\n public : \n     int  m_Age ; \n     // Person() { \n     //     cout << "Person的默认构造函数" << endl; \n     // } \n     // Person (int age) { \n     //     cout << "Person的有参构造函数调用" << endl; \n     //     m_Age = age; \n     // } \n     Person   ( const  Person  & p )   { \n        cout  <<   "Person的拷贝构造函数调用"   <<  endl ; \n        m_Age  =  p . m_Age ; \n     } \n     ~ Person ( ) { \n        cout  <<   "Person的析构函数调用"   <<  endl ; \n     } \n } ; \n\n // void test01() { \n //     Person p; \n //     p.m_Age = 18; \n //     Person p2(p); \n //     cout << "p2的年龄为：" << p2.m_Age << endl; \n // } \n\n // void test02() { \n //     Person p(28); \n //     Person p2(p); \n //     cout << "p2的年龄为：" << p2.m_Age << endl; \n // } \n\n void   test03 ( )   { \n    Person p ; //仅写拷贝构造函数时会显示不存在默认拷贝构造函数 \n } \n\n int   main ( )   { \n     // test01(); \n     // test02(); \n     system ( "pause" ) ; \n     return   0 ; \n } \n \n 3.2.5深拷贝与浅拷贝 \n 浅拷贝：简单赋值拷贝操作 \n 深拷贝：在堆区重新申请空间，进行拷贝操作 \ninclude   <iostream> \n using   namespace  std ; \n\n //深拷贝浅拷贝 \n class   Person   { \n public : \n     int  m_Age ; \n     int   * m_Height ; \n     Person ( )   { \n        cout  <<   "Person的默认构造函数调用"   <<  endl ; \n     } \n     Person ( int  age ,   int  height )   { \n        m_Age  =  age ; \n        m_Height  =   new   int ( height ) ; \n        cout  <<   "Person的有参构造函数调用"   <<  endl ; \n     } \n     //浅拷贝赋值，导致指针指向同一地址，析构时会出现重复释放 \n     Person ( const  Person  & p )   {   //若自己不定义，那么系统会提供一个浅拷贝构造函数 \n        m_Age  =  p . m_Age ; \n         //m_Height = p.m_Height; //编译器默认实现的是这行代码 \n         //深拷贝 \n        m_Height  =   new   int ( * p . m_Height ) ; \n        cout  <<   "Person的拷贝构造建函数调用"   <<  endl ; \n     } \n\n     ~ Person ( )   { \n         //析构函数，释放在堆区开辟的内存 \n         if   ( m_Height  !=   nullptr )   { \n             delete  m_Height ; \n         } \n        cout  <<   "Person的析构函数调用"   <<  endl ; \n     } \n } ; \n\n void   test01 ( )   { \n    Person  p1 ( 18 ,   181 ) ; \n    cout  <<   "p1的年龄为："   <<  p1 . m_Age  <<   "身高为："   <<   * ( p1 . m_Height )   <<  endl ; \n    Person  p2 ( p1 ) ; \n    cout  <<   "p2的年龄为："   <<  p2 . m_Age  <<   "身高为："   <<   * ( p2 . m_Height )   <<  endl ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n \n 总结：如果属性有在堆区开辟，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题。 \n \n 3.2.6初始化列表 \n **作用：**C++提供了初始化列表语法，用来初始化属性。 \n 语法： 构造函数(): 属性1(值1), 属性2(值2), ... {} \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n public : \n     // 传统的有参构造函数 \n     // Person (int a, int b, int c) { \n     //     m_A = a; \n     //     m_B = b; \n     //     m_C = c; \n     // } \n\n     //初始化列表初始化属性 \n     // Person(): m_A(10), m_B(20), m_C(30){ \n\n     // } \n     //也可以 \n     Person ( int  a ,   int  b ,   int  c ) :   m_A ( a ) ,   m_B ( b ) ,   m_C ( c )   { \n\n     } \n     void   printPerson ( )   { \n        cout  <<   "p.m_A = "   <<  m_A  <<  endl ; \n    \tcout  <<   "p.m_B = "   <<  m_B  <<  endl ; \n    \tcout  <<   "p.m_C = "   <<  m_C  <<  endl ; \n     } \n    \n private : \n     int  m_A ; \n     int  m_B ; \n     int  m_C ; \n } ; \n\n void   test01 ( )   { \n     // Person p(10, 20, 30); \n     // Person p; \n    Person  p ( 30 ,   20 ,   10 ) ; \n    p . printPerson ( ) ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n 3.2.7类对象作为类成员 \n C++类中的成员可以是另一个类的对象，我们称该成员为对象成员。 \n 例如： \n class   A   { } ; \n class   B   { \n    A a ; \n } ; \n \n B类中有对象A作为成员，A为对象成员。 \ninclude   <iostream> \n using   namespace  std ; \n\n class   Phone   { \n public : \n     Phone ( string pName )   { \n        m_pName  =  pName ; \n        cout  <<   "Phone构造函数调用"   <<  endl ; \n     } \n     ~ Phone ( )   { \n        cout  <<   "Phone析构函数调用"   <<  endl ; \n     } \n    string m_pName ; \n } ; \n\n class   Person   { \n public : \n     //Phone m_Phone = pName; //隐式转换法 \n     Person ( string name ,  string pName ) :   m_Name ( name ) ,   m_Phone ( pName ) { \n        cout  <<   "Person构造函数调用"   <<  endl ; \n     } \n     ~ Person ( )   { \n        cout  <<   "Person析构函数调用"   <<  endl ; \n     } \n    string m_Name ; \n    Phone m_Phone ; \n } ; \n //当其他类对象作为本类成员，先构造其他类对象，再构造自身 \n void   test01 ( )   { \n    Person  p ( "张三" ,   "苹果MAX" ) ; \n    cout  <<  p . m_Name  <<   "拿着"   <<  p . m_Phone . m_pName  <<  endl ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n 那么当创建B对象时，A与B的构造和析构顺序是谁先谁后？ \n **答：**先构造成员类，再构造自身；先析构自身，再析构成员类。先制造零件，再组装机器人；先拆解机器人，再烧毁零件。 \n 3.2.8静态成员 \n 静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员，注意静态成员也有访问权限 \n 静态成员分为： \n \n 静态成员变量\n \n 所有对象共享同一份数据 \n 在编译阶段分配内存 \n 类内声明，类外初始化 \n \n \n 静态成员函数\n \n 所有对象共享一个函数 \n 静态成员函数只能访问静态变量 \n \n \n \n **示例：**静态成员变量和静态成员函数 \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n public : \n     static   int  m ; \n     static   void   func ( )   { \n        cout  <<   "静态成员变量 m = "   <<  m  <<  endl ; \n        cout  <<   "静态成员函数func调用"   <<  endl ; \n        m ++ ; \n     } \n\n private : \n     static   void   func2 ( )   {   //静态成员函数也有权限 \n\n     } \n } ; \n //静态成员变量类内声明，类外初始化 \n int  Person :: m  =   0 ; \n\n //静态成员函数不需要创建对象也可以访问 \n //静态成员函数，不可以访问非静态成员变量 \n void   test01 ( )   {  \n     Person :: func ( ) ; \n     Person :: func ( ) ; \n     //Person::func2(); //类外访问不到私有成员函数 \n } \n\n void   test02 ( )   { \n    Person p1 ; \n    Person p2 ; \n    Person :: m ++ ; \n    cout  <<   "m = "   <<  p1 . m  <<  endl ; \n    p1 . m ++ ; \n    cout  <<   "m = "   <<  p2 . m  <<  endl ; \n\n } \n\n int   main ( )   { \n     test01 ( ) ; \n     test02 ( ) ; \n     return   0 ; \n } \n \n \n 静态函数只能访问静态成员，静态成员不需要创建对象也可以被使用 \n  \n 3.3 C++对象模型和this指针 \n 3.3.1 成员变量和成员函数分开存储 \n 在C++中，类内的成员变量和成员函数分开存储。 \n 总结： 只有 非静态成员变量 才属于类的对象上 \ninclude   <iostream> \n using   namespace  std ; \n\n //成员变量 和 成员函数 是 分开存储的 \n class   Person   { \n     int  m_A ;   // 非静态成员变量 属于类的对象上 \n     long  m_B ; \n     long   long  m_C ; \n     static   int  b ;   //静态成员变量 不属于类的对象上 \n     void   func ( )   { }   // 非静态成员函数 不属于类对象上 \n     static   void   func2 ( )   { }   //静态成员函数 不属于类的对象上 \n } ;  \n\n\n //空对象占用的内存空间字节为： 1 \n //C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置 \n //每个空对象也应该有一个独一无二的内存地址 \n void   test01 ( )   { \n    Person p ; \n    cout  <<   "size of p = "   <<   sizeof ( p )   <<  endl ; \n } \n\n //若对象非空，则按照占内存最大的非静态成员变量的字节大小来分配内存 \n void   test02 ( )   { \n    Person p ; \n    cout  <<   "size of p = "   <<   sizeof ( p )   <<  endl ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     test02 ( ) ; \n     return   0 ; \n } \n \n C++类满足内存对齐。 \n 3.3.2 this指针的用途 \n 通过上一节得知，C++中成员变量和成员函数分开存储 \n 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用同一块代码 \n 那么问题是：这一块代码是如何区分那个对象调用自己的呢？ \n C++通过提供特殊的对象指针，this指针，解决上述问题。 this指针指向被调用的成员函数所属的对象 \n this指针是隐含每一个非静态成员函数内的一种指针 \n this指针不需要定义，直接使用即可。 \n this指针的用途： \n \n 当形参和成员变量同名时，可用this指针来区分 \n 在类的非静态成员函数中返回对象本身，可使用 return *this \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n public : \n     Person   ( int  age )   {  \n         // this指针指向被调用的成员函数所属的对象 \n         this -> age  =  age ;   //解决名称冲突 \n     } \n     void   PersonAddAge ( Person  & p )   { \n         this -> age  +=  p . age ; \n     } \n\n     //链式编程思想 \n     //cout与cin也是如此 \n     //如果需要返回本体，那么需要使用引用来返回 \n     //如果返回类型为Person（即值返回），则会按值拷贝构造一个新对象，最终原对象只加了一次 \n    Person &   PersonAddAgeN ( Person  & p )   {  \n         this -> age  +=  p . age ; \n         //this是一个指向p2的指针，*this则是p2这个对象本身（的地址） \n         return   * this ; \n     } \n\n     int  age ; \n } ; \n\n //1.解决名称冲突 \n void   test01 ( )   { \n    Person  p1 ( 18 ) ; \n    cout  <<   "p1的年龄为："   <<  p1 . age  <<  endl ; \n } \n\n //2.返回对象本身用*this \n void   test02 ( )   { \n    Person  p1 ( 10 ) ; \n    Person  p2 ( 10 ) ; \n    p2 . PersonAddAge ( p1 ) ; \n    cout  <<   "p2的年龄为："   <<  p2 . age  <<  endl ; \n } \n\n void   test03 ( )   { \n    Person  p1 ( 10 ) ; \n    Person  p2 ( 10 ) ; \n    p2 . PersonAddAgeN ( p1 ) . PersonAddAgeN ( p1 ) . PersonAddAgeN ( p1 ) ; \n    cout  <<   "p2的年龄为："   <<  p2 . age  <<  endl ; \n } \n\n int   main ( )   { \n     // test01(); \n     // test02(); \n     test03 ( ) ; \n     return   0 ; \n } \n \n 3.3.3 空指针调用成员函数 \n C++空指针也可以调用成员函数，但是要注意有没有用到this指针 \n 如果用到this指针，需要加以判断保证代码健壮性 \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n public : \n     void   showClassName ( )   { \n        cout  <<   "This is class Person"   <<  endl ; \n     } \n     void   showAge ( )   { \n         if   ( this   ==   NULL )   return ;   //解决方式，提高代码健壮性 \n        cout  <<   "age = "   <<  m_Age  <<  endl ;  \n         //每个对象的属性都会默认加上this指针，如this->m_Age \n         //当this是空时，那么this->m_Age则会报错 \n         //报错的原因是传入指针为空 \n     } \n     int  m_Age ; \n } ; \n\n void   test01 ( )   { \n    Person  * p  =   NULL ; \n    p -> showClassName ( ) ;   //正常调用 \n    p -> showAge ( ) ;   //调用错误：this是nullptr \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n 3.3.4 const修饰成员函数 \n 常函数： \n \n 成员函数后加 const 后，我们称这个函数为 常函数 \n 常函数内不可以修改成员属性 \n 成员属性声明时附加mutable关键字，在常函数中依然可以修改。 \n \n 常对象： \n \n 声明对象前加const称该对象为常对象 \n 常对象只能调用常函数 \n 常对象不允许修改普通属性（mutable属性除外） \n \n 声明形式： 类名 cosnt 对象名 (实参表) 或 cosnt 类名 对象名(实参表) \n const    class    object ( params ) ; \n class   const   object ( params ) ; \n \n 也可以定义const指针: \n const   class   * p  =   new   class ( params ) ; \n class   const   * p  =   new   class ( params ) ; \n \n class 为类名， object 为对象名， params 为实参列表， p 为指针名。两种方式定义出来的对象都是常对象。 \n 示例： \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n public : \n     Person ( ) :   m_A ( 10 ) ,   m_B ( 20 )   { } \n     //this指针的本质 是指针常量 指针的指向是不可以修改的 \n     //Person * const this;//原本this是这种形式 \n     //在后面加入const后相当于const Person *const this; //使得this指向的值也不可被修改 \n     void   showPerson ( )   const   { \n         //m_A = 100; //相当于 this->m_A = 100;常函数不可以修改成员属性，去掉函数后的const成立 \n         //this = NULL; //this指针不可以修改指向 \n         this -> m_B  =   100 ; \n     } \n     void   func ( )   { } \n     int  m_A ; \n     mutable   int  m_B ;   //特殊变量，即使在常函数中，也可以修改这个值，加关键字mutable \n } ; \n\n void   test01 ( )   { \n    Person p ; \n    p . showPerson ( ) ;  \n } \n\n //常对象 \n void   test02 ( )   { \n     const  Person p2 ;   //在对象前加上一个const修饰即为常对象，常对象必须初始化 \n     //p2.m_A = 100;  //常对象的普通属性不可以被修改 \n    p2 . m_B  =   100 ;   //常对象的mutable属性在任何有权限的区域都可以修改 \n\n     //常对象，只能调用常函数 \n    p2 . showPerson ( ) ; \n     //p2.func(); //常对象不可以调用普通成员函数，因为普通成员函数可以修改属性 \n } \n\n int   main ( )   { \n     return   0 ; \n } \n 3.4 友元 \n 生活中你家有客厅(public), 有你的卧室(private) \n 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 \n 但是呢，你也可以允许你的好闺蜜好基友进去。 \n 在程序里，有些私有属性，也想让类外特殊的一些函数或者类进行访问, 就需要用到友元的技术。 \n 友元的作用就是让一个函数或者类 访问另一个类中的私有成员 \n 友元的关键字为  friend \n 友元三种实现方式 \n \n 全局函数做友元 \n 类做友元 \n 成员函数做友元 \n \n 3.4.1 全局函数做友元 \ninclude   <iostream> \n using   namespace  std ; \n\n class   Building   { \n     //表明goodGay全局函数是本类的友元，可以访问私有成员 \n     friend   void   goodGay ( Building  * building ) ; \n public : \n     Building ( ) :   m_SittingRoom ( "客厅" ) ,   m_BedRoom ( "卧室" )   { } \n\n public : \n    string m_SittingRoom ;   //客厅 \n\n private : \n    string m_BedRoom ;   //卧室 \n } ; \n\n //全局函数 \n void   goodGay ( Building  * building )   { \n    cout  <<   "好基友的全局函数正在访问："   <<  building -> m_SittingRoom  <<  endl ; \n    cout  <<   "好基友的全局函数正在访问："   <<  building -> m_BedRoom  <<  endl ; //友元可访问私有 \n } \n\n void   test01 ( )   { \n    Building building ; \n     goodGay ( & building ) ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n \n 3.4.2 类作为友元 \ninclude   <iostream> \ninclude   <string> \n using   namespace  std ; \n\n class   Building ; \n\n class   Goodgay { \n public : \n     Goodgay ( ) ; \n     void   visit ( ) ;   //参观函数，访问building中的属性 \n\n    Building  * building ; \n } ; \n\n //类做友元 \n class   Building   { \n     //告诉编译器，Goodgay是本类的友元，可以访问本类私有成员 \n     friend   class   Goodgay ; \n public : \n     Building ( ) ; \n\n public : \n    string m_SittingRoom ;   //客厅 \n\n private : \n    string m_BedRoom ;   //卧室 \n } ; \n\n //类外写成员函数 \n Building :: Building ( ) :   m_SittingRoom ( "客厅" ) ,   m_BedRoom ( "卧室" )   { } \n Goodgay :: Goodgay ( ) :   building ( new  Building )   { } \n void   Goodgay :: visit ( )   { \n    cout  <<   "好基友类正在访问："   <<  building -> m_SittingRoom  <<  endl ; \n    cout  <<   "好基友类正在访问："   <<  building -> m_BedRoom  <<  endl ; \n } \n\n void   test01 ( )   { \n    Goodgay g1 ; \n    g1 . visit ( ) ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n 3.4.3 成员函数做友元 \ninclude   <iostream> \ninclude   <string> \n using   namespace  std ; \n\n class   Building ; \n\n class   Goodgay { \n public : \n     Goodgay ( ) ; \n     void   visit ( ) ;   //参观函数，访问building中的私有成员 \n     void   visit2 ( ) ;   //不能访问building中的私有成员 \n    Building  * building ; \n } ; \n\n //类做友元 \n class   Building   { \n     //告诉编译器，Goodgay下的visit是本类的友元，可以访问私有成员 \n     friend   void   Goodgay :: visit ( ) ; \n\n public : \n     Building ( ) ; \n\n public : \n    string m_SittingRoom ;   //客厅 \n\n private : \n    string m_BedRoom ;   //卧室 \n } ; \n\n //类外写成员函数 \n Building :: Building ( ) :   m_SittingRoom ( "客厅" ) ,   m_BedRoom ( "卧室" )   { } \n Goodgay :: Goodgay ( ) :   building ( new  Building )   { } \n\n void   Goodgay :: visit ( )   { \n    cout  <<   "visit正在访问："   <<  building -> m_SittingRoom  <<  endl ; \n    cout  <<   "visit正在访问："   <<  building -> m_BedRoom  <<  endl ; \n } \n\n\n void   Goodgay :: visit2 ( )   { \n    cout  <<   "visit2正在访问："   <<  building -> m_SittingRoom  <<  endl ; \n     //cout << "visit2正在访问：" << building->m_BedRoom << endl; //此时visit可以访问私有成员，visit2不可以 \n } \n\n void   test01 ( )   { \n    Goodgay g1 ; \n    g1 . visit ( ) ; \n    g1 . visit2 ( ) ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n 3.5 运算符重载 \n 运算符重载概念：对已有的运算符重新定义，赋予其另一种功能，以适应不同的数据类型 \n 3.5.1 加号运算符重载 \n 作用：实现两个自定义数据类型相加的运算 \n 可以通过上面的链式编程思想来理解，（ps: 下方第一个返回值掉了&, 应该为Person&) \n & PersonAddPerson 相当于 operate+ \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n public : \n     //1.成员函数重载+号 \n     // Person operator+(Person &p) { \n     //     Person temp; \n     //     temp.m_A = this->m_A + p.m_A; \n     //     temp.m_B = this->m_B + p.m_B; \n     //     return temp; \n     // } \n\n     int  m_A ; \n     int  m_B ; \n     Person ( ) { } \n     Person ( int  a ,   int  b ) :   m_A ( a ) ,   m_B ( b )   { } \n } ; \n\n //2.全局函数重载+号 \nPerson  operator + ( Person  & p1 ,  Person  & p2 )   { \n    Person temp ; \n    temp . m_A  =  p1 . m_A  +  p2 . m_A ; \n    temp . m_B  =  p1 . m_B  +  p2 . m_B ; \n     return  temp ; \n } \n\n //运算符重载中的函数重载 \nPerson  operator + ( Person  & p1 ,   int  num )   { \n    Person temp ; \n    temp . m_A  =  p1 . m_A  +  num ; \n    temp . m_B  =  p1 . m_B  +  num ; \n     return  temp ; \n } \n\n void   test01 ( )   { \n    Person p1 ; \n    p1 . m_A  =   10 ; \n    p1 . m_B  =   10 ; \n    Person  p2 ( 10 ,   10 ) ; \n     //1.成员函数重载本质调用 \n     // Person p3 = p1.operator+(p2); \n\n     //2.全局函数重载本质调用 \n     // Person p3 = operator+(p1, p2); \n\n    Person p3  =  p1  +  p2 ; \n    cout  <<   "p3.m_A = "   <<  p3 . m_A  <<  endl ; \n    cout  <<   "p3.m_B = "   <<  p3 . m_B  <<  endl ; \n\n     //运算符重载也可以发生函数重载 \n    Person p4  =  p1  +   100 ;   //Person + int \n    cout  <<   "p4.m_A = "   <<  p4 . m_A  <<  endl ; \n    cout  <<   "p4.m_B = "   <<  p4 . m_B  <<  endl ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n \n 总结一：对于内置的数据类型的表达式，其运算符是不可能发生改变的 \n 总结二：不要滥用运算符重载（比如把加法写成减法） \n \n 3.5.2 左移运算符重载 \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n friend  ostream &   operator << ( ostream  & cout ,  Person  & p ) ; \n private : \n     //利用成员函数重载左移运算符 p.operator<<(cout) 简化版本 p << cout \n     //不会利用成员函数重载<<运算符，因为无法实现 cout在左侧 \n     //void operator<<() {} \n     int  m_A ; \n     int  m_B ; \n\n public : \n     Person ( ) :   m_A ( 10 ) ,   m_B ( 10 )   { } \n     Person ( int  a ,   int  b ) :   m_A ( a ) ,   m_B ( b )   { } \n } ; \n\n //只能利用全局函数重载左移运算符 \n //如果传入参数非引用方式，那么就会创建一个新的对象，而cout对象全局只有一个，所以需要以引用的方式来进行传入 \n //本质 operator<< (cout, p) 简化 cout << p \n //若要访问私有，既可以通过在类内设置接口，也可以设置友元 \nostream &   operator << ( ostream  & cout ,  Person  & p )   {  \n    cout  <<   "p.m_A = "   <<  p . m_A  <<   " p.m_B = "   <<  p . m_B ; \n     return  cout ; \n } \n\n // 引用是取别名，所以改为out也OK，他们本质都是指向同一块内存空间 \n // ostream& operator<<(ostream &out, Person &p) {  \n //     out << "p.m_A = " << p.m_A << " p.m_B = " << p.m_B; \n //     return out; \n // } \n\n void   test01 ( )   { \n    Person p ; \n    cout  <<  p  <<  endl ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n \n 总结：重载的左移运算符配合友元可以实现输出自定义的数据类型 \n \n 3.5.3 递增运算符重载 \n 作用：通过重载递增运算符，实现自己的整型数据 \ninclude   <iostream> \n using   namespace  std ; \n\n class   MyInteger   { \n     friend  ostream &   operator << ( ostream &  cout ,  MyInteger myint ) ; \n\n public : \n     MyInteger ( ) :   m_Num ( 0 )   { } \n\n     //重载前置++ 返回引用是为了对同一个数据进行递增操作，而不是递增完返回对象后又拷贝构造一个新的对象 \n    MyInteger &   operator ++ ( )   { \n        m_Num ++ ; \n         return   * this ; \n     } \n\n     //重载后置++ \n     //void operator++(int) int代表占位参数，可以用于区分前置和后置递增 \n    MyInteger  operator ++ ( int )   {   //后置递增返回的是局部对象，所以不加引用 \n         //先 记录当时结果 \n        MyInteger temp  =   * this ; \n         //后 递增 \n        m_Num ++ ; \n         //最后将记录结果做返回 \n         return  temp ; \n     } \n private : \n     int  m_Num ; \n } ; \n\nostream &   operator << ( ostream &  cout ,  MyInteger myint )   { \n    cout  <<  myint . m_Num ; \n     return  cout ; \n } \n\n void   test01 ( )   { \n    MyInteger myint ; \n    cout  <<   ++ ( ++ myint )   <<  endl ; \n    cout  <<  myint  <<  endl ; \n } \n\n void   test02 ( )   { \n    MyInteger myint ; \n    cout  <<  myint ++   <<  endl ; \n    cout  <<  myint  <<  endl ; \n } \n\n int   main ( )   { \n     // test01(); \n     test02 ( ) ; \n     return   0 ; \n } \n \n \n 总结：前置递增返回引用，后置递增返回值。 \n \n 自己实现了一个--重载 \ninclude   <iostream> \n using   namespace  std ; \n\n class   MyInteger   { \n     friend  ostream &   operator << ( ostream  & cout ,  MyInteger myint ) ; \n\n public : \n     MyInteger ( ) :   m_Num ( 0 )   { } \n    \n     //前置++ \n    MyInteger &   operator -- ( )   { \n        m_Num -- ; \n         return   * this ; \n     } \n\n    MyInteger  operator -- ( int )   { \n        MyInteger temp  =   * this ;   //先记录 \n         this -> m_Num -- ;   //再递减 \n         return  temp ;   //再返回临时记录的结果 \n     } \n    \n\n private : \n     int  m_Num ; \n } ; \n\nostream &   operator << ( ostream  & cout ,  MyInteger myint )   {   //此处myint为值传递会创建新对象 \n    cout  <<  myint . m_Num ; \n     return  cout ; \n } \n\n void   test01 ( )   { \n    MyInteger myint ; \n    cout  <<   -- -- myint  <<  endl ; \n    cout  <<  myint  <<  endl ; \n } \n\n void   test02 ( )   { \n    MyInteger myint ; \n    cout  <<  myint --   <<  endl ; \n    cout  <<  myint  <<  endl ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     test02 ( ) ; \n     return   0 ; \n } \n \n 3.5.4 赋值运算符重载 \n C++编译器至少给一个类添加4个函数 \n \n \n 默认构造函数（无参，函数体为空） \n \n \n 默认析构函数（无参，函数体为空） \n \n \n 默认拷贝构造函数，对属性进行值拷贝 \n \n \n 赋值运算符 operator=，对属性进行值拷贝 \n \n \n 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题，堆区内存重复释放。 \n \n 示例： \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n public : \n     Person ( int  age )   { \n        m_Age  =   new   int ( age ) ; \n     } \n     ~ Person ( )   { \n         if   ( m_Age  !=   NULL )   { \n             delete  m_Age ; \n            m_Age  =   NULL ; \n         } \n     } \n     //重载运算符= \n    Person &   operator = ( Person  & p )   { \n         //编译器提供浅拷贝 \n         //m_Age = p.m_Age; \n        \n         //应该先判断是否有属性在堆区，如果有释放干净，然后再深拷贝 \n         if   ( m_Age  !=   NULL )   { \n             delete  m_Age ; \n            m_Age  =   NULL ; \n         } \n\n         //深拷贝 \n        m_Age  =   new   int ( * p . m_Age ) ; \n\n         //返回对象本身来支持连等 \n         return   * this ; \n     } \n\n     int   * m_Age ; \n } ; \n\n void   test01 ( )   { \n    Person  p1 ( 18 ) ; \n    Person  p2 ( 20 ) ; \n    Person  p3 ( 28 ) ; \n    p3  =  p2  =  p1 ; \n    cout  <<   "p1的年龄为："   <<   * p1 . m_Age  <<  endl ; \n    cout  <<   "p2的年龄为："   <<   * p2 . m_Age  <<  endl ; \n    cout  <<   "p3的年龄为："   <<   * p3 . m_Age  <<  endl ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n 3.5. 关系运算符 == 或 != 重载 \ninclude   <iostream> \n using   namespace  std ; \n\n class   Person   { \n public : \n     Person ( string name ,   int  age )   :   m_Name ( name ) ,   m_Age ( age )   { } \n\n     bool   operator == ( Person  & p )   { \n         return   this -> m_Name  ==  p . m_Name  &&   this -> m_Age  ==  p . m_Age ; \n     } \n\n     bool   operator != ( Person  & p )   { \n         return   this -> m_Name  !=  p . m_Name  ||   this -> m_Age  !=  p . m_Age ; \n     } \n\n    string m_Name ; \n     int  m_Age ; \n } ; \n\n void   test01 ( )   { \n    Person  p1 ( "Tom" ,   18 ) ; \n    Person  p2 ( "Jerry" ,   18 ) ; \n     if   ( p1  ==  p2 )   { \n        cout  <<   "p1 和 p2 是相等的！"   <<  endl ; \n     }   else   { \n        cout  <<   "p1 和 p2 是不相等的！"   <<  endl ; \n     } \n     if   ( p1  !=  p2 )   { \n        cout  <<   "p1 和 p2 是不相等的！"   <<  endl ; \n     }   else   { \n        cout  <<   "p1 和 p2 是相等的！"   <<  endl ; \n     } \n } \n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n 4.5.6 函数调用运算符重载 \n \n 函数调用运算符() 也可以重载 \n 由于重载后的方式非常像函数的调用，因此称为仿函数 \n 仿函数没有固定写法，非常灵活 \ninclude   <iostream> \ninclude   <string> \n using   namespace  std ; \n\n class   MyPrint   { \n\n public : \n     //重载函数调用运算符 \n     void   operator ( )   ( string text )   { \n        cout  <<  text  <<  endl ; \n     } \n } ; \n\n //仿函数没有固定写法，非常灵活 \n //加法类 \n class   MyAdd   { \n public : \n     int   operator ( )   ( int  a ,   int  b )   { \n         return  a  +  b ; \n     } \n } ; \n\n void   test01 ( )   { \n    MyPrint myprint ; \n     myprint ( "hello world" ) ;   //由于重载后的方式非常像函数的调用，因此称为仿函数 \n    MyAdd myadd ; \n     int  ret  =   myadd ( 100 ,   100 ) ; \n    cout  <<   "ret = "   <<  ret  <<  endl ; \n    cout  <<   myadd ( 15 ,   17 )   <<  endl ; \n\n     //匿名函数对象调用: 匿名对象创建完在本行执行结束立即释放，匿名对象调用重载的() \n    cout  <<   "MyAdd()(100, 100) = "   <<   MyAdd ( ) ( 100 ,   100 )   <<  endl ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n 3.6 继承 \n 继承是面向对象三大特性之一 \n 有些类与类之间存在特殊的关系，例如下图中： \n \n 定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。 \n 这个时候，我们就可以考虑利用继承的技术，减少重复代码。 \n 3.6.1 继承基本语法 \n 例如很多网站中，都有公共头部，公共的底部，甚至公共的左侧列表，只有中心内容不同 \n 接下来我们分别利用普通写法和继承写法来实现网页中的内容，看一下继承存在的意义及好处 \n 普通实现： \ninclude   <iostream> \n using   namespace  std ; \n\n //普通实现页面 \n //Java页面 \n class   Java   { \n public : \n     void   header ( )   { \n        cout  <<   "首页、公开课、登录、注册...（公共头部）"   <<  endl ; \n     } \n     void   footer ( )   { \n        cout  <<   "帮助中心、交流合作、站内地图...（公共底部）"   <<  endl ; \n     } \n     void   left ( )   { \n        cout  <<   "Java、Python、C++、...（公共类列表）"   <<  endl ; \n     } \n     void   content ( )   { \n        cout  <<   "Java学科视频"   <<  endl ; \n     } \n } ; \n\n //Python页面 \n class   Python   { \n public : \n     void   header ( )   { \n        cout  <<   "首页、公开课、登录、注册...（公共头部）"   <<  endl ; \n     } \n     void   footer ( )   { \n        cout  <<   "帮助中心、交流合作、站内地图...（公共底部）"   <<  endl ; \n     } \n     void   left ( )   { \n        cout  <<   "Java、Python、C++、...（公共类列表）"   <<  endl ; \n     } \n     void   content ( )   { \n        cout  <<   "Python学科视频"   <<  endl ; \n     } \n } ; \n\n //C++页面 \n class   CPP   { \n public : \n     void   header ( )   { \n        cout  <<   "首页、公开课、登录、注册...（公共头部）"   <<  endl ; \n     } \n     void   footer ( )   { \n        cout  <<   "帮助中心、交流合作、站内地图...（公共底部）"   <<  endl ; \n     } \n     void   left ( )   { \n        cout  <<   "Java、Python、C++、...（公共类列表）"   <<  endl ; \n     } \n     void   content ( )   { \n        cout  <<   "Python学科视频"   <<  endl ; \n     } \n } ; \n\n void   test01 ( )   { \n    cout  <<   "Java页面"   <<  endl ; \n    Java ja ; \n    ja . header ( ) ; \n    ja . footer ( ) ; \n    ja . left ( ) ; \n    ja . content ( ) ; \n\n    cout  <<   "-------------------"   <<  endl ; \n    cout  <<   "Python页面"   <<  endl ; \n    Python py ; \n    py . header ( ) ; \n    py . footer ( ) ; \n    py . left ( ) ; \n    py . content ( ) ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n 继承实现（继承公共部分）： \n 语法： class 子类 : 继承方式 父类 {}; \n class A : public B {} ; \n 子类 也称为 派生类 \n 父类 也称为 基类 \n 好处：减少重复的代码 \ninclude   <iostream> \n using   namespace  std ; \n\n //继承实现页面 \n //公共部分 \n class   BasePage   { \n public : \n     void   header ( )   { \n        cout  <<   "首页、公开课、登录、注册...（公共头部）"   <<  endl ; \n     } \n     void   footer ( )   { \n        cout  <<   "帮助中心、交流合作、站内地图...（公共底部）"   <<  endl ; \n     } \n     void   left ( )   { \n        cout  <<   "Java、Python、C++、...（公共类列表）"   <<  endl ; \n     } \n } ; \n\n //实现继承 \n\n //Java页面 \n class   Java   :   public   BasePage   { \n public : \n     void   content ( )   { \n        cout  <<   "Java学科视频"   <<  endl ; \n     } \n } ; \n\n //Python页面 \n class   Python   :   public   BasePage   { \n public : \n     void   content ( )   { \n        cout  <<   "Python学科视频"   <<  endl ; \n     } \n } ; \n\n //C++页面 \n class   CPP   :   public   BasePage   { \n public : \n     void   content ( )   { \n        cout  <<   "C++学科视频"   <<  endl ; \n     } \n } ; \n\n void   test01 ( )   { \n    cout  <<   "Java页面"   <<  endl ; \n    Java ja ; \n    ja . header ( ) ; \n    ja . footer ( ) ; \n    ja . left ( ) ; \n    ja . content ( ) ; \n\n    cout  <<   "-------------------"   <<  endl ; \n    cout  <<   "Python页面"   <<  endl ; \n    Python py ; \n    py . header ( ) ; \n    py . footer ( ) ; \n    py . left ( ) ; \n    py . content ( ) ; \n\n    cout  <<   "-------------------"   <<  endl ; \n    cout  <<   "C++页面"   <<  endl ; \n    CPP cpp ; \n    cpp . header ( ) ; \n    cpp . footer ( ) ; \n    cpp . left ( ) ; \n    cpp . content ( ) ; \n\n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n \n 派生类中的成员，包含两大类 \n 一类是从基类中继承来的，一类是自己增加的成员 \n 从基类继承过来的表现其共性，而新增的成员体现了其个性 \n \n 3.6.2 继承方式 \n 继承语法：  class 子类 : 继承方式 父类 {}; \n 继承方式一共三种： \n \n 公共继承 \n 保护继承 \n 私有继承 \n \n \n 公共继承：父类中的public, protected成员被子类继承且访问权限不变，父类的private子类不可访问 \n 保护继承：父类的public,protected成员被子类继承，且访问权限修改为protected，父类private子类不可访问 \n 私有继承：public,protected被继承且权限修改为private，父类的private子类不可访问 \n 3.6.3 继承中的对象模型 \n **问题：**子类中继承过来的成员，哪些属于子类对象中？ \n 示例： \ninclude   <iostream> \n using   namespace  std ; \n\n class   Base   { \n public : \n     int  m_A ; \n protected : \n     int  m_B ; \n private : \n     int  m_C ; \n } ; \n\n class   Son   :   public   Base { \n public : \n     int  m_D ; \n } ; \n\n //vs的开发工具 \n //利用开发人员命令提示工具查看对象模型 \n //跳转盘符 F: \n //跳转文件路径 cd 具体路径下 \n //查看命令 \n //cl /d1 reportSingleClassLayout类名 文件名 \n void   test01 ( )   { \n     //父类中所有非静态成员属性都会被子类继承下去 \n     //父类的私有成员属性被编译器隐藏了，因此访问不到，但确实继承下去了 \n    cout  <<   "size of Son = "   <<   sizeof ( Son )   <<  endl ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n \n 父类中所有非静态成员属性都会被子类继承下去,父类的私有成员属性被编译器隐藏了，因此访问不到，但确实继承下去了 \n \n 3.6.4 继承中构造和析构顺序 \n 子类继承父类后， 当创建子类对象，也会调用父类的构造函数 \n **问题：**父类和子类的构造和析构顺序谁先谁后？ \n **答：**构造：Base -> Son(先父再子) \n 析构：Son -> Base(先子再父) \n 示例： \ninclude   <iostream> \n using   namespace  std ; \n\n class   Base   { \n public : \n     Base ( )   { \n        cout  <<   "Base构造函数！"   <<  endl ; \n     } \n     ~ Base ( )   { \n        cout  <<   "Base析构函数！"   <<  endl ; \n     } \n } ; \n\n class   Son   :   public   Base   { \n public : \n     Son ( )   { \n        cout  <<   "Son构造函数！"   <<  endl ; \n     } \n     ~ Son ( )   { \n        cout  <<   "Son析构函数！"   <<  endl ; \n     } \n } ; \n\n void   test01 ( )   { \n    Son s1 ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n 3.6.5 继承中同名成员处理方式 \n 问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？ \n \n 访问子类同名成员 直接访问即可 \n 访问父类同名成员 需要加作用域 :: \n \n 注意：同名成员函数即使发生重载，也需要加::来调用 \n 如果子类中出现同名成员函数，那么子类会隐藏掉父类中的所有同名成员，包括重载 \n 示例： \ninclude   <iostream> \n using   namespace  std ; \n\n class   Base   { \n public : \n     Base ( )   { \n        m_A  =   100 ; \n     } \n     void   func ( )   { \n        cout  <<   "Base-func()"   <<  endl ; \n     } \n     void   func ( int  a )   { \n        cout  <<   "Base-func(int)"   <<  endl ; \n     } \n     int  m_A ; \n } ; \n\n class   Son   :   public   Base   { \n public : \n     Son ( )   { \n        m_A  =   200 ; \n     } \n     void   func ( )   { \n        cout  <<   "Son-func()"   <<  endl ; \n     } \n     int  m_A ; \n } ; \n\n void   test01 ( )   { \n    Son s1 ; \n    cout  <<   "Son下的m_A: "   <<  s1 . m_A  <<  endl ; \n    cout  <<   "Base下的m_A: "   <<  s1 . Base :: m_A  <<  endl ; \n } \n\n //同名即使重载也需要 \n void   test02 ( )   { \n    Son s1 ; \n    cout  <<   "Son的func：" ; \n    s1 . func ( ) ; \n    cout  <<   "Base的func：" ; \n    s1 . Base :: func ( ) ; \n     //如果子类中出现同名成员函数，那么子类会隐藏掉父类中的所有同名成员，包括重载 \n     //需要加作用域来访问父类中的同名成员 \n     //s1.func(100); \n    cout  <<   "Base的func(int)：" ; \n    s1 . Base :: func ( 100 ) ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     test02 ( ) ; \n     return   0 ;  \n } \n \n 3.6.6 继承中同名静态成员处理方式 \n 问题：继承中同名的静态成员在子类对象上如何进行访问？ \n 静态成员和非静态成员出现同名，处理方式一致，且同一个类中的对象共享同一份静态成员 \n \n 访问子类同名成员 直接访问即可 \n 访问父类同名成员 需要加作用域 \n \n 示例： \ninclude   <iostream> \n using   namespace  std ; \n\n class   Base   { \n public : \n     static   int  m_A ; \n     static   void   func ( )   { \n        cout  <<   "Base - static void func"   <<  endl ; \n     } \n     static   void   func ( int  a )   { \n        cout  <<   "Base - static void func(int)"   <<  endl ; \n     } \n } ; \n\n int  Base :: m_A  =   100 ; \n\n class   Son   :   public   Base   { \n public : \n     static   int  m_A ; \n     static   void   func ( )   { \n        cout  <<   "Son - static void func"   <<  endl ; \n     } \n } ; \n\n int  Son :: m_A  =   200 ; \n\n void   test01 ( )   { \n    Son s ; \n     //1.通过对象访问 \n    cout  <<   "Son的m_A: "   <<  s . m_A  <<  endl ; \n    cout  <<   "Base的m_A: "   <<  s . Base :: m_A  <<  endl ; \n\n     //2.通过类名访问 \n    cout  <<   "通过类名访问："   <<  endl ; \n    cout  <<   "Son   下 m_A = "   <<  Son :: m_A  <<  endl ; \n    cout  <<   "Base  下 m_A = "   <<  Base :: m_A  <<  endl ;   //直接通过父类访问静态成员 \n     //第一个::代表通过类名方式访问 第二个::代表访问父类作用域下 \n    cout  <<   "Base  下 m_A = "   <<  Son :: Base :: m_A  <<  endl ;   //通过子类访问父类，再访问静态成员 \n } \n\n void   test02 ( )   { \n\n     //1.通过对象访问 \n    cout  <<   "通过对象访问: "   <<  endl ; \n    Son s ; \n    s . func ( ) ; \n    s . Base :: func ( ) ; \n\n     //2.通过类名方式访问 \n    cout  <<   "通过类名访问: "   <<  endl ; \n     Son :: func ( ) ; \n    Son :: Base :: func ( ) ; \n\n     // Son::func(100); \n     //如果子类中出现同名静态成员函数，那么子类会隐藏掉父类中的所有同名成员，包括重载 \n     //需要加作用域来访问父类中的同名成员 \n    Son :: Base :: func ( 100 ) ; \n } \n\n int   main ( )   { \n     // test01(); \n     test02 ( ) ; \n     return   0 ; \n } \n \n 3.6.7 多继承语法 \n 语法： class 子类 : 继承方式1 父类1, 继承方式2 父类2... {} \n 多继承可能会引发父类中有同名成员出现，需要加作用域区分 \n C++实际开发中不建议用多继承 \n 示例： \ninclude   <iostream> \n using   namespace  std ; \n\n class   Base1   { \n public : \n     Base1 ( )   { \n        m_A  =   100 ; \n     } \n     int  m_A ; \n } ; \n\n class   Base2   { \n public : \n     Base2 ( )   { \n        m_A  =   200 ; \n     } \n     int  m_A ; \n } ; \n\n class   Son   :   public   Base1 ,   public   Base2   { \n public : \n     Son ( )   { \n        m_C  =   300 ; \n        m_D  =   400 ; \n     } \n     int  m_C ; \n     int  m_D ; \n } ; \n\n void   test01 ( )   { \n    Son s ; \n    cout  <<   sizeof ( s )   <<  endl ; \n     //当父类中出现同名成员，子类使用需要加作用域, 否则会报错“不明确” \n    cout  <<   "Base2::m_A = "   <<  s . Base2 :: m_A  <<  endl ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n \n 当父类中出现同名成员，子类使用需要加作用域 \n \n 4.6.8 菱形继承 \n 菱形继承概念 \n ​\t\t两个派生类继承同一个基类 \n ​\t\t又有某个类同时继承这两个派生类 \n ​\t\t这种继承被称为菱形继承，或者钻石继承 \n  \n 典型的菱形继承案例： \n  \n 菱形继承问题： \n 1. 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。\n2. 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份即可。\n \n 通过virtual关键字来进行继承 \n 语法： class son : virtual public Base {}; \n \n \n virtual底层是继承了两个指针vbptr（虚基类指针） 指向 vbtable（虚继承表） \n vbptr通过偏移量，找到虚基类 \ninclude   <iostream> \n using   namespace  std ; \n\n //动物类 \n class   Animal   { \n public : \n     int  m_Age ; \n } ; \n\n //利用虚继承可解决菱形继承问题 \n //继承之前 加上关键字 virtual 变为虚继承 \n //Animal类称为 虚基类 \n //羊类 \n class   Sheep   :   virtual   public   Animal   { } ; \n\n //驼类 \n class   Tuo   :   virtual   public   Animal   { } ; \n\n //草泥马 \n class   SheepTuo   :   public   Sheep ,   public   Tuo   { } ; \n\n void   test01 ( )   { \n    SheepTuo st ; \n     //当出现菱形继承的时候，两个父类拥有相同数据，需要加以作用域区分 \n    st . Sheep :: m_Age  =   18 ; \n    st . Tuo :: m_Age  =   28 ; \n    cout  <<   "st.Sheep::m_Age = "   <<  st . Sheep :: m_Age  <<  endl ; \n    cout  <<   "st.Tuo::m_Age = "   <<  st . Tuo :: m_Age  <<  endl ; \n\n     //这份数据我们知道, 只有一份就够了,菱形继承导致数据有两份，资源浪费 \n    cout  <<   "st.m_Age = "   <<  st . m_Age  <<  endl ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n \n 总结： \n 菱形继承带来的主要问题是子类继承两份相同数据，导致资源浪费以及毫无意义 \n 利用虚继承可以解决菱形继承问题 \n 虚继承本质是通过继承来的虚基类指针，来让基类指针指向子类中继承来的基类的对象。 \n 3.7 多态 \n 3.7.1 多态的基本概念 \n 多态是C++面向对象的三大特性之一（封装、继承、多态） \n 多态分为两类 \n \n 静态多态：函数重载 和 运算符重载属于静态多态，复用函数名 \n 动态多态：派生类 和 虚函数实现运行时多态 \n \n 静态多态和动态多态区别： \n \n 静态多态的函数地址早绑定 - 编译阶段确定函数地址 \n 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 \n \n 下面案例： \ninclude   <iostream> \n using   namespace  std ; \n\n //动物类 \n class   Animal   { \n public : \n     //加上virtual实现地址晚绑定 \n     //虚函数 \n     virtual   void   speak ( )   { \n        cout  <<   "动物在说话"   <<  endl ; \n     } \n } ; \n\n //猫类 \n class   Cat   :   public   Animal   { \n public : \n     void   speak ( )   { \n        cout  <<   "小猫在说话"   <<  endl ; \n     } \n } ; \n\n //狗类 \n class   Dog   :   public   Animal   { \n public : \n     void   speak ( )   { \n        cout  <<   "小狗在说话"   <<  endl ; \n     } \n } ; \n\n\n //执行说话函数 \n //地址早绑定 在编译阶段就确定了函数地址 \n //如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定 \n\n //动态多态满足条件 \n // 1. 有继承关系 \n // 2. 子类重写父类的虚函数（重写：返回值类型，函数名，参数列表完全相同） \n // 子类写不写virtual都无影响 \n\n //动态多态的使用 \n // 父亲的指针或者引用 指向子类对象 \n\n //个人总结 \n //当传入对象类型定义为父类，调用函数时传入的是子类时，地址早绑定，里边会执行父类的地址 \n //父类与子类有同名函数，若父类的同名函数设置为虚函数，那么就会地址晚绑定，此时才会执行传入的类成员函数 \n\n\n void   doSpeak ( Animal  & animal )   {   //Animal &animal = cat; \n    animal . speak ( ) ; \n } \n\n\n\n void   test01 ( )   { \n    Cat cat ; \n    cat . speak ( ) ; \n     doSpeak ( cat ) ;  \n    Dog dog ; \n     doSpeak ( dog ) ; \n } \n\n void   test02 ( )   { \n    cout  <<   "sizeof Animal = "   <<   sizeof   ( Animal )   <<  endl ; \n     //64位系统中，指针大小为8字节2^64 \n     //32位系统中，指针大小为4字节2^32 \n     //说明此时Animal中有一个指针 \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     test02 ( ) ; \n     return   0 ; \n } \n \n 总结： \n 多态满足条件： \n \n 有继承关系 \n 子类重写父类中的虚函数 \n \n 多态使用条件 \n \n 父类指针或引用指向子类对象 \n \n 重写：函数返回值类型 函数名 参数列表 完全一致重写 \n 多态原理剖析 \n \n 如果子类不重写，那么子类中的虚函数表 内部 存放地址仍然是继承于父类，即与父类一致，仍为&Animal::speak \n 重写之后，由子类中的函数地址覆盖为&Cat::speak() \n 3.7.2 多态实现计算器案例 \n 在真的开发中 提倡 开闭原则 \n **开闭原则：**对扩展进行开放，对修改进行关闭 \n 多态好处： \n 1.组织结构清晰 \n 2.可读性强 \n 3.对于前期和后期的扩展以及维护性高 \ninclude   <iostream> \n using   namespace  std ; \n\n\n //有的设计如果想扩展新的功能，需要修改源码 \n\n //在真的开发中 提倡 开闭原则 \n //开闭原则：对扩展进行开放，对修改进行关闭 \n\n\n //利用多态实现计算器 \n //多态好处： \n //1.组织结构清晰 \n //2.可读性强 \n //3.对于前期和后期的扩展以及维护性高 \n\n //实现计算器 \n class   AbstractCalculator   { \n public : \n     virtual   int   getResult ( )   { \n         return   0 ; \n     } \n     int  m_Num1 ; \n     int  m_Num2 ; \n } ; \n\n class   AddCalculator   :   public   AbstractCalculator   { \n public : \n     int   getResult ( )   { \n         return  m_Num1  +  m_Num2 ; \n     } \n } ; \n\n class   SubCalculator   :   public   AbstractCalculator   { \n public : \n     int   getResult ( )   { \n         return  m_Num1  -  m_Num2 ; \n     } \n } ; \n\n class   MultiCalculator   :   public   AbstractCalculator   { \n public : \n     int   getResult ( )   { \n         return  m_Num1  *  m_Num2 ; \n     } \n } ; \n\n void   test02 ( )   { \n     //多态使用条件，父类的引用或指针指向子类对象 \n    AbstractCalculator  * abc  =   new  AddCalculator ; \n    abc -> m_Num1  =   10 ; \n    abc -> m_Num2  =   20 ; \n    cout  <<  abc -> getResult ( ) ; \n     delete  abc ; \n\n    abc  =   new  SubCalculator ; \n    abc -> m_Num1  =   10 ; \n    abc -> m_Num2  =   20 ; \n    cout  <<  abc -> getResult ( ) ; \n     delete  abc ; \n } \n\n int   main ( )   { \n     test02 ( ) ;  \n     return   0 ; \n } \n \n 3.7.3 纯虚函数和抽象类 \n 在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 \n 因此可以将虚函数改为 纯虚函数 \n 纯虚函数语法： virtual 返回值类型 函数名 (参数列表) = 0 \n 当类中有了纯虚函数，这个类也称为抽象类 \n 抽象类的特点： \n \n 无法实例化对象 \n 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 \n \n 示例： \ninclude   <iostream> \n using   namespace  std ; \n\n class   Base   { \n public : \n     //纯虚函数 \n     //类中只要有一个纯虚函数，那么该类即为抽象类 \n     //抽象类特点： \n     //1.无法实例化对象 \n     //2.抽象类的子类，必须重写父类的纯虚函数，否则其本身也为抽象类 \n\n     virtual   void   func ( )   =   0 ; \n } ; \n\n class   Son   :   public   Base   { \n public : \n     virtual   void   func ( )   { \n        cout  <<   "func函数调用"   <<  endl ; \n     } ;   //virtual和;可加可不加 \n } ; \n\n void   test01 ( )   { \n     // Base b;   //抽象类无法实例化对象 \n     // new Base; //抽象类无法实例化对象 \n    Base  * base  =   new  Son ; \n    base -> func ( ) ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n 3.7.4 多态案例二-制作饮品 \n 案例描述： \n 制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料 \n 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 \ninclude   <iostream> \n using   namespace  std ; \n\n //多态案例2 制作饮品 \n class   AbstractDrinking   { \n public : \n     //煮水 \n     virtual   void   Boil ( )   =   0 ; \n\n     //冲泡 \n     virtual   void   Brew ( )   =   0 ; \n\n     //倒入杯中 \n     virtual   void   PourInCup ( )   =   0 ; \n\n     //加入辅料 \n     virtual   void   PutSomething ( )   =   0 ; \n\n     //制作饮品 \n     void   makeDrink ( )   { \n         Boil ( ) ; \n         Brew ( ) ; \n         PourInCup ( ) ; \n         PutSomething ( ) ; \n     } \n } ; \n\n //制作咖啡 \n class   Coffee   :   public   AbstractDrinking   { \n public : \n     //煮水 \n     void   Boil ( )   { \n        cout  <<   "煮农夫山泉"   <<  endl ; \n     } \n\n     //冲泡 \n     void   Brew ( )   { \n        cout  <<   "冲泡咖啡"   <<  endl ; \n     } \n\n     //倒入杯中 \n     void   PourInCup ( )   { \n        cout  <<   "倒入杯中"   <<  endl ; \n     } \n\n     //加入辅料 \n     void   PutSomething ( )   { \n        cout  <<   "加入糖和牛奶"   <<  endl ; \n     } \n } ; \n\n\n //制作咖啡 \n class   Tea   :   public   AbstractDrinking   { \n public : \n     //煮水 \n     void   Boil ( )   { \n        cout  <<   "煮矿泉水"   <<  endl ; \n     } \n\n     //冲泡 \n     void   Brew ( )   { \n        cout  <<   "冲泡茶叶"   <<  endl ; \n     } \n\n     //倒入杯中 \n     void   PourInCup ( )   { \n        cout  <<   "倒入杯中"   <<  endl ; \n     } \n\n     //加入辅料 \n     void   PutSomething ( )   { \n        cout  <<   "加入柠檬"   <<  endl ; \n     } \n } ; \n\n void   doWork ( AbstractDrinking  * abs )   { \n    abs -> makeDrink ( ) ; \n     delete  abs ;   //使用后释放 \n } \n\n void   test01 ( )   { \n     //制作咖啡 \n     doWork ( new  Coffee ) ; \n    cout  <<   "---------------"   <<  endl ; \n     doWork ( new  Tea ) ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n 3.7.5 虚析构和纯虚析构 \n 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 \n 解决方式：将父类中的析构函数改为 虚析构 和 纯虚析构 \n 虚析构和纯虚析构共性： \n \n 可以解决父类指针释放子类对象 \n 都需要具体的函数实现 \n \n 虚析构和纯虚析构区别： \n \n 如果是纯虚析构，该类属于抽象类，无法实例化对象 \n \n 虚析构语法 \n virtual ~类名(){} \n 纯虚析构语法： \n virtual ~类名() = 0; \n 类名::~类名(){} \n 注意：纯虚析构需要使用上述方法在类外实现 \ninclude   <iostream> \ninclude   <string> \n using   namespace  std ; \n\n class   Animal   { \n public : \n     Animal ( )   { \n        cout  <<   "Animal构造函数调用"   <<  endl ; \n     } \n     // virtual ~Animal() { \n     //     cout << "Animal析构函数调用" << endl; \n     // } \n\n     //纯虚析构 \n     virtual   ~ Animal ( )   =   0 ; \n     //若不实现该纯虚析构，会发生“1个无法解析的外部命令”，链接时发生的错误 \n     //在类外实现 \n\n     //纯虚函数，子类实现 \n     virtual   void   speak ( )   =   0 ; \n } ; \n\n Animal :: ~ Animal ( )   { \n    cout  <<   "Animal纯虚析构函数调用"   <<  endl ; \n } \n\n class   Cat   :   public   Animal   { \n public : \n     Cat ( string name )   { \n        m_Name  =   new   string ( name ) ; \n     } \n\n     virtual   void   speak ( )   { \n        cout  <<   "Cat的构造函数调用"   <<  endl ; \n        cout  <<   * m_Name  <<   "小猫在说话"   <<  endl ; \n     } \n\n     ~ Cat ( )   { \n         if   ( m_Name  !=   NULL )   { \n            cout  <<   "Cat的析构函数调用"   <<  endl ; \n             delete  m_Name ; \n            m_Name  =   NULL ; \n         } \n     } \n\n    string  * m_Name ; \n } ; \n\n void   test01 ( )   { \n    Animal  * animal  =   new   Cat ( "Tom" ) ; \n    animal -> speak ( ) ; \n     //父类的指针在析构时，不会调用子类析构函数，导致子类如果有堆区属性，出现内存泄露 \n     //解决方法，将父类的析构函数改为虚析构函数 \n     delete  animal ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n \n 总结： \n \n 虚析构和纯虚析构都是用来解决通过父类指针释放子类对象 \n 如果子类中没有堆区数据，可以不写为虚析构或者纯虚析构 \n 拥有纯虚析构的类也是抽象类 \n \n **3.7.6 多态案例三 - 电脑组装 ** \n 案例描述： \n 电脑主要组成部件为CPU（用于计算），显卡（用于显示），内存条（用于存储） \n 将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商 \n 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口 \n 测试时组装三台不同的电脑进行工作 \n  \n 示例： \ninclude   <iostream> \n using   namespace  std ; \n\n //抽象出每个零件的类 \n //抽象CPU \n class   CPU   { \n public : \n     virtual   void   calculate ( )   =   0 ; \n } ; \n\n //抽象显卡 \n class   VideoCard   { \n public : \n     virtual   void   display ( )   =   0 ; \n } ; \n\n //抽象内存条 \n class   Memory   { \n public : \n     virtual   void   storage ( )   =   0 ; \n } ; \n\n //组装电脑 \n class   Computer   { \n public : \n     Computer ( CPU  * cpu ,  VideoCard  * vc ,  Memory  * mem )   { \n        m_cpu  =  cpu ; \n        m_vc  =  vc ; \n        m_mem  =  mem ; \n     } \n\n     //工作函数 \n     void   work ( )   { \n        m_cpu -> calculate ( ) ; \n        m_mem -> storage ( ) ; \n        m_vc -> display ( ) ; \n     } \n\n     //提供析构函数释放三个电脑的零件 \n     ~ Computer ( )   { \n         if   ( m_cpu  !=   NULL )   { \n             delete  m_cpu ; \n            m_cpu  =   NULL ; \n         } \n         if   ( m_mem  !=   NULL )   { \n             delete  m_mem ; \n            m_mem  =   NULL ; \n         } \n         if   ( m_vc  !=   NULL )   { \n             delete  m_vc ; \n            m_vc  =   NULL ; \n         } \n     } \n\n private : \n    CPU  * m_cpu ;   //cpu零件指针 \n    VideoCard  * m_vc ;   //显卡零件指针 \n    Memory  * m_mem ;   //内存条零件指针 \n } ; \n\n //具体厂商 \n //Intel \n class   IntelCPU   :   public   CPU   { \n public : \n     void   calculate ( )   { \n        cout  <<   "Intel的CPU开始计算了"   <<  endl ; \n     } \n } ; \n\n class   IntelVideoCard   :   public   VideoCard   { \n public : \n     void   display ( )   { \n        cout  <<   "Intel的显卡开始显示了"   <<  endl ; \n     } \n } ; \n\n class   IntelMemory   :   public   Memory   { \n public : \n     void   storage ( )   { \n        cout  <<   "Intel的内存条开始存储了"   <<  endl ; \n     } \n } ; \n\n\n //Lenovo厂商 \n class   LenovoCPU   :   public   CPU   { \n public : \n     void   calculate ( )   { \n        cout  <<   "Lenovo的CPU开始计算了"   <<  endl ; \n     } \n } ; \n\n class   LenovoVideoCard   :   public   VideoCard   { \n public : \n     void   display ( )   { \n        cout  <<   "Lenovo的显卡开始显示了"   <<  endl ; \n     } \n } ; \n\n class   LenovoMemory   :   public   Memory   { \n public : \n     void   storage ( )   { \n        cout  <<   "Lenovo的内存条开始存储了"   <<  endl ; \n     } \n } ; \n\n void   test01 ( )   { \n     //第一台电脑零件 \n    CPU  * intelCPU  =   new  IntelCPU ; \n    VideoCard  * intelVC  =   new  IntelVideoCard ; \n    Memory  * intelMemory  =   new  IntelMemory ; \n\n     //创建第一台电脑 \n    Computer  * computer1  =   new   Computer ( intelCPU ,  intelVC ,  intelMemory ) ; \n    computer1 -> work ( ) ; \n     delete  computer1 ;   //堆区零件需要释放，所以加上析构函数 \n\n     //Lenovo厂商 \n    Computer  * computer2  =   new   Computer ( new  LenovoCPU ,   new  LenovoVideoCard ,   new  LenovoMemory ) ; \n    computer2 -> work ( ) ; \n     delete  computer2 ; \n } \n\n int   main ( )   { \n     test01 ( ) ; \n     return   0 ; \n } \n 4 函数提高 \n 4.1 函数默认参数 \n 在C++语法中，函数的形参列表中的形参是可以有默认值的。 \n 语法： 返回值类型 函数名 (参数 = 默认值) {} \n 示例： \n int   func ( int  a ,   int  b  =   10 ,   int  c  =   10 )   { \n     return  a  +  b  +  c ; \n } \n //1. 如果某个位置参数有默认值，那么这个位置往后，从左往右，必须都要有默认值 \n //2. 如果函数声明有默认值，函数实现的时候就不能有默认参数 \n int   func ( int  a  =   10 ,   int  b  =   10 ) ; \n int   func ( int  a ,   int  b )   { \n     return  a  +  b ; \n } \n 4.2 函数的占位参数 \n C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置 \n 语法： 返回值类型 函数名 (数据类型) {} \n //函数占位时，占位参数也可以有默认参数 \n void   func ( int  a  =   10 ,   int )   { \n    cout  <<   "this is a func"   <<  endl ; \n } \n\n int   main ( )   { \n     func ( 10 ,   10 ) ; //占位必须补参 \n     return   0 ; \n } \n\n //占位参数也可以有默认参数 \n void   func ( int  a ,   int   =   10 )   { \n    cout  <<   "this is a func"   <<  endl ; \n } \n\n int   main ( )   { \n     func ( 10 ) ; //有默认参数则可不用补参 \n     return   0 ; \n } \n 4.3 函数重载 \n **作用：**函数名可以相同，提高复用性 \n 函数重载满足条件： \n \n \n 同一个作用域下 \n \n \n 函数名相同 \n \n \n 函数参数 类型不同  或  个数不同  或  顺序不同 \n int   func ( int  a ,   int  b ) ; \n int   func ( int  a ,   int  b ,   int  c ) ; \n int   func ( float  a ,   int  b ) ; \n int   func ( int  a ,   float  b ) ; \n \n \n \n **注意：**函数返回值不可以作为函数重载条件 \n 注意事项： \n \n \n 引用作为函数重载条件：引用作为重载条件 ，加const和不加const也能作为重载条件（注意，是引用时才能用const来区分） \n int   func ( int   & a ) ; \n int   func ( const   int   & a ) ; \ninclude <iostream> \n using   namespace  std ; \n void   fun ( int   & a ) { \n    cout << "1" << endl ;  \n }  \n void   fun ( const   int   & a ) { \n    cout << "2" << endl ;  \n }  \n int   main ( ) { \n\t int  a  =   10 ; \n     fun ( a )   ; \n     fun ( 10 ) ; //const int &a=10; \n     //相当于临时建一个变量t=10,让&a=t;  \n     return   0 ; \n } \n // 输出 1 和 2 \n \n \n PS: 这种情况不能使用 \n \n \n \n 函数重载碰到函数默认参数 \n 正确情况 \ninclude <iostream> \n using   namespace  std ; \n void   fun ( int  a )   { \n    cout << "1" << endl ;  \n }  \n void   fun ( int  a , int  b )   { \n    cout << "2" << endl ;  \n }  \n\n int   main ( )   { \n     fun ( 10 ) ; //调用函数1  \n     return   0 ; \n } \n // 输出1 \n \n 错误情况 \n void   fun ( int  a ) ; \n void   fun (   int  a , int  b  =   0 ) ;   // 此时编译器无法区分 \n \n \n 出现二义性错误 \n \n \n \n 关于函数名修饰，详情参看博客 ： C++基础之函数重载 \n \n Linux下函数重载修饰的规则： \n 从代码到程序经过 预处理，编译，汇编，链接 几个过程，C++为了支持函数重载在编译阶段对函数名做了修饰，即名字修饰。Windows下修饰比较复杂，Linux下修饰比较容易。 \n \n _Z+函数名长度+函数名+形参类型\n形参类型：\ni int\nf float\nc char\npi *int\n其它照此类推 \n C++Primer部分内容 \n 5 顺序容器 \n 5.1 额外的string操作 \n \n 可能的原因： \n 我想了一下，可能是由于没有空字符结束，所以这里就直接在字面值常量存放的内存区域（.rodata）中拷贝，直到遇到第一个空字符\'\\0\'就结束拷贝，而之所以为"HiHello World!!!"是因为"Hi"是.rodata段已被使用空间的末尾，然后偏移量指针就回到(.rodata段的)开头继续向后遍历拷贝直到遇到第一个\'\\0\' \n IO库 \ninclude   <csdtio> \ninclude   <iostream> \ncout  <<   3   <<  endl ;   // endl输出一个换行换行刷新缓冲区 \ncout  <<   1   <<  ends ;   // ends向缓冲区插入一个空字符，然后刷新缓冲区 \ncout  <<   2   <<  flush ;   // flush刷新缓冲区，但不输出任何额外字符 \n 补充 \n 关于extern关键字 \n 具体可以参考文章  extern关键字的作用 \n 凡是没有带extern的声明同时也都是定义 \n extern的三种用法 \n 非常量全局变量的外部链接 \n 最常见的用法，当链接器在一个全局变量声明前看到extern关键字，它会尝试在其他文件中寻找这个变量的定义。这里强调全局且非常量的原因是，全局非常量的变量默认是外部链接的。 \n //fileA.cpp \n int  i  =   1 ;           //声明并定义全局变量i \n\n //fileB.cpp \n extern   int  i ;      //声明i，链接全局变量 \n\n //fileC.cpp \n extern   int  i  =   2 ;          //错误，多重定义 \n int  i ;                      //错误，这是一个定义，导致多重定义 \n int   main ( ) \n { \n     extern   int  i ;          //正确 \n     int  i  =   5 ;              //正确，新的局部变量i; \n } \n \n 常量全局变量的外部链接 \n 常量全局变量默认是内部链接的，所以想要在文件间传递常量全局变量需要在定义时指明extern，如下所示： \n //fileA.cpp \n extern   const   int  i  =   1 ;          //定义 \n\n //fileB.cpp                    //声明 \n extern   const   int  i ; \n \n extern "C" 和extern "C++"函数声明 \n 在C++中，当与字符串连用时，extern指明当前声明使用了其他语言的链接规范，如extern "C"，就指明使用C语言的链接规范。原因是，C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时无法找到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。C和C++对函数的处理方式是不同的.extern "C"是使C++能够调用C写作的库文件的一个手段，如果要对编译器提示使用C的方式来处理函数的话，那么就要使用extern "C"来说明。 \n 示例： \n // 声明printf函数使用C链接 \n extern   "C"   int   printf ( const   char   * fmt ,   . . . ) ; \n\n\n //声明指定的头文件内所有的东西都使用 C 链接 \n extern   "C"   { \ninclude   <stdio.h> \n } \n\n //  声明函数ShowChar和GetChar使用 C 链接 \n extern   "C"   { \n     char   ShowChar ( char  ch ) ; \n     char   GetChar ( void ) ; \n } \n\n //  定义函数 ShowChar 和 GetChar 使用 C 链接 \n extern   "C"   char   ShowChar ( char  ch )   { \n     putchar ( ch ) ; \n     return  ch ; \n } \n\n extern   "C"   char   GetChar ( void )   { \n     char  ch ; \n    ch  =   getchar ( ) ; \n     return  ch ; \n } \n\n // 声明全局变量 errno 为C链接 \n extern   "C"   int  errno ; \n\n //又比如，在程序中常见的代码段 \nifdef   __cplusplus   \n extern   "C"   {   \nendif    \n  \n /**** some declaration or so *****/   \nifdef   __cplusplus   \n }   \nendif \n\n //这里__cplusplus是cpp中的自定义宏，定义了这个宏就表明这是一段cpp的代码，也就是说， \n //上面的代码的含义是:如果这是一段cpp的代码，那么加入extern "C"{和}处理其中的代码。 \n \n '},{title:"进阶数据结构专题",frontmatter:{},regularPath:"/algorithm/3_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",relativePath:"algorithm/3_数据结构.md",key:"v-608b7a94",path:"/algorithm/3_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",headers:[{level:2,title:"平衡二叉树AVL",slug:"平衡二叉树avl"},{level:3,title:"AVL树-四种失衡类型",slug:"avl树-四种失衡类型"},{level:3,title:"SB树（Size Balanced 树）",slug:"sb树-size-balanced-树"}],content:' 进阶数据结构专题 \n 平衡二叉树AVL \n 名称：AVL树 \n 发明者： \n ​\t\t G.M.  A delson- V elsky  &  E.M.  L andis \n 年代： 1962年（55岁） \n 性质： \n $|H(left) - H(right)| <= 1$ \n 优点： \n 由于对每个节点的左右子树的树高做了限制，所以整棵树不会退化成一个链表 \n 问题： \n \n \n 高度为H的BS树，所含的节点数量在什么范围内？ \n $H <= SIZE(h) <= 2^n - 1$ \n \n \n 高度为H的AVL树，所包含的节点数量在什么范围之内？ \n **low(h)**表示高度为h，AVL树所包含的最少节点的数量。 \n 所以 $2^h - 1 >= size(h) >= low(h - 1) + low(h - 2) + 1$ \n 因为左右子树差别为1，所以包含的节点数下限为 low(h - 1) (高一层子树的最少节点)，加上  high(h - 2) (矮一层子树的最少节点)， 加上  1  (一个根节点) \n $low(1) = 1, low(2) = 2, low(3) = 4, ...$  从3开始就可以往后递推了（斐波那契数列）增长趋势为 $1.618^n \\approx 1.5^n$ \n \n \n 所以 AVL树提高了树形结构查找下限，保证logN。 \n AVL树操作： \n \n \n 左旋 \n \n 左旋将原先根节点的右孩子置为根节点 \n 将原先的根节点置为左孩子 \n 将原先右孩子的左子树置为原先根节点的右子树（因为它上的所有值都比这个原先的根节点都大 \n \n \n \n \n 右旋：左旋的逆操作 \n \n 将原先根节点的左孩子置为根节点 \n 将原先根节点置为右孩子 \n 将原先左孩子的右子树置为新的右孩子的左子树 \n \n \n \n ​\t  \n AVL树-四种失衡类型 \n LL型 ： 左孩子的左子树树高高一点 \n RR型 ：右孩子的右子树树高高一点 \n LR型 ： 左孩子的右子树树高高一点 \n RL型 ： 右孩子的左子树树高高一点 \n \n **对于LL型：**右旋 \n \n $$\nhk_1 = hk_2 + 1 \\\nhk_2 = hk_3 + 2 \\\nh_A = h_B + 1 \\\nhk_3 = max(h_C, h_D) + 1 \\\nh_A = max(h_C, h_D) + 2\n$$ \n **对于RR型：**是LL型镜像，左旋即可。 \n 对于LR型： \n   $$h_{k_1} = h_{k_2} + 1 \\ h_{k_2} = h_D + 2 \\ h_{k_2} = h_{k_3} + 1 \\ h_{k_3} = h_A + 1 \\ h_{k_3} = max(h_B, h_C) + 1 \\ h_A + 1 = max(h_B, h_C) + 1 \\ \\therefore h_A = max(h_B, h_C) = h_D$$ \n \n \n LR->先左旋左子树->LL \n \n 2.LL->再右旋整个树 \n \n \n **对于RL型：**是LR的镜像，先右旋右子树，再大左旋 \n 实现代码 \ninclude   <iostream> \ninclude   <cstdio> \ninclude   <cstdlib> \n using   namespace  std ; \n\n struct   Node   { \n     int  key ,  h ; \n    Node  * lchild ,   * rchild ; \n     // Node() : key(0), h(0), lchild(nullptr), rchild(nullptr) {}; \n     // Node(int _key) : key(_key), h(1), lchild(nullptr), rchild(nullptr) {} \n } ; \n\n // decrease the judge cases, we can do like the following: \n // use NIL to replace all the nullptr \nNode __NIL ; \ndefine   NIL   ( & __NIL ) \n __attribute__ ( ( constructor ) )   // make NIL extand in advance \n void   init_NIL ( )   { \n    NIL -> key  =   0 ,  NIL -> h  =   0 ;  \n    NIL -> lchild  =  NIL -> rchild  =  NIL ; \n     return   ; \n } \n\n inline   int   H ( Node  * root )   { \n     return  root  !=  NIL  ?  root -> h  :   0 ; \n } \n\n inline   int   KEY ( Node  * root )   { \n     return  root  !=  NIL ?  root -> key  :   0 ; \n } \n\nNode  * getNewNode ( int  val )   { \n    Node  * p  =   ( Node  * ) malloc ( sizeof ( Node ) ) ; \n    p -> key  =  val ; \n    p -> h  =   1 ; \n    p -> lchild  =  p -> rchild  =  NIL ; \n     return  p ; \n } \n\n // when we insert a node, we need to update the height \n void   update_height ( Node  * root )   { \n     int  h1  =   H ( root -> lchild ) ; \n     int  h2  =   H ( root -> rchild ) ; \n    root -> h  =   ( h1  >  h2  ?  h1  :  h2 )   +   1 ; \n     return   ; \n } \n\n // right rotate \nNode  * right_rotate ( Node  * root )   { \n    Node  * tmp  =  root -> lchild ; \n    root -> lchild  =  tmp -> rchild ;   //  \n    tmp -> rchild  =  root ; \n     update_height ( root ) ;   // root as child \n     update_height ( tmp ) ;   // tmp as new root \n     return  tmp ;   // be marked as root \n } \n\n // left rotate  \nNode  * left_rotate ( Node  * root )   { \n    Node  * tmp  =  root -> rchild ; \n    root -> rchild  =  tmp -> lchild ; \n    tmp -> lchild  =  root ; \n     update_height ( root ) ;   // root as left child \n     update_height ( tmp ) ;   // tmp as new root \n     return  tmp ; \n } \n\nNode  * maintain ( Node  * root )   {   // need to judge the pointer exist, so we change nullptr to NIL \n     if   ( abs ( H ( root -> lchild )   -   H ( roo\n                                t -> rchild ) )   <=   1 )   return  root ; \n     if   ( root -> lchild -> h  >  root -> rchild -> h )   { \n         if   ( root -> lchild -> rchild -> h  >  root -> lchild -> lchild -> h )   {   // LR \n            root -> lchild  =   left_rotate ( root -> lchild ) ; \n         } \n        root  =   right_rotate ( root ) ;   // LL or LR \n     }   else   { \n         if   ( root -> rchild -> lchild -> h  >  root -> rchild -> rchild -> h )   {   // RL \n            root -> rchild  =   right_rotate ( root -> rchild ) ; \n         } \n        root  =   left_rotate ( root ) ;   // RR or RL \n     } \n     return  root ; \n } \n\nNode  * insert ( Node  * root ,   int  val )   { \n     if   ( root  ==  NIL )   return   getNewNode ( val ) ; \n     if   ( root -> key  ==  val )   return  root ; \n     else   if   ( root -> key  >  val )   { \n        root -> lchild  =   insert ( root -> lchild ,  val ) ; \n     }   else   { \n        root -> rchild  =   insert ( root -> rchild ,  val ) ; \n     } \n     update_height ( root ) ; \n     return   maintain ( root ) ; \n } \n\n // the root has two out-degree \nNode  * predecedure ( Node  * root )   { \n    Node  * l  =  root -> lchild ; \n     while   ( l -> rchild  !=  NIL )   { \n        l  =  l -> rchild ; \n     } \n     return  l ; \n } \n\nNode  * erase ( Node  * root ,   int  val )   { \n     if   ( root  ==  NIL )   return  NIL ; \n     if   ( root -> key  >  val )   { \n        root -> lchild  =   erase ( root -> lchild ,  val ) ; \n     }   else   if   ( root -> key  <  val )   { \n        root -> rchild  =   erase ( root -> rchild ,  val ) ; \n     }   else   if   ( root -> key  ==  val )   { \n         if   ( root -> lchild  ==  NIL  &&  root -> rchild  ==  NIL )   { \n             delete  root ; \n            root  =  NIL ; \n         }   else   if   ( root -> lchild  ==  NIL  ||  root -> rchild  ==  NIL )   { \n            Node  * tmp  =   ( root -> lchild  !=  NIL  ?  root -> lchild  :  root -> rchild ) ; \n             delete  root ; \n            root  =  NIL ; \n             return  tmp ; \n         }   else   { \n            Node  * pre  =   predecedure ( root ) ; \n            root -> key  =  pre -> key ; \n            root -> lchild  =   erase ( root -> lchild ,  pre -> key ) ; \n         } \n     } \n     return  root ;   // the hidden case is that if val was not found, nothing would be changed. \n } \n\n void   clear ( Node  * root )   { \n     if   ( root  ==  NIL )   return   ; \n     clear ( root -> lchild ) ; \n     clear ( root -> rchild ) ; \n     delete  root ; \n    root  =  NIL ; \n     return   ; \n } \n\n void   output ( Node  * root )   { \n     if   ( root  ==  NIL )   return   ; \n     output ( root -> lchild ) ; \n    cout  <<  root -> key  <<   " -> " ; \n     output ( root -> rchild ) ; \n     return   ; \n } \n\n void   outS ( Node  * root )   { \n     if   ( root  ==  NIL )   return   ; \n    cout  <<   KEY ( root )   <<   "["   <<  root -> h  <<   "]"   <<   "("   <<   KEY ( root -> lchild )   <<   ", "   <<   KEY ( root -> rchild )   <<   ")"   <<  endl ; \n     outS ( root -> lchild ) ; \n     outS ( root -> rchild ) ; \n     return   ; \n } \n\n int   main ( )   { \n     int  op ,  val ; \n    Node  * root  =  NIL ; \n     while   ( cin  >>  op  >>  val )   { \n         switch   ( op )   { \n             case   1 :  root  =   insert ( root ,  val ) ;   break ; \n             case   2 :  root  =   erase ( root ,  val ) ;   break ; \n         } \n         output ( root ) ; \n        cout  <<  endl ; \n         outS ( root ) ; \n        cout  <<  endl  <<   "-----------------------------"   <<  endl ; \n     } \n     return   0 ; \n } \n SB树（Size Balanced 树） \n 性质： \n$$\nSize(left) >= Size(right ->left) \\\nSize(left) >= Size(right ->right) \\\nSize(right) >= Size(left ->left) \\\nSize(right) >= Size(left -> right)\n$$\n**优点：**由于对每个节点的左右子树的节点数量做了限制，所以整棵树不会退化成一个链表 \n 思考： \n \n 高度为H的BS树（二叉搜索树），所包含的节点数量在什么范围之内？ \n 高度为H的SB树，所包含的节点数量在什么范围之内？ \n \n'},{title:"计算机体系结构",frontmatter:{},regularPath:"/cs-basis/6_%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html",relativePath:"cs-basis/6_计算机体系结构.md",key:"v-3899f2b6",path:"/cs-basis/6_%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html",headers:[{level:2,title:"存储器层次结构",slug:"存储器层次结构"},{level:3,title:"整体概览",slug:"整体概览"},{level:3,title:"存储技术",slug:"存储技术"}],content:" 计算机体系结构 \n 存储器层次结构 \n 本章关键词： 存储技术 、 局部性 、 存储器层次结构 、 高速缓存存储器 、 编写高速缓存友好的代码 、 存储器山 \n 整体概览 \n 存储器系统（memory system)  是一个具有 许多不同容量、成本和访问时间的存储设备 的 层次结构。 \n 从 快到慢 、小到大 、贵到便宜 内到外分别是： \n \n CPU寄存器 ：保存着最常用的数据。 \n 高速缓存存储器(L1~L3 Cache) : CPU与主存之间，存放 相对慢速的主存储器中的一部分数据和指令。 \n 主存储器(main memory) : 存储来自更慢更大的磁盘上已经持久化的数据。 \n 外存(磁盘、固态硬盘...) : 存放持久化数据，通常也作为 通过网络连接的主机之间 进行数据传输的 缓冲区域。 \n \n 存储器层次结构整体 （CSAPP中文3版-P421） \n \n Intel Core i7 的高速缓存结构  （CSAPP中文3版-P438） \n \n Regs: register 寄存器 \n d-cache: data cache，只保存数据 \n i-cache: introduction cache，只保存指令 \n 这个层次结构的一个有趣的特性是所有的 SRAM高速缓存存储器都 在 CPU 芯 片上。 \n 存储技术 \n 目前的存储技术主要有： SRAM 存储器、 DRAM 存储器、 ROM 存储器以及 旋转 和 固态 的硬盘 \n **随机访问存储器(Random Access Memory, RAM)**有两类 \n \n \n 静态的(Static RAM,  SRAM ) \n \n 每个位存储于一个  双稳态(bistable) 存储器单元里。其通过一个 六晶体管 电路来实现。 \n 该电路可以无限期保持在两个不同的电压配置或者状态。 \n 也就是说， 只要有电，它就会永远地保持它的值。 \n \n \n \n 动态的(Dynamic RAM,  DRAM ) \n \n DRAM的每个位通过对一个电容充电来区分01 \n 其 每个单元由一个电容和一个晶体管组成 ，所以可以很密集 \n 但DRAM单元容易 漏电 ，通常会在10~100毫秒内失去电荷 \n 幸运的是计算机运行时钟周期通常是以纳秒来计算，所以 内存系统需要周期性地通过读出、重写来刷新每一位 。 \n \n CSAPP中文3版-P401 \n \n \n \n 传统DRAM \n DRAM 芯 片 中的单元 （位） 被分成 d个超单元 (supercell)， 每个超单元都由 w个 DRAM 单元组成 。 一个d X w的 DRAM 总共存储 了 dw 位信息。 \n 超单元被组织成一个r行c列的长 方形阵列 ， 这里rc=d 。 每个超单元有形如（i，j）的地址， 这里i表示行， 而 j 表示列。 \n e.g. 如下图： \n 16个超单元，每个超单元存储8位 \n \n 取数据步骤 \n \n 根据addr，将指定地一整行数据复制到内部行缓冲区 \n 再根据addr指定地列号，将行缓冲中对应的超单元中的w位数据复制并发送到内存控制器 \n \n \n 为何发送两次？ \n DRAM被组织成二维阵列而不是线性数组， 降低 了芯片上 地址引脚的数量 。 缺点 就是必须 分两步发送地址，这增加了访问时间 。 \n \n 内存模块 \n DRAM作为计算机的主存。 \n 多个DRAM芯片一起封装在**内存模块（memory module）**中，它插到主板的扩展槽上。 \n 每一个64位数据分为8份（每份1字节8bit）存储在不同DRAM芯片的相同位置。下图展示了内存模块的基本思想： \n \n \n 64位处理器，一次处理64位数据，这64位数据分8个字节存储在8个不同DRAM芯片的相同位置 \n \n 增强的DRAM \n \n \n 双倍数据速率同步DRAM（Double Data-Rate Synchronous DRAM，DDR SDRAM） \n 使用两个时钟沿作为控制信号，从而让DRAM的速度翻倍 \n 不同类型的DDR SDRAM是用提高  预取缓冲区  有效带宽大小来划分的： \n DDR(2位)，DDR2(4位)，DDR3(8位)，DDR4(16位) \n \n \n 非易失性存储器 \n DRAM和SRAM在断电后都会丢失信息，所以它们都是 易失的 (volatile) \n 非易失性存储器 就是即使断电，仍然可以保留信息。由于历史原因，这类存储器整体多是  只读存储器（Read-Only Memory，ROM） ，所以一般也称为ROM。 \n 分类如下： \n \n \n PROM ( Programmable ROM , 可编程 ROM)  只能被编程一次 \n \n PROM 的每个存储器单元有一种熔丝( fuse) ， 只能用高电流熔断一次。 \n \n \n \n 可擦写可编程ROM  (Erasable Programmable ROM ,  EPROM )， 可编程 1000 次 \n \n 有一个透明的石英窗口，允许光到达存储单元 。紫外线光照射过窗 口，EPROM 单元就被清除为0。对 EPROM 编程是通过使用一种把 1 写入EPROM 的特殊设备来完成的。 \n \n \n \n 电子可擦除PROM (Electrically Erasable  PROM ,  EEPROM )，可编程 $10 ^ 5$ 次 \n \n 它不需要一个物理上独立的编程设备， 因此可以直接在印制电路卡上编程。 \n \n \n \n 闪存(flash memory) ， 基于EEPROM \n \n 闪存是非易失性存储器，是一种 重要的存储技术 ，为大量的电子设备提供快速而持久的非易失性存储，固态硬盘(SSD)就是基于闪存的。 \n \n \n \n 存储在 ROM 设备中的程序通常被称为  固件( firmware)  。 \n \n 当一个计算机系统通电以后， 它会运行存储 在 ROM 中的固件。 一 些 系统在 固件中提供了少 鼠基本的输 入 和输出函 数一例如 PC 的 BIOS（基本输入／输出系统）例程。复杂的设备，像图形卡和磁盘驱动控制器，也依赖固件翻译来自 CPU 的I/O（输入／输出） 请求 。 \n \n"},{title:"操作系统",frontmatter:{},regularPath:"/cs-basis/5_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html",relativePath:"cs-basis/5_操作系统.md",key:"v-bcb174f2",path:"/cs-basis/5_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html",headers:[{level:2,title:"虚拟内存与物理内存",slug:"虚拟内存与物理内存"},{level:2,title:"进程与线程",slug:"进程与线程"},{level:2,title:"malloc分配方式",slug:"malloc分配方式"},{level:3,title:"malloc有两种分配方式，brk() 和 mmap()",slug:"malloc有两种分配方式-brk-和-mmap"},{level:3,title:"malloc是直接物理分配么？",slug:"malloc是直接物理分配么"},{level:3,title:"为什么不全部使用malloc分配？",slug:"为什么不全部使用malloc分配"},{level:3,title:"为什么不全部用brk来分配？",slug:"为什么不全部用brk来分配"},{level:3,title:"free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？",slug:"free-函数只传入一个内存地址-为什么能知道要释放多大的内存"},{level:2,title:"网路系统",slug:"网路系统"},{level:3,title:"什么是DMA技术？",slug:"什么是dma技术"},{level:3,title:"如何优化文件传输性能？",slug:"如何优化文件传输性能"},{level:3,title:"如何实现零拷贝？",slug:"如何实现零拷贝"},{level:3,title:"使用零拷贝的项目",slug:"使用零拷贝的项目"},{level:3,title:"I/O 多路复用",slug:"i-o-多路复用"},{level:3,title:"高性能网络模型：Reactor 和 Proactor",slug:"高性能网络模型-reactor-和-proactor"},{level:3,title:"一致性哈希",slug:"一致性哈希"},{level:3,title:"",slug:""}],content:' 操作系统 \n 主要为经典面试题，大部分来自小林coding。 \n 虚拟内存与物理内存 \n 见博客  进程与线程的对比 \n Linux用户空间内存结构 \n \n \n 程序文件段，包括二进制可执行代码； \n 已初始化数据段，包括静态常量； \n 未初始化数据段，包括未初始化的静态变量； \n 堆段，包括动态分配的内存，从低地址开始向上增长； \n 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关 ）； \n 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是  8 MB 。当然系统也提供了参数，以便我们自定义大小； \n \n 在这 6 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的  malloc()  或者  mmap()  ，就可以分别在堆和文件映射段动态分配内存。 \n 虚拟内存 与 物理内存 \n 虚拟内存是操作系统为每个进程提供的一种抽象，每个进程都有属于自己的、私有的、地址连续的 虚拟内存 ，当然我们知道最终进程的数据及代码必然要放到 物理内存 上，那么必须有某种机制能记住虚拟地址空间中的某个数据被放到了哪个物理内存地址上，这就是所谓的 地址空间映射 ，也就是虚拟内存地址与物理内存地址的映射关系。 \n 操作系统实现虚拟内存到物理内存的映射方式： 页表 \n 页表中记录了虚拟内存地址到物理内存地址的映射关系。 \n 把虚拟地址转换为物理地址需要查找页表 ，页表查找是一个 很慢 的过程，因此通常使用： \n  Cache来缓存常用的地址映射，这样可以加速页表的查找，这个Cache就是TLB \n TLB本质上就是一个cache，是用来加速页表查找的 。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么： \n  当进程切换后页表也要进行切换，页表切换后TLB就失效了 \n  cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢 \n 表现出来的就是程序运行会变慢 ，而 线程切换则不会导致TLB失效 ， 因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。 \n 总结： \n 每个进程拥有自己的、私有的、连续的虚拟内存，而同一进程下的线程共享同一块虚拟内存。 \n 虚拟内存靠页表来存储与物理内存的映射关系，它们的转换需要查找页表，同时还通过Cache（此处是TLB）存储一些常用的映射关系来加快虚拟内存与物理内存的转换；但是进程切换会切换虚拟内存，因此TLB就失效了，这导致Cache命中率降低，虚拟地址与物理地址的转换就变慢，进而引起程序运行速度下降；而切换线程不会切换虚拟内存空间，所以就不会引起内存的转换。 \n 进程与线程 \n \n 需要了解一下 进程, 线程状态转换, 信息的保存 \n 要熟悉一下 PCB进程控制块 以及 寄存器 和 计数器 \n \n 进程与线程的本质区别： \n 进程是操作系统资源分配的最基本单位，而线程是任务调度和执行的基本单位。 \n 进程具体知识见博客： \n 【操作系统/OS笔记08】进程的定义、组成、PCB、生命周期管理、状态变化模型、挂起模型 \n 进程拥有的资源 \n 进程拥有的资源都存放在 $PCB(Process , Control , Block)$ 中，PCB也是进程的唯一标识。其控制的资源包括： \n \n \n 进程标识符 \n \n 外部标识符 ：方便用户对进程的访问。PID \n 内部标识符 ：方便操作系统对进程的使用，即OS赋予每个进程唯一的数字标识，它通常是一个进程的序号。 \n \n \n \n 处理机状态（又称进程上下文） \n \n 通用寄存器 ：又称用户可视寄存器，可以被用户程序访问，用于暂存信息。 \n 指令计数器 ：存放要访问的下一条指令的地址。 \n 程序状态字寄存器 $PSW(Process , State , Word)$：存放状态信息（如条件码、执行方式、中断屏蔽标志等） \n 用户栈指针寄存器 ：每个用户进程都有一个或者多个与之相关的系统栈，用于存放进程和系统的  调用参数及调用地址 。栈指针指向该栈的栈顶。 \n \n 当处理机处于执行状态时，正在处理的许多信息都存放在寄存器中；而当寄存器被切换时，处理机的咋状态信息都存放在PCB中，以便在该进程被重新调度时，能再从断点处继续执行。 \n \n \n 进程调度信息 \n \n 进程状态 ：创建，**就绪（静态[被挂起]-活动就绪[被激活]），执行，阻塞（静态[被挂起]-活动[被激活]就绪），**终止 \n 进程优先级 ：进程抢占处理机的优先级 \n 进程调度所需其它信息 ：进程已等待CPU时间总和、进程已执行时间总和等；这些信息与它们所采用的调度算法相关 \n 事件 ：进程阻塞的原因，详细描述就是 进程由执行状态转换为阻塞状态所等待发生的事件。 \n \n \n \n 进程控制信息 \n \n 程序和数据的地址 ：进程中程序和数据的内存或外存起始地址，便于再次调度该进程时快速从PCB中找到程序与数据。 \n 进程同步和通信机制 ：实现进程同步或通信时所必须的机制，如消息队列指针、信号量等的全部或部分会放入PCB。 \n 资源清单 ：列出进程在运行期间所需的全部资源（除CPU外） \n 链接指针 ：给出本进程所在队列的下一个进程PCB的起始地址。（也是PCB通过链表组织的实现结构） \n \n \n \n 控制线程同步的方法 \n 有那几种锁 \n 线程池的实现？ \n malloc分配方式 \n 见小林coding博客  malloc是如何分配内存的 \n malloc有两种分配方式， brk()  和  mmap() \n \n 当分配内存大于128kb时会调用brk， 通过将「堆顶」指针向高地址移动，获得新的内存空间；且释放的空间 不归还给操作系统 ，而是缓存在malloc的内存池中 \n 申请内存大于128kb时调用 mmap()，通过mmap()系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存；free后空间 归还给操作系统 ，这块虚拟内存不再属于该进程 \n \n 注意，不同的 glibc 版本定义的阈值也是不同的。 \n  malloc是直接物理分配么？ \n malloc分配不是直接物理分配的，malloc分配的是虚拟内存 ，如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了。 \n 只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。 \n  为什么不全部使用malloc分配？ \n 首先是避免频繁系统调用 \n 因为向操作系统申请内存，是要通过系统调用的，执行系统调用是要进入内核态的，然后在回到用户态，运行态的切换会耗费不少时间。 \n 所以，申请内存的操作应该避免频繁的系统调用，如果都用 mmap 来分配内存，等于每次都要执行系统调用。 \n 其次是减少缺页中断 \n 因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。会导致CPU消耗过大。 \n 改进这两个问题 \n malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。 \n **等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数。**降低CPU消耗。 \n 为什么不全部用brk来分配？ \n 前面我们提到通过 brk 从堆空间分配的内存，并不会归还给操作系统，那么我们那考虑这样一个场景。 \n 如果我们连续申请了 10k，20k，30k 这三片内存，如果 10k 和 20k 这两片释放了，变为了空闲内存空间，如果下次申请的内存小于 30k，那么就可以重用这个空闲内存空间。（此时就是在内存池中重用） \n 但是如果下次申请的内存大于 30k，没有可用的空闲内存空间，必须向 OS 申请，实际使用内存继续增大。 \n 因此，随着系统频繁地 malloc 和 free ，尤其对于小块内存，**堆内将产生越来越多不可用的碎片，导致“内存泄露”。**而这种“泄露”现象使用  valgrind 是无法检测出来的 。 \n 所以，malloc 实现中，充分考虑了 brk 和 mmap 行为上的差异及优缺点，默认分配大块内存 (128KB) 才使用 mmap 分配内存空间。 \n free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？ \n 前面提到， malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节. \n 这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。 \n  \n 这样当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了。 \n 网路系统 \n 什么是DMA技术？ \n 没有DMA之前的I/O过程： \n \n CPU 发出对应的指令给磁盘控制器，然后返回； \n 磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个 中断 ； \n CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。 \n \n \n 整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。这很明显会影响CPU的工作效率，所以就有了    直接内存访问（Direct Memory Access） 技术。 \n 什么是DMA？ \n 在进行I/O设备和内存数据传输时，数据搬运的工作全部交给 DMA控制器 ，而CPU不再参与任何与数据搬运相关的事情，这样CPU就可以去处理别的事务。 \n 使用 DMA 控制器进行数据传输的过程如下： \n \n 具体过程： \n \n 用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态； \n 操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务； \n DMA 进一步将 I/O 请求发送给磁盘； \n 磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满； \n DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务 ； \n 当 DMA 读取了足够多的数据，就会发送中断信号给 CPU； \n CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回； \n \n 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。现代计算机中一般每个I/O设备都有自己的DMA控制器。 \n 如何优化文件传输性能？ \n 要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数 。 \n 1.先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？ \n 读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。 \n 而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。 \n 所以， 要想减少上下文切换到次数，就要减少系统调用的次数 。 \n 2.再来看看，如何减少「数据拷贝」的次数？ \n 在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。 \n 因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此 用户的缓冲区是没有必要存在的 。 \n 如何实现零拷贝？ \n 零拷贝的实现有两种方式： \n \n mmap + write \n sendfile \n \n mmap + write \n 在前面我们知道， read()  系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用  mmap()  替换  read()  系统调用函数。 \n buf  =   mmap ( file ,  len ) ; \n write ( sockfd ,  buf ,  len ) ; \n \n mmap()  系统调用函数会直接把内核缓冲区里的数据「 映射 」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。[进程内存模型，代码段，数据段（.data .bass），堆（低地址到高地址生长）， 文件映射区 ，栈（高地址到低地址生长），内核空间] mmap映射到文件映射区。 \n \n 具体过程如下： \n \n 应用进程调用了  mmap()  后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核**「共享」**这个缓冲区； \n 应用进程再调用  write() ，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据； \n 最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。 \n \n 通过使用  mmap()  来代替  read() ， 可以减少一次数据拷贝的过程。 \n 但这还不是最理想的零拷贝 ，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。 \n sendfile \n 在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数  sendfile() ，函数形式如下： \ninclude   <sys/socket.h> \nssize_t  sendfile ( int  out_fd ,   int  in_fd ,  off_t  * offset ,  size_t count ) ; \n \n 它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。 \n 首先，它可以替代前面的  read()  和  write()  这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。 \n 其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图： \n \n 但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（ The Scatter-Gather Direct Memory Access ）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。 \n 你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性： \n $  ethtool   -k  eth0  |   grep  scatter-gather\nscatter-gather: on\n \n 于是，从 Linux 内核  2.4  版本开始起，对于支持网卡支持 SG-DMA 技术的情况下，  sendfile()  系统调用的过程发生了点变化，具体过程如下： \n \n 第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里； \n 第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝； \n \n 所以，这个过程之中，只进行了 2 次数据拷贝，如下图： \n \n 这就是所谓的 零拷贝（ Zero-copy ）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。 \n 零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数， 只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。 \n 所以，总体来看， 零拷贝技术可以把文件传输的性能提高至少一倍以上。 \n 使用零拷贝的项目 \n Kafka，Nginx等。 \n 补充： \n \n PageCache：是磁盘和主存之间的缓存，用于缓存和预读磁盘中的数据，可以充分发挥程序的局部性。 \n 大文件传输：大文件不使用PageCache，PageCache只能缓存少量数据，造成命中率降低，这样造成巨大额外开销。 \n 使用异步I/O可以绕开PageCache \n \n 异步I/O的流程： \n \n 它把读操作分为两部分： \n \n 前半部分，内核向磁盘发起读请求，但是可以 不等待数据就位就可以返回 ，于是进程此时可以处理其他任务； \n 后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的 通知 ，再去处理数据； \n \n 我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。 \n 绕开 PageCache 的 I/O 叫 直接 I/O ，使用 PageCache 的 I/O 则叫 缓存 I/O 。 \n 大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。 \n 于是， 在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术 。 \n 直接 I/O 应用场景常见的两种： \n \n 应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启； \n 传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。 \n \n 另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化： \n \n 内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「 合并 」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作； \n 内核也会「 预读 」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作 \n \n 于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。 \n 所以，传输文件的时候，我们要根据文件的大小来使用不同的方式： \n \n 传输大文件的时候，使用「异步 I/O + 直接 I/O」； \n 传输小文件的时候，则使用「零拷贝技术」； \n \n 在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式： \n location  / video /   {  \n    sendfile on ;  \n    aio on ;  \n    directio  1024 m ;  \n } \n \n 当文件大小大于  directio  值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。 \n I/O 多路复用 \n socket四元组： \n TCP/IP协议用一个四元组来唯一确定一个连接： \n \n 服务器的IP \n 服务器的Port \n 客户端的IP \n 客户端的Port \n \n 服务器的IP和Port可以保持不变，只要客户端的IP和Port彼此不同就OK了。 \n 一个TCP连接的标记为一个四元组： \n (source_ip, source_port, destination_ip, destination_port) \n 即(源IP，源端口，目的IP，目的端口)四个元素的组合。 \n 进一步的理解： \n 也可以在同一个端口号和IP地址上绑定一个TCP套接字和一个UDP套接字 \n 原因在于端口号虽然一样，但由于协议不一样，所以端口是完全独立的 \n tcp/udp一般采用五元组来定位一个连接: \n src_ip, src_port, dest_ip, dest_port, protocol_type \n \n 一个端口号可以同时被两个使用udp或tcp的进程同时绑定吗? \n 可以 ，protocol_type不一样，不是两个相同的链接。 \n \n Linux系统调用socket \n 此处不聊socket的使用，只聊TCP使用socket的流程及每一步的作用 \n 服务端首先调用  socket()  函数，创建一个网络协议为 IPv4、传输协议为TCP的Socket文件描述符（sockfd），接着调用  bind()  函数，给这个Socket绑定一个IP地址和端口， 绑定这两个的目的是什么？ \n \n 绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。 \n 绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们； \n \n \n 总结bind()的目的就是，绑定ip:port，以便机器通过ip找到收到的数据包；通过port找到服务端机器上对应的进程。 \n \n 绑定完 IP 地址和端口后，就可以调用  listen()  函数进行监听，此时对应 TCP 状态图中的  listen ，如果我们要判定服务器中一个网络程序有没有启动，可以通过  netstat  命令查看对应的端口号是否有被监听。 \n 服务端进入了监听状态后，通过调用  accept()  函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。 \n 那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，调用  connect()  函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。 \n 在 TCP 连接的过程中， 服务器的内核 实际上为每个 Socket 维护了 两个队列 ： \n \n 一个是「还没完全建立」连接的队列，称为  TCP半连接队列 ，这个队列都是 没有完成三次握手 的连接，此时服务端处于  syn_rcvd  的状态； \n 一个是「已经建立」连接的队列，称为  TCP全连接队列 ，这个队列都是 完成了三次握手 的连接，此时服务端处于  established  状态 \n \n 当 TCP 全连接队列不为空后，服务端的  accept()  函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。 \n 注意，监听的 Socket 和真正用来传数据的 Socket 是两个： \n \n 一个叫作 监听 Socket ；（listen状态后的sockfd \n 一个叫作 已连接 Socket ；（accept返回的sockfd \n \n 连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过  read()  和  write()  函数来读写数据。 \n 至此， TCP 协议的 Socket 程序的调用过程就结束了，整个过程如下图： \n \n 看到这，不知道你有没有觉得读写 Socket 的方式，好像读写文件一样。 \n 是的，基于 Linux 一切皆文件的理念，在内核中 Socket 也是以「文件」的形式存在的，也是有对应的文件描述符。 \n 关于文件描述符 \n 文件描述符的作用是什么？ 每一个进程都有一个数据结构  task_struct ，该结构体里有一个指向「文件描述符数组」的成员指针。该数组里列出这个进程打开的所有文件的文件描述符。数组的下标是文件描述符，是一个整数，而数组的内容是一个指针，指向内核中所有打开的文件的列表，也就是说内核可以通过文件描述符找到对应打开的文件。 \n 然后 每个文件都有一个 inode ， Socket 文件的 inode  指向了 内核中的 Socket 结构 ，在这个结构体里有 两个队列 ，分别是 发送队列 和 接收队列 ，这个两个队列里面保存的是一个个  struct sk_buff ，用链表的组织形式串起来。 \n sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。 \n **你可能会好奇，为什么全部数据包只用一个结构体来描述呢？**协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头， 如果每一层都用一个结构体 ，那在层之间传递数据的时候， 就要发生多次拷贝 ，这将大大降低 CPU 效率。 \n 于是，为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中  data  的指针，比如： \n \n 当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb->data 的值，来逐步剥离协议首部。 \n 当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb->data 的值来增加协议首部。 \n \n 从下面这张图看到，当发送报文时，data 指针的移动过程。 \n \n 如何一台机器如何服务更多的用户？ \n 前面提到的 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是 同步阻塞 的方式，当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。 \n 可如果我们服务器只能服务一个客户，那这样就太浪费资源了，于是我们要改进这个网络 I/O 模型，以支持更多的客户端。 \n 在改进网络 I/O 模型前，我先来提一个问题，你知道服务器单机理论最大能连接多少个客户端？ \n 相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是： 本机IP, 本机端口, 对端IP, 对端端口 。 \n 服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以  最大 TCP 连接数 = 客户端 IP 数×客户端端口数 。 \n 对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是 服务端单机最大 TCP 连接数约为 2 的 48 次方 。 \n 这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制： \n \n 文件描述符 ，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目； \n 系统内存 ，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的； \n \n 那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？ \n 并发 1 万请求，也就是经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。 \n 从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。 \n 不过，要想真正实现 C10K 的服务器，要考虑的地方在于服务器的网络 I/O 模型，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。 \n 多进程模型 \n 基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用 多进程模型 ，也就是为每个客户端分配一个进程来处理请求。 \n 服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过  fork()  函数创建一个子进程，实际上就把父进程 所有 相关的东西都 复制 一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。 \n 这两个进程刚复制完的时候，几乎一模一样。不过，会根据 返回值 来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。 \n 正因为子进程会 复制父进程的文件描述符 ，于是就可以直接使用「已连接 Socket 」和客户端通信了， \n 可以发现，子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」。 \n 下面这张图描述了从连接请求到连接建立，父进程创建生子进程为客户服务。 \n \n 另外，当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成 僵尸进程 ，随着僵尸进程越多，会慢慢耗尽我们的系统资源。 \n 因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用  wait()  和  waitpid()  函数。 \n 这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为 每产生一个进程，必会占据一定的系统资源 ，而且 进程间上下文切换的“包袱”是很重的 ，性能会大打折扣。 \n 进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。 \n 多线程模型 \n 既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求 ——  多线程模型 。 \n 线程是运行在进程中的一个“逻辑流”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。 \n 当服务器与客户端 TCP 完成连接后，通过  pthread_create()  函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。 \n 如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。 \n 那么，我们可以使用 线程池 的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。 \n \n 需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。（多线程竞争也就是 惊群效应 ） \n 上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。 \n I/O多路复用 \n 既然为每个请求分配一个进程/线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是  I/O 多路复用 技术。 \n \n 一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。 \n 我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用， 进程可以通过一个系统调用函数从内核中获取多个事件 。 \n select/poll/epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。 \n select/poll/epoll 这是三个多路复用接口，都能实现 C10K 吗？接下来，我们分别说说它们。 \n select/poll \n select 实现多路复用的方式是，将已连接的 Socket 都放到一个 文件描述符集合 （这个文件描述符集合就是个数组），然后调用 select 函数将文件描述符集合 拷贝 到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过 遍历 文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合 拷贝 回用户态里，然后用户态还需要再通过 遍历 的方法找到可读或可写的 Socket，然后再对其处理。 \n 所以，对于 select 这种方式，需要进行  2 次「遍历」文件描述符集合 ，一次是在内核态里，一个次是在用户态里 ，而且还会发生  2 次「拷贝」文件描述符集合 ，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。 \n select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为  1024 ，只能监听 0~1023 的文件描述符。 \n poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以 链表 形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。 \n 但是 poll 和 select 并没有太大的本质区别， 都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合 ，这种方式随着并发数上来，性能的损耗会呈指数级增长。 \n epoll \n 先复习下 epoll 的用法。如下的代码中，先用 epoll_create 创建一个 epoll 对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait 等待数据。 \n int  s  =   socket ( AF_INET ,  SOCK_STREAM ,   0 ) ; \n bind ( s ,   . . . ) ; \n listen ( s ,   . . . ) \n\n int  epfd  =   epoll_create ( . . . ) ; \n epoll_ctl ( epfd ,   . . . ) ;   //将所有需要监听的socket添加到epfd中 \n\n while ( 1 )   { \n     int  n  =   epoll_wait ( . . . ) ; \n     for ( 接收到数据的socket ) { \n         //处理 \n     } \n } \n \n epoll 通过两个方面，很好解决了 select / poll 的问题。 \n 第一点 ，epoll 在内核里使用 红黑树来跟踪进程所有待检测的文件描述字 ，把需要监控的 socket 通过  epoll_ctl()  函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是  O(logn) 。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。 \n 第二点 ， epoll 使用 事件驱动 的机制，内核里 维护了一个链表来记录就绪事件 ，当某个 socket 有事件发生时，通过 回调函数 内核会将其加入到这个就绪事件列表中，当用户调用  epoll_wait()  函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。 \n 从下图你可以看到 epoll 相关的接口作用： \n \n 边缘触发和水平触发 \n epoll 支持两种触发模式， 边缘触发（edge-triggered, ET）和 水平触发（level-triggered, LT） \n \n 边缘触发 ：当被监控的 Socket 描述符上有可读事件发生时， 服务器只会从 epoll_wait 中苏醒一次 ，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此程序员要保证一次性将内核缓冲区的数据读完，如果该数据到达时没来得及处理，就直接丢弃； \n 水平触发 ：当被监控的 Socket 上有可读事件发生时， 服务器端不断地从 epoll_wait 中苏醒，知道内核缓冲区数据被 read 函数读取完毕才结束 ，目的是告诉我们有数据需要读取； \n \n 例如， \n 你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发； \n 如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。 \n 边缘触发一般搭配非阻塞I/O使用的原因？ \n \n 使用边缘触发时，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会循环从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时进程就会一直阻塞在读写函数那里，程序就没有办法往下继续执行。所以需要边缘触发要搭配非阻塞I/O使用，程序会一直执行 I/O 操作，直到系统调用（如  read  和  write ）返回错误，错误类型为  EAGAIN  或  EWOULDBLOCK 。 \n \n EAGAIN  就是当文件描述符为非阻塞模式时，read操作从中进行读取数据时没有数据可读，那么此时read操作不会阻塞在那里等待有数据可读，而是直接返回  EAGAIN  提示其进行下一次调用。（在VxWorks和Windows上，EAGAIN的名字叫做  EWOULDBLOCK ） \n 一般来说，边缘触发的效率比水平触发的效率要高的原因？ \n \n 因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。 \n \n select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。 \n 另外， 使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用 ，Linux 手册关于 select 的内容中有如下说明： \n \n Under Linux, select() may report a socket file descriptor as "ready for reading", while nevertheless a subsequent read blocks. This could for example happen when data has arrived but upon examination has wrong checksum and is discarded. There may be other circumstances in which a file descriptor is spuriously reported as ready. Thus it may be safer to use O_NONBLOCK on sockets that should not block. \n \n 博主 小林coding 翻译的结果： \n \n 在Linux下，select() 可能会将一个 socket 文件描述符报告为 "准备读取"，而后续的读取块却没有。例如，当数据已经到达，但经检查后发现有错误的校验和而被丢弃时，就会发生这种情况。也有可能在其他情况下，文件描述符被错误地报告为就绪。因此，在不应该阻塞的 socket 上使用 O_NONBLOCK 可能更安全。 \n \n 简单理解就是， 多路复用API返回的事件并不一定是可读写的 ，如果使用阻塞I/O，那么在调用 read/write 时则会发生程序阻塞 I/O，以便应对极少数的特殊情况。 \n I/O 多路复用总结 \n 最基础的 TCP 的 Socket 编程，它是阻塞 I/O 模型，基本上只能一对一通信，为了服务更多的用户，需要改进模型。 \n 这就引入了  多进程/多线程模型 ，每来一个客户端连接，就分配一个进程/线程，然后后续的读写都在对应的进程/线程，这种方式处理100个客户端没问题，但是当客户端增大到10000个时，10000个进程/线程的调度、上下文切换及它们占用的内存开销巨大，都会称为这种模型的性能瓶颈。 \n 为解决上述问题，就有了  I/O多路复用 ，可以只在 一个进程里处理多个文件的I/O ，Linux 下有三种提供了 I/O 多路复用的 API，分别是：select、poll、epoll。 \n select和poll没有本质区别，它们内部都是通过 ⌈线性结构⌋ 来存储进程监听的 Socket文件描述符集合。 \n 在使用时，首先需要把监听的 Socket 集合通过 select/poll 系统调用从用户态拷贝到内核态，然后由内核检测事件，当有网络事件产生时，内核需要遍历进程监听的 Socket 集合，找到对应的 Socket，并设置其状态为可读/可写，然后把整个 Socket 集合从内核态拷贝到用户态，然后由用户进程遍历监听的 Socket 集合找到可读/写的 Socket，然后对其处理。 \n select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越大，Socket 集合的遍历和拷贝会带来很大的开销，因此也很难应对 C10K。 \n epoll 是解决 C10K 问题的利器，通过两个方面解决了 select/poll 的问题。 \n \n epoll 内核使用了  红黑树  来存储进程所有待检测的 Socket，红黑树的增删查改效率都为 O(logn)较快，通过红黑树管理，不需要像 select/poll 一样每次都要将 socket 集合来回拷贝，极大减少了内核和用户空间的内存分配和数据拷贝。 \n epoll 是  事件驱动  的机制，内核中维护了一个  链表  来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。 \n \n 而且，epoll 支持边缘触发和水平触发的方式，而 select/poll 只支持水平触发，一般而言，边缘触发的方式会比水平触发的效率高。 \n 高性能网络模型：Reactor 和 Proactor \n Reactor 模式也叫  Dispatcher  模式，这个名字更贴合该模式的含义，即  I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程 。 \n Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成: \n \n Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件； \n 处理资源池负责处理事件，如read -> 业务逻辑 -> send; \n \n Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于： \n \n Reactor 的数量可以只有一个，也可以有多个； \n 处理资源池可以是单个进程 / 线程， 也可以是多个 进程 / 线程 \n \n 排列组合一下就是： \n \n 单 Reactor 单进程 / 线程； \n 单 Reactor 多进程 / 线程； \n 多 Reactor 单进程 / 线程； \n 多 Reactor 多进程 / 线程； \n \n 其中，「多 Reactor 单进程 / 线程」实现方案相比「单 Reactor 单进程 / 线程」方案，不仅复杂而且也没有性能优势，因此实际中并没有应用。 \n 剩下的 3 个方案都是比较经典的，且都有应用在实际的项目中： \n \n 单 Reactor 单进程 / 线程； \n 单 Reactor 多线程 / 进程； \n 多 Reactor 多进程 / 线程； \n \n 方案具体使用进程还是线程，要看使用的编程语言以及平台有关： \n \n Java 语言一般使用线程，比如 Netty; \n C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。 \n \n 接下来，分别介绍这三个经典的 Reactor 方案。 \n 一般来说，C 语言实现的是「 单 Reactor *单进程* 」的方案，因为 C 语编写完的程序，运行后就是一个独立的进程，不需要在进程中再创建线程。 \n 而 Java 语言实现的是「 单 Reactor *单线程* 」的方案，因为 Java 程序是跑在 Java 虚拟机这个进程上面的，虚拟机中有很多线程，我们写的 Java 程序只是其中的一个线程而已。 \n 单Reactor 单进程 \n 我们来看看「 单 Reactor 单进程 」的方案示意图： \n \n 可以看到进程里有  Reactor、Acceptor、Handler  这三个对象： \n \n Reactor 对象的作用是监听和分发事件； \n Acceptor 对象的作用是获取连接； \n Handler 对象的作用是处理业务； \n \n 对象里的 select、accept、read、send 是系统调用函数，dispatch 和 「业务处理」是需要完成的操作，其中 dispatch 是分发事件操作。 \n 接下来，介绍下「单 Reactor 单进程」这个方案： \n \n Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型； \n 如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件； \n 如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应； \n Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。 \n \n 单 Reactor 单进程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。 \n 但是，这种方案存在 2 个缺点： \n \n 第一个缺点，因为只有一个进程， 无法充分利用 多核 CPU 的性能 ； \n 第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的， 如果业务处理耗时比较长，那么就造成响应的延迟 ； \n \n 所以，单 Reactor 单进程的方案 不适用计算机密集型的场景，只适用于业务处理非常快速的场景 。 \n Redis 是由 C 语言实现的，在 Redis 6.0 版本之前采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。 \n 单 Reactor 多线程 / 多进程 \n 如果要克服「单 Reactor 单线程 / 进程」方案的缺点，那么就需要引入多线程 / 多进程，这样就产生了 单 Reactor 多线程 / 多进程 的方案。 \n 闻其名不如看其图，先来看看「单 Reactor 多线程」方案的示意图如下： \n \n 详细说一下这个方案： \n \n Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型； \n 如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件； \n 如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应； \n \n 上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了： \n \n Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理； \n 子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client； \n \n 单 Reator 多线程的方案优势在于 能够充分利用多核 CPU 的能 ，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。 \n 例如，子线程完成业务处理后，要把结果传递给主线程的 Handler 进行发送，这里涉及共享数据的竞争。 \n 要避免多线程由于竞争共享资源而导致数据错乱的问题，就需要在操作共享资源前加上互斥锁，以保证任意时间里只有一个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。 \n 聊完单 Reactor 多线程的方案，接着来看看单 Reactor 多进程的方案。 \n 事实上，单 Reactor 多进程相比单 Reactor 多线程实现起来很麻烦，主要因为要考虑子进程 <-> 父进程的双向通信，并且父进程还得知道子进程要将数据发送给哪个客户端。 \n 而多线程间可以共享数据，虽然要额外考虑并发问题，但是这远比进程间通信的复杂度低得多，因此实际应用中也 看不到单 Reactor 多进程的模式。 \n 另外，「单 Reactor」的模式还有个问题， 因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方 。 \n 多 Reactor 多进程 / 线程 \n 要解决「单 Reactor」的问题，就是将「单 Reactor」实现成「多 Reactor」，这样就产生了第  多 Reactor 多进程 / 线程 的方案。 \n 老规矩，闻其名不如看其图。多 Reactor 多进程 / 线程方案的示意图如下（以线程为例）： \n \n 方案详细说明如下： \n \n 主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程； \n 子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。 \n 如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。 \n Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。 \n \n 多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下： \n \n 主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。 \n 主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。 \n \n 大名鼎鼎的两个开源软件 Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案。 \n 采用了「多 Reactor 多进程」方案的开源软件是 Nginx，不过方案与标准的多 Reactor 多进程有些差异。 \n 具体差异表现在主进程中仅仅用来初始化 socket，并没有创建 mainReactor 来 accept 连接，而是由子进程的 Reactor 来 accept 连接，通过锁来控制一次只有一个子进程进行 accept（防止出现惊群现象），子进程 accept 新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程。 \n Proactor \n Reactor 是非阻塞同步网络模式，而 Proactor 是异步网络模式。 \n   阻塞I / O   ，当用户进程执行  read ，线程会被阻塞，一直等待内核数据准备好，并把数据从内核缓从内核缓冲区拷贝到应用程序的缓冲区中，拷贝完成后，read调用才会返回。   阻塞等待的是 ⌈内核数据准备好⌋ 和 ⌈数据从内核态拷贝到用户态⌋ 这两个过程。   \n \n   非阻塞I / O   ，非阻塞read在数据未准备好时立即返回，此时应用程序不断轮询查看内核数据是否准备好，没准备好就立即返回，当内核数据准备好时，再将数据从内核缓冲区拷贝到程序缓冲区， read  调用才会有结果。   此时最后一次read调用，从内核态获取数据到用户态的过程，是一个同步操作，是需要等待的过程。这里同步，就是指数据从内核态拷贝到用户态的过程。   (将Socket设置为  O_NONBLOCK  ，就表示该文件描述符读写方式为非阻塞) \n \n   异步I / O    则是「内核数据准备好」和「数据从内核态拷贝到用户态」这 两个过程都不用等待 。当我们发起  aio_read  (异步I/O) 之后，就立即返回，内核自动将数据从内核态拷贝到用户空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，   应用程序不需要主动发起拷贝动作。   \n \n Proactor 正是采用了异步 I/O 技术，所以被称为异步网络模型。 \n \n   Reactor 是非阻塞同步模型，感知的是就绪可读可写事件   。每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据拷贝到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。 \n   Proactor 是异步网络模式，感知的是已完成的读写事件   。在异步请求发起时，需要传入应用内存数据缓冲区地址（用于存放读写完成的结果）等信息，这样操作系统就可以自动地把数据读写工作完成，并自动地将最终处理好的数据放入应用进程内存中，而不需要像 Reactor 一样由引用进程主动发起 read/write 请求来读写数据，Proactor 模式中操作系统自动完成数据读写工作后，就会直接通知应用程序直接处理数据。 \n \n   Reactor就是 来了事件操作系统通知应用进程，让应用进程来处理   \n   Proactor就是 来了事件操作系统直接处理，处理完了再通知应用进程。   \n \n 这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I/O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。 \n \n 一个很贴切地例子   快递员送货到楼下通知你下来取快递和直接送货上门的区别 \n \n Reactor 就是快递员送快递到楼下，通知你来取；Proactor 就是快递员直接将快递送到门口。 \n \n 总结： \n 无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于  Reactor 模式是基于「待完成」的 I/O 事件，而 Proactor 模式则是基于「已完成」的 I/O 事件 。 \n Proactor流程图： \n \n Proactor流程解析： \n \n Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 通过 Asynchronous Operation Processor 注册到内核； \n Asynchronous Operation Processor 负责处理注册请求，并处理 I/O 操作； \n Asynchronous Operation Processor 处理完 I/O 请求之后就通知 Proactor； \n Proactor 根据不同的事件类型回调不同的Handler 进行业务处理； \n Handler 完成业务处理 \n \n 可惜的是，在 Linux 下的异步 I/O 是不完善的，  aio  系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。 \n 而 Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是  IOCP ，是由操作系统级别实现的异步 I/O，真正意义上异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。 \n \n Linux 的aio是用户空间模拟出来的，不是由操作系统实现的；而Windows的异步操作  IOCP  是操作系统级别实现的异步I/O，是真正意义上的异步 I/O. \n 一致性哈希 \n 问题：什么是一致性哈希，使用场景，解决了什么问题？ \n \n 如何分配请求？ \n 多数网站背后不止一台服务器，因为单机的并发量和数据量都是有限的，所以都会用多台服务器构成集群来对外提供服务。 \n 这就会引发新的问题：那么多节点该如何分配来自客户端的请求呢？（负载均衡问题） \n 最简单的方式，引入一个中间的负载均衡层 ，让它将外界的请求「轮流」的转发给内部的集群。比如集群有 3 个节点，外界请求有 3 个，那么每个节点都会处理 1 个请求，达到了分配请求的目的。 \n \n 考虑到每个节点的硬件配置有所区别，我们可以引入权重值，将硬件配置更好的节点的权重值设高，然后根据各个节点的权重值，按照一定比重分配在不同的节点上，让硬件配置更好的节点承担更多的请求，这种算法叫做 加权轮询 。 \n 加权轮询算法使用场景是建立在 每个节点存储的数据都是相同 的前提。所以，每次读数据的请求，访问任意一个节点都能得到结果。 \n 但是，加权轮询算法是无法应对「分布式系统（ 数据分片的系统 ）」的，因为 分布式系统中，每个节点存储的数据是不同的 。 \n 当我们想提高系统的容量，就会将数据水平切分到不同的节点来存储，也就是将数据分布到了不同的节点。比如 一个分布式 KV（key-valu） 缓存系统，某个 key 应该到哪个或者哪些节点上获得，应该是确定的 ，不是说任意访问一个节点都可以得到缓存结果的。 \n 因此，我们要想一个能应对分布式系统的负载均衡算法。 \n 负载均衡算法使用哈希算法有啥问题？ \n 有的同学可能很快就想到了： 哈希算法 。因为对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个 key 确定到一个节点了，可以满足分布式系统的负载均衡需求。 \n 哈希算法最简单的做法就是进行取模运算 ，比如分布式系统中有 3 个节点，基于  hash(key) % 3  公式对数据进行了映射。 \n 如果客户端要获取指定 key 的数据，通过下面的公式可以定位节点： \n hash ( key )   %   3 \n \n 但是有一个很致命的问题， 如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据 ，否则会出现查询不到数据的问题。 \n 要解决这个问题，就需要进行    数据迁移 ，节点数量改变，哈希函数改变，就需要重新对数据和节点做映射。 \n 假设总数据条数为 M，哈希算法在面对节点数量变化时， 最坏情况下所有数据都需要迁移，所以它的数据迁移规模是 O(M) ，这样数据的 迁移成本太高了 。 \n 所以，我们应该要重新想一个新的算法，来避免分布式系统在扩容或者缩容时，发生过多的数据迁移。 \n 使用一致性哈希有啥问题？ \n 一致性哈希就可以解决分布式系统在扩容或缩容时，发生过多数据迁移的问题。 \n 一致性哈希也用到了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致性哈希算法是对 2 ^ 32 进行取模运算，是一个固定值。 \n 我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为 哈希环 ，如下图： \n \n 一致性哈希要进行两步哈希： \n \n 第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希； \n 第二步：当对数据进行存储或访问时，对数据进行哈希映射； \n \n 所以， 一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上 。 \n 问题来了，对「数据」进行哈希映射得到一个结果要怎么找到存储该数据的节点呢？ \n 答案是，映射的结果值往 顺时针的方向的找到第一个节点 ，就是存储该数据的节点。 \n 下面是例子 \n 举个例子，有 3 个节点经过哈希计算，映射到了如下图的位置： \n \n 接着，对要查询的 key-01 进行哈希计算，确定此 key-01 映射在哈希环的位置，然后从这个位置往顺时针的方向找到第一个节点，就是存储该 key-01 数据的节点。 \n 比如，下图中的 key-01 映射的位置，往顺时针的方向找到第一个节点就是节点 A。 \n \n 所以，当需要对指定 key 的值进行读写的时候，要通过下面 2 步进行寻址： \n \n 首先，对 key 进行哈希计算，确定此 key 在环上的位置； \n 然后，从这个位置沿着顺时针方向走，遇到的第一节点就是存储 key 的节点。 \n \n 知道了一致哈希寻址的方式，我们来看看， 如果增加一个节点或者减少一个节点会发生大量的数据迁移吗？ \n 假设节点数量从 3 增加到了 4，新的节点 D 经过哈希计算后映射到了下图中的位置： \n \n 你可以看到，key-01、key-03 都不受影响，只有 key-02 需要被迁移节点 D。 \n 假设节点数量从 3 减少到了 2，比如将节点 A 移除： \n \n 你可以看到，key-02 和 key-03 不会受到影响，只有 key-01 需要被迁移节点 B。 \n 因此， 在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响 。 \n 上面这些图中 3 个节点映射在哈希环还是比较分散的，所以看起来请求都会「均衡」到每个节点。 \n 一致性哈希算法的问题： \n 但是  一致性哈希算法并不保证节点能够在哈希环上分布均匀 ，这样就会带来一个问题，会 有大量的请求集中在一个节点上 。 \n 比如，下图中 3 个节点的映射位置都在哈希环的右半边： \n \n 这时候有一半以上的数据的寻址都会找节点 A，也就是访问请求主要集中的节点 A 上，这肯定不行的呀，说好的负载均衡呢，这种情况一点都不均衡。 \n 另外，在这种节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，容易发生雪崩式的连锁反应。 \n 比如，上图中如果节点 A 被移除了，当节点 A 宕机后，根据一致性哈希算法的规则，其上数据应该全部迁移到相邻的节点 B 上，这样，节点 B 的数据量、访问量都会迅速增加很多倍，一旦新增的压力超过了节点 B 的处理能力上限，就会导致节点 B 崩溃，进而形成雪崩式的连锁反应。 \n 所以， 一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题 。 \n  \n 通过虚拟节点提高均衡度 \n 要想解决节点能在哈希环上分配不均匀的问题，就是要有大量的节点，节点数越多，哈希环上的节点分布的就越均匀。 \n 但问题是，实际中我们没有那么多节点。所以这个时候我们就加入 虚拟节点 ，也就是对一个真实节点做多个副本。 \n 具体做法是， 不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。 \n 比如对每个节点分别设置 3 个虚拟节点： \n \n 对节点 A 加上编号来作为虚拟节点：A-01、A-02、A-03 \n 对节点 B 加上编号来作为虚拟节点：B-01、B-02、B-03 \n 对节点 C 加上编号来作为虚拟节点：C-01、C-02、C-03 \n \n 引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍。 \n \n 可以看到，  节点数量变多了之后，节点在哈希环上的分布就相对均匀了 。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。 \n \n 上面为了便于理解，每个真实节点仅包含 3 个虚拟节点，这样能起到的均衡效果其实很有限。而在实际的工程中，虚拟节点的数量会大很多，比如 Nginx 的一致性哈希算法，每个权重为 1 的真实节点就含有160 个虚拟节点。 \n \n 另外，虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。 当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高 。 \n \n 比如，当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。 \n \n 而且，有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。 \n 因此， 带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景 。 \n'},{title:"计算机基础",frontmatter:{},regularPath:"/cs-basis/",relativePath:"cs-basis/README.md",key:"v-464a6c05",path:"/cs-basis/",content:" 计算机基础 \n 本目录主要用于补充计算机除数据结构与算法的其它相关知识。 \n 包括但不限于 编程语言、计算机组成、计算机网络、计算机操作系统的等知识。 \n"},{title:"Windows查看已经连接过的WiFi密码",frontmatter:{},regularPath:"/notes/1_Windows%E6%9F%A5%E7%9C%8BWiFi%E5%AF%86%E7%A0%81.html",relativePath:"notes/1_Windows查看WiFi密码.md",key:"v-27e95ee0",path:"/notes/1_Windows%E6%9F%A5%E7%9C%8BWiFi%E5%AF%86%E7%A0%81.html",content:' Windows查看已经连接过的WiFi密码 \n 转载自微信公众号 【青衣十三楼飞花堂】，作者：沈沉舟 \n // 确保wlansvc服务启动中，没有无线网络的台式机，该服务未启动\n$ sc query wlansvc  |  findstr STATE\n\n// 查看曾经连接过的无线网络\n$ netsh wlan show profiles\n\n// 若wlansvc服务未启动，上述命令报错\n$ netsh wlan show profiles\nThe Wireless AutoConfig Service  ( wlansvc )  is not running.\n\n// 假设一切顺利，如下命令可查看指定无线网络的明文密码\n// 如果是Windows 中文版，需要将  "Key Content"  替换为  "关键内容" \n$ netsh wlan show profiles  name = "xxx"   key = clear  |  findstr /C: "Key Content" \n    Key Content             :  XXXXXXXXXXXXXXXX\n \n PS: 记得使用cmd，使用PowerShell部分命令无输出 \n 贴一张图 \n \n cmd中输入以下命令就可以使用全英文命令了 \n $ chcp  437 \n \n '},{title:"随记",frontmatter:{},regularPath:"/notes/",relativePath:"notes/README.md",key:"v-2dd5a64b",path:"/notes/",content:" 随记 \n 本栏用于记录平时遇到的一些小技巧及一些不知如何分类的杂项。 \n"},{title:"snprintf导致的-Wformat-truncation警报",frontmatter:{},regularPath:"/notes/2_snprintf%E5%AF%BC%E8%87%B4%E7%9A%84-Wformat-truncation%E8%AD%A6%E6%8A%A5.html",relativePath:"notes/2_snprintf导致的-Wformat-truncation警报.md",key:"v-1f019c97",path:"/notes/2_snprintf%E5%AF%BC%E8%87%B4%E7%9A%84-Wformat-truncation%E8%AD%A6%E6%8A%A5.html",content:' snprintf导致的-Wformat-truncation警报 \n 遇到了两个  -Wformat-truncation  警报，其中一个比较让人困惑，记录一下 \n warning: ‘-’ directive output may be truncated writing  1  byte into a region of size between  0  and  16   [ -Wformat-truncation = ] \n \n 原始代码如下 \n \t char  dst_time [ 32 ]   =   { 0 } ; \n\t struct   timeval  tv ; \n\t struct   tm   * pm ; \n\t gettimeofday ( & tv ,   NULL ) ; \n\tpm  =   localtime ( ( time_t   * ) & tv . tv_sec ) ; \n     snprintf ( dst_time ,   sizeof ( dst_time ) ,  \n         "%04d-%02d-%02d-%02d-%02d-%02d-%03d" , \n        pm -> tm_year  +   1900 , \n        pm -> tm_mon  +   1 , \n        pm -> tm_mday , \n        pm -> tm_hour , \n        pm -> tm_min , \n        pm -> tm_sec , \n         ( int ) tv . tv_usec  /   1000 ) ; \n \n 报警直接原因 ：在snprintf的目标缓冲区有可能不足时，会引发阶段warning \n 此处  %02d  对于位数在2位以内的数，不会引发异常，其作为字符串输出的位数仍是2位，但是当位数大于等于3时其实并不会截断，因为截断会影响其原本的值，其正常输出如下： \n printf ( "%02d" ,   1 ) ;   // 输出01 \n printf ( "%02d" ,   23 ) ;   // 输出23 \n printf ( "%02d" ,   123 ) ;   // 输出123 \n \n 问题原因 ：所以对于上述问题，其问题是，对于占位字符串并不是按照%占位符后所设置的位数来计算的，而是按照int类别数的最大位数来计算的，int类别算上负号最大位数时 $-2 * 10^9$ 也就是 11位 \n 解决方法 ：所以  dst_time 的大小改成100就不会警告了。 \n \t char  dst_time [ 100 ]   =   { 0 } ; \n\t struct   timeval  tv ; \n\t struct   tm   * pm ; \n\t gettimeofday ( & tv ,   NULL ) ; \n\tpm  =   localtime ( ( time_t   * ) & tv . tv_sec ) ; \n     snprintf ( dst_time ,   sizeof ( dst_time ) ,  \n         "%04d-%02d-%02d-%02d-%02d-%02d-%03d" , \n        pm -> tm_year  +   1900 , \n        pm -> tm_mon  +   1 , \n        pm -> tm_mday , \n        pm -> tm_hour , \n        pm -> tm_min , \n        pm -> tm_sec , \n         ( int ) tv . tv_usec  /   1000 ) ; \n 扩展知识 \n 其它可以消除报警的方法记录： \n // 1.如果上述传入值范围本身有限制，那么可以不用增大目标缓冲区，就可以通过接收返回值的方式消除警报 \n\t int  ret  =   snprintf ( dst ,   sizeof ( dst ) ,   "%s!" ,  src ) ; \n     if   ( ret  <   0 )   { \n          abort ( ) ; \n     } \n\n // 2.使用编译宏 \n     // use compiler specific pragmas to disable the warning \npragma   GCC diagnostic push \npragma   GCC diagnostic ignored  "-Wformat-truncation" \n     snprintf ( dst ,   sizeof ( dst ) ,   "%s!" ,   "a" ) ; \npragma   GCC diagnostic pop \n\n // 3.使用volatile关键字 \n volatile   int  dst_size  =   sizeof ( dst ) ; \n snprintf ( dst ,  dst_size ,   "%s!" ,   "a" ) ; \n \n volatile \n volatile是一个 类型修饰符 （type specifier），就像我们熟悉的const一样，它是被设计用来修饰被不同线程访问和修改的 变量 ；volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。 \n volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。 \n'}],themeConfig:{logo:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/terminal.svg",nav:[{text:"Home",link:"/"},{text:"计算机基础",link:"/cs-basis/"},{text:"算法刷题",link:"/algorithm/"},{text:"随记",link:"/notes/"},{text:"Github",link:"https://github.com/feobay"}],sidebar:{"/cs-basis/":["","1_C++","2_EffectiveC++","3_STL源码剖析","4_ComputerNetwork","5_操作系统","6_计算机体系结构"],"/algorithm/":["","1_Acwing算法基础课","2_LeetCode","3_数据结构"],"/notes/":["","1_Windows查看WiFi密码","2_snprintf导致的-Wformat-truncation警报"],"/":[""]},lastUpdated:"Last Updated",smoothScroll:!0,sidebarDepth:3}};e(235);Ge.component("Badge",()=>Promise.all([e.e(0),e.e(4)]).then(e.bind(null,308))),Ge.component("CodeBlock",()=>Promise.all([e.e(0),e.e(5)]).then(e.bind(null,304))),Ge.component("CodeGroup",()=>Promise.all([e.e(0),e.e(6)]).then(e.bind(null,305)));e(236),e(237);function $s(n){const t=document.documentElement.getBoundingClientRect(),e=n.getBoundingClientRect();return{x:e.left-t.left,y:e.top-t.top}}var Is=[{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({Vue:n,router:t})=>{t.options.scrollBehavior=(t,e,r)=>{if(r)return window.scrollTo({top:r.y,behavior:"smooth"});if(t.hash){if(n.$vuepress.$get("disableScrollBehavior"))return!1;const e=document.querySelector(t.hash);return!!e&&window.scrollTo({top:$s(e).y,behavior:"smooth"})}return window.scrollTo({top:0,behavior:"smooth"})}}],Rs=[];class Ms extends class{constructor(){this.store=new Ge({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,t){Ge.set(this.store.state,n,t)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Ms.prototype,{getPageAsyncComponent:ss,getLayoutAsyncComponent:cs,getAsyncComponent:ls,getVueComponent:us});var Ds={install(n){const t=new Ms;n.$vuepress=t,n.prototype.$vuepress=t}};function Us(n,t){const e=t.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===e)}var zs={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const t=this.pageKey||this.$parent.$page.key;return ds("pageKey",t),Ge.component(t)||Ge.component(t,ss(t)),Ge.component(t)?n(t):n("")}},Fs={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:t,slots:e})=>n("div",{class:["content__"+t.slotKey]},e()[t.slotKey])},Hs={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},qs=(e(238),e(239),Object(Es.a)(Hs,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Ws={functional:!0,render(n,{parent:t,children:e}){if(t._isMounted)return e;t.$once("hook:mounted",()=>{t.$forceUpdate()})}};Ge.config.productionTip=!1,Ge.use(Wa),Ge.use(Ds),Ge.mixin(function(n,t,e=Ge){!function(n){n.locales&&Object.keys(n.locales).forEach(t=>{n.locales[t].path=t});Object.freeze(n)}(t),e.$vuepress.$set("siteData",t);const r=new(n(e.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),o={};return Object.keys(i).reduce((n,t)=>(t.startsWith("$")&&(n[t]=i[t].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let t,e;for(const r in n)"/"===r?e=n[r]:0===this.$page.path.indexOf(r)&&(t=n[r]);return t||e||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:t}=this.$page.frontmatter;if("string"==typeof t)return t;const e=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return e?r?r+" | "+e:e:r||"VuePress"}get $description(){const n=function(n){if(n){const t=n.filter(n=>"description"===n.name)[0];if(t)return t.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(r.path.toLowerCase()===t.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},Bs)),Ge.component("Content",zs),Ge.component("ContentSlotsDistributor",Fs),Ge.component("OutboundLink",qs),Ge.component("ClientOnly",Ws),Ge.component("Layout",cs("Layout")),Ge.component("NotFound",cs("NotFound")),Ge.prototype.$withBase=function(n){const t=this.$site.base;return"/"===n.charAt(0)?t+n.slice(1):n},window.__VUEPRESS__={version:"1.9.10",hash:""},async function(n){const t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Bs.routerBase||Bs.base,e=new Wa({base:t,mode:"history",fallback:!1,routes:Ts,scrollBehavior:(n,t,e)=>e||(n.hash?!Ge.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((t,e,r)=>{if(Us(n,t.path))r();else if(/(\/|\.html)$/.test(t.path))if(/\/$/.test(t.path)){const e=t.path.replace(/\/$/,"")+".html";Us(n,e)?r(e):r()}else r();else{const e=t.path+"/",i=t.path+".html";Us(n,i)?r(i):Us(n,e)?r(e):r()}})}(e);const r={};try{await Promise.all(Is.filter(n=>"function"==typeof n).map(t=>t({Vue:Ge,options:r,router:e,siteData:Bs,isServer:n})))}catch(n){console.error(n)}return{app:new Ge(Object.assign(r,{router:e,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Rs.map(t=>n(t)))])})),router:e}}(!1).then(({app:n,router:t})=>{t.onReady(()=>{n.$mount("#app")})})}]);